memory > xGetLanguageInfoListNode
memory > xsingular
memory > xTranslateNode
memory > xtoken_kwargs
memory > xIndexError
memory > xvar
memory > xException
memory > xmark_safe
memory > xfloat
memory > xDecimal
memory > xnext
memory > xLibrary
memory > xplural_vars
memory > xk
memory > xNode
memory > xlang
memory > xBlockTranslateNode
memory > xTemplateSyntaxError
memory > xtoken
memory > xtranslation
memory > xcounter
memory > xLanguageNode
memory > xValueError
memory > xstr
memory > xcountervar
memory > xSafeData
memory > xrender_value_in_context
memory > xKeyError
memory > xGetCurrentLanguageNode
memory > xGetLanguageInfoNode
memory > xGetCurrentLanguageBidiNode
memory > xTokenType
memory > xplural
memory > xset
memory > xsettings
memory > xint
memory > xVariable
memory > xGetAvailableLanguagesNode
memory > xval
memory > xv
memory > xvars
memory > xiter
memory > xisinstance
memory > xlen
[] > i18n
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xdo_get_language_info
        memory > xdo_block_translate
        memory > xdo_translate
        memory > xdo_get_current_language_bidi
        memory > xregister
        memory > xget_language_info
        memory > xrender
        memory > xchild_nodelists
        memory > xlanguage
        memory > x__init__
        memory > xdo_get_language_info_list
        memory > xlanguage_bidi
        memory > x__repr__
        memory > xlanguage_name_local
        memory > xdo_get_current_language
        memory > xdo_get_available_languages
        memory > xlanguage_name_translated
        memory > xlanguage_name
        memory > xrender_token_list
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            xregister.write (((xLibrary)).apply)
            (((unsupported)).apply ((xNode)))
              seq
                x__init__.write
                  [xself xvariable]
                    seq > @
                      (((unsupported)).apply (((xself).xvariable)) ((xvariable)))
                xrender.write
                  [xself xcontext]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xvariable)))) ((((unsupported)).apply ((((unsupported)).apply ((xk)) (((((xtranslation).xgettext)).apply ((xv)))))) ((((unsupported)).apply ((xk)) ((xv)))) (((xsettings).xLANGUAGES)))))
                        (((unsupported)).apply (""))
            (((unsupported)).apply ((xNode)))
              seq
                x__init__.write
                  [xself xlang_code xvariable]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xlang_code)) ((xlang_code)))
                        (((unsupported)).apply (((xself).xvariable)) ((xvariable)))
                xrender.write
                  [xself xcontext]
                    memory > xlang_code
                    seq > @
                      seq
                        xlang_code.write (((((xself).xlang_code).xresolve)).apply ((xcontext)))
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xvariable)))) (((((xtranslation).xget_language_info)).apply ((xlang_code)))))
                        (((unsupported)).apply (""))
            (((unsupported)).apply ((xNode)))
              seq
                x__init__.write
                  [xself xlanguages xvariable]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xlanguages)) ((xlanguages)))
                        (((unsupported)).apply (((xself).xvariable)) ((xvariable)))
                xget_language_info.write
                  [xself xlanguage]
                    seq > @
                      ((((xlen)).apply ((((unsupported)).apply ((xlanguage)) (0)))).greater 1).if
                        (((unsupported)).apply (((((xtranslation).xget_language_info)).apply ((((unsupported)).apply ((xlanguage)) (0))))))
                        (((unsupported)).apply (((((xtranslation).xget_language_info)).apply ((((xstr)).apply ((xlanguage)))))))
                xrender.write
                  [xself xcontext]
                    memory > xlangs
                    seq > @
                      seq
                        xlangs.write (((((xself).xlanguages).xresolve)).apply ((xcontext)))
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xvariable)))) ((((unsupported)).apply (((((xself).xget_language_info)).apply ((xlang)))) ((xlang)) ((xlangs)))))
                        (((unsupported)).apply (""))
            (((unsupported)).apply ((xNode)))
              seq
                x__init__.write
                  [xself xvariable]
                    seq > @
                      (((unsupported)).apply (((xself).xvariable)) ((xvariable)))
                xrender.write
                  [xself xcontext]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xvariable)))) (((((xtranslation).xget_language)).apply)))
                        (((unsupported)).apply (""))
            (((unsupported)).apply ((xNode)))
              seq
                x__init__.write
                  [xself xvariable]
                    seq > @
                      (((unsupported)).apply (((xself).xvariable)) ((xvariable)))
                xrender.write
                  [xself xcontext]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xvariable)))) (((((xtranslation).xget_language_bidi)).apply)))
                        (((unsupported)).apply (""))
            (((unsupported)).apply ((xNode)))
              seq
                xchild_nodelists.write (((unsupported)).apply)
                x__init__.write
                  [xself xfilter_expression xnoop xasvar xmessage_context]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xnoop)) ((xnoop)))
                        (((unsupported)).apply (((xself).xasvar)) ((xasvar)))
                        (((unsupported)).apply (((xself).xmessage_context)) ((xmessage_context)))
                        (((unsupported)).apply (((xself).xfilter_expression)) ((xfilter_expression)))
                        (((xisinstance)).apply ((((xself).xfilter_expression).xvar)) ((xstr))).if
                          seq
                            (((unsupported)).apply ((((xself).xfilter_expression).xis_var)) (TRUE))
                            (((unsupported)).apply ((((xself).xfilter_expression).xvar)) ((((xVariable)).apply (("'%s'".mod (((xself).xfilter_expression).xvar))))))
                xrender.write
                  [xself xcontext]
                    memory > xvalue
                    memory > xis_safe
                    memory > xoutput
                    seq > @
                      seq
                        (((unsupported)).apply (((((xself).xfilter_expression).xvar).xtranslate)) ((((xself).xnoop).not)))
                        ((xself).xmessage_context).if
                          (((unsupported)).apply (((((xself).xfilter_expression).xvar).xmessage_context)) ((((((xself).xmessage_context).xresolve)).apply ((xcontext)))))
                        xoutput.write (((((xself).xfilter_expression).xresolve)).apply ((xcontext)))
                        xvalue.write (((xrender_value_in_context)).apply ((xoutput)) ((xcontext)))
                        xis_safe.write (((xisinstance)).apply ((xvalue)) ((xSafeData)))
                        xvalue.write ((((xvalue).xreplace)).apply ("%%") ("%"))
                        xvalue.write ((xis_safe).if (((xmark_safe)).apply ((xvalue))) (xvalue))
                        ((xself).xasvar).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xasvar)))) ((xvalue)))
                            (((unsupported)).apply (""))
                          (((unsupported)).apply ((xvalue)))
            (((unsupported)).apply ((xNode)))
              seq
                x__init__.write
                  [xself xextra_context xsingular xplural xcountervar xcounter xmessage_context xtrimmed xasvar xtag_name]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xextra_context)) ((xextra_context)))
                        (((unsupported)).apply (((xself).xsingular)) ((xsingular)))
                        (((unsupported)).apply (((xself).xplural)) ((xplural)))
                        (((unsupported)).apply (((xself).xcountervar)) ((xcountervar)))
                        (((unsupported)).apply (((xself).xcounter)) ((xcounter)))
                        (((unsupported)).apply (((xself).xmessage_context)) ((xmessage_context)))
                        (((unsupported)).apply (((xself).xtrimmed)) ((xtrimmed)))
                        (((unsupported)).apply (((xself).xasvar)) ((xasvar)))
                        (((unsupported)).apply (((xself).xtag_name)) ((xtag_name)))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("<{self.__class__.__qualname__}: extra_context={self.extra_context!r} singular={self.singular!r} plural={self.plural!r}>"))
                xrender_token_list.write
                  [xself xtokens]
                    memory > xvars
                    memory > xresult
                    memory > xmsg
                    seq > @
                      seq
                        xresult.write (((unsupported)).apply)
                        xvars.write (((unsupported)).apply)
                        (((unsupported)).apply ((xtoken)) ((xtokens)))
                          (((xtoken).xtoken_type).eq ((xTokenType).xTEXT)).if
                            bogusForceDataize.write ((((xresult).xappend)).apply ((((((xtoken).xcontents).xreplace)).apply ("%") ("%%"))))
                            (((xtoken).xtoken_type).eq ((xTokenType).xVAR)).if
                              seq
                                bogusForceDataize.write ((((xresult).xappend)).apply (("%%(%s)s".mod ((xtoken).xcontents))))
                                bogusForceDataize.write ((((xvars).xappend)).apply (((xtoken).xcontents)))
                        xmsg.write ((("".xjoin)).apply ((xresult)))
                        ((xself).xtrimmed).if
                          xmsg.write ((((xtranslation).xtrim_whitespace)).apply ((xmsg)))
                        (((unsupported)).apply ((((unsupported)).apply ((xmsg)) ((xvars)))))
                xrender.write
                  [xself xcontext xnested]
                    memory > xdefault_value
                    memory > xmessage_context
                    memory > xcount
                    memory > xdata
                    memory > xresult
                    memory > xrender_value
                    seq > @
                      (((unsupported)).apply)
                        ((xself).xmessage_context).if
                          xmessage_context.write (((((xself).xmessage_context).xresolve)).apply ((xcontext)))
                          xmessage_context.write "None: is there a None literal in the EO language?"
                        bogusForceDataize.write ((((xcontext).xupdate)).apply ((((unsupported)).apply ((xvar)) (((((xval).xresolve)).apply ((xcontext)))) ((((unsupported)).apply ((xvar)) ((xval)))) ((((((xself).xextra_context).xitems)).apply)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xsingular)) ((xvars)))) (((((xself).xrender_token_list)).apply (((xself).xsingular)))))
                        ((((xself).xplural).and ((xself).xcountervar)).and ((xself).xcounter)).if
                          seq
                            xcount.write (((((xself).xcounter).xresolve)).apply ((xcontext)))
                            ((((xisinstance)).apply ((xcount)) ((((unsupported)).apply ((xDecimal)) ((xfloat)) ((xint))))).not).if
                              (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("%r argument to %r tag must be a number.".mod (((unsupported)).apply (((xself).xcountervar)) (((xself).xtag_name))))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xcountervar)))) ((xcount)))
                            (((unsupported)).apply ((((unsupported)).apply ((xplural)) ((xplural_vars)))) (((((xself).xrender_token_list)).apply (((xself).xplural)))))
                            (xmessage_context).if
                              xresult.write ((((xtranslation).xnpgettext)).apply ((xmessage_context)) ((xsingular)) ((xplural)) ((xcount)))
                              xresult.write ((((xtranslation).xngettext)).apply ((xsingular)) ((xplural)) ((xcount)))
                            bogusForceDataize.write ((((xvars).xextend)).apply ((xplural_vars)))
                          (xmessage_context).if
                            xresult.write ((((xtranslation).xpgettext)).apply ((xmessage_context)) ((xsingular)))
                            xresult.write ((((xtranslation).xgettext)).apply ((xsingular)))
                        xdefault_value.write ((((xcontext).xtemplate).xengine).xstring_if_invalid)
                        xrender_value.write
                          [xkey]
                            memory > xval
                            seq > @
                              seq
                                (((unsupported)).apply ((xkey)) ((xcontext))).if
                                  xval.write (((unsupported)).apply ((xcontext)) ((xkey)))
                                  xval.write ((((unsupported)).apply ("%s") ((xdefault_value))).if ((xdefault_value).mod (xkey)) (xdefault_value))
                                (((unsupported)).apply ((((xrender_value_in_context)).apply ((xval)) ((xcontext)))))
                        xdata.write (((unsupported)).apply ((xv)) ((((xrender_value)).apply ((xv)))) ((xv)) ((xvars)))
                        bogusForceDataize.write ((((xcontext).xpop)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xKeyError)) ((xValueError)))))
                          xresult.write ((xresult).mod (xdata))
                          seq
                            (xnested).if
                              (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("%r is unable to format string returned by gettext: %r using %r".mod (((unsupported)).apply (((xself).xtag_name)) ((xresult)) ((xdata))))))))
                            (((unsupported)).apply (((((xtranslation).xoverride)).apply ("None: is there a None literal in the EO language?"))))
                              xresult.write (((unsupported)).apply (((xself).xrender)) ((xcontext)) (TRUE))
                        ((xself).xasvar).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xcontext)) (((xself).xasvar)))) ((xresult)))
                            (((unsupported)).apply (""))
                          (((unsupported)).apply ((xresult)))
            (((unsupported)).apply ((xNode)))
              seq
                x__init__.write
                  [xself xnodelist xlanguage]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xnodelist)) ((xnodelist)))
                        (((unsupported)).apply (((xself).xlanguage)) ((xlanguage)))
                xrender.write
                  [xself xcontext]
                    memory > xoutput
                    seq > @
                      seq
                        (((unsupported)).apply (((((xtranslation).xoverride)).apply ((((((xself).xlanguage).xresolve)).apply ((xcontext)))))))
                          xoutput.write (((((xself).xnodelist).xrender)).apply ((xcontext)))
                        (((unsupported)).apply ((xoutput)))
            xdo_get_available_languages.write
              [xparser xtoken]
                memory > xargs
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xargs.write (((((xtoken).xcontents).xsplit)).apply)
                    (((((xlen)).apply ((xargs))).neq 3).or ((((unsupported)).apply ((xargs)) (1)).neq "as")).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("'get_available_languages' requires 'as variable' (got %r)".mod (xargs))))))
                    (((unsupported)).apply ((((xGetAvailableLanguagesNode)).apply ((((unsupported)).apply ((xargs)) (2))))))
            xdo_get_language_info.write
              [xparser xtoken]
                memory > xargs
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xargs.write ((((xtoken).xsplit_contents)).apply)
                    ((((((xlen)).apply ((xargs))).neq 5).or ((((unsupported)).apply ((xargs)) (1)).neq "for")).or ((((unsupported)).apply ((xargs)) (3)).neq "as")).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("'%s' requires 'for string as variable' (got %r)".mod (((unsupported)).apply ((((unsupported)).apply ((xargs)) (0))) ((((unsupported)).apply ((xargs)) ((((unsupported)).apply (1)))))))))))
                    (((unsupported)).apply ((((xGetLanguageInfoNode)).apply (((((xparser).xcompile_filter)).apply ((((unsupported)).apply ((xargs)) (2))))) ((((unsupported)).apply ((xargs)) (4))))))
            xdo_get_language_info_list.write
              [xparser xtoken]
                memory > xargs
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xargs.write ((((xtoken).xsplit_contents)).apply)
                    ((((((xlen)).apply ((xargs))).neq 5).or ((((unsupported)).apply ((xargs)) (1)).neq "for")).or ((((unsupported)).apply ((xargs)) (3)).neq "as")).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("'%s' requires 'for sequence as variable' (got %r)".mod (((unsupported)).apply ((((unsupported)).apply ((xargs)) (0))) ((((unsupported)).apply ((xargs)) ((((unsupported)).apply (1)))))))))))
                    (((unsupported)).apply ((((xGetLanguageInfoListNode)).apply (((((xparser).xcompile_filter)).apply ((((unsupported)).apply ((xargs)) (2))))) ((((unsupported)).apply ((xargs)) (4))))))
            xlanguage_name.write
              [xlang_code]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply (((((xtranslation).xget_language_info)).apply ((xlang_code)))) ("name"))))
            xlanguage_name_translated.write
              [xlang_code]
                memory > xenglish_name
                seq > @
                  (((unsupported)).apply)
                    xenglish_name.write (((unsupported)).apply (((((xtranslation).xget_language_info)).apply ((xlang_code)))) ("name"))
                    (((unsupported)).apply (((((xtranslation).xgettext)).apply ((xenglish_name)))))
            xlanguage_name_local.write
              [xlang_code]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply (((((xtranslation).xget_language_info)).apply ((xlang_code)))) ("name_local"))))
            xlanguage_bidi.write
              [xlang_code]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply (((((xtranslation).xget_language_info)).apply ((xlang_code)))) ("bidi"))))
            xdo_get_current_language.write
              [xparser xtoken]
                memory > xargs
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xargs.write (((((xtoken).xcontents).xsplit)).apply)
                    (((((xlen)).apply ((xargs))).neq 3).or ((((unsupported)).apply ((xargs)) (1)).neq "as")).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("'get_current_language' requires 'as variable' (got %r)".mod (xargs))))))
                    (((unsupported)).apply ((((xGetCurrentLanguageNode)).apply ((((unsupported)).apply ((xargs)) (2))))))
            xdo_get_current_language_bidi.write
              [xparser xtoken]
                memory > xargs
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xargs.write (((((xtoken).xcontents).xsplit)).apply)
                    (((((xlen)).apply ((xargs))).neq 3).or ((((unsupported)).apply ((xargs)) (1)).neq "as")).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("'get_current_language_bidi' requires 'as variable' (got %r)".mod (xargs))))))
                    (((unsupported)).apply ((((xGetCurrentLanguageBidiNode)).apply ((((unsupported)).apply ((xargs)) (2))))))
            xdo_translate.write
              [xparser xtoken]
                memory > xbits
                memory > xinvalid_context
                memory > xoption
                memory > xvalue
                memory > xnoop
                memory > xasvar
                memory > xmessage_context
                memory > xseen
                memory > xremaining
                memory > xmessage_string
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xbits.write ((((xtoken).xsplit_contents)).apply)
                    ((((xlen)).apply ((xbits))).less 2).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("'%s' takes at least one argument".mod (((unsupported)).apply ((xbits)) (0)))))))
                    xmessage_string.write ((((xparser).xcompile_filter)).apply ((((unsupported)).apply ((xbits)) (1))))
                    xremaining.write (((unsupported)).apply ((xbits)) ((((unsupported)).apply (2))))
                    xnoop.write FALSE
                    xasvar.write "None: is there a None literal in the EO language?"
                    xmessage_context.write "None: is there a None literal in the EO language?"
                    xseen.write (((xset)).apply)
                    xinvalid_context.write (((unsupported)).apply ("as") ("noop"))
                    while.
                      (xremaining)
                      [unused]
                        seq > @
                          seq
                            xoption.write ((((xremaining).xpop)).apply (0))
                            (((unsupported)).apply ((xoption)) ((xseen))).if
                              (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("The '%s' option was specified more than once.".mod (xoption))))))
                              ((xoption).eq "noop").if
                                xnoop.write TRUE
                                ((xoption).eq "context").if
                                  seq
                                    (((unsupported)).apply ((xIndexError)))
                                      xvalue.write ((((xremaining).xpop)).apply (0))
                                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("No argument provided to the '%s' tag for the context option.".mod (((unsupported)).apply ((xbits)) (0)))))))
                                    (((unsupported)).apply ((xvalue)) ((xinvalid_context))).if
                                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("Invalid argument '%s' provided to the '%s' tag for the context option".mod (((unsupported)).apply ((xvalue)) ((((unsupported)).apply ((xbits)) (0)))))))))
                                    xmessage_context.write ((((xparser).xcompile_filter)).apply ((xvalue)))
                                  ((xoption).eq "as").if
                                    seq
                                      (((unsupported)).apply ((xIndexError)))
                                        xvalue.write ((((xremaining).xpop)).apply (0))
                                        (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("No argument provided to the '%s' tag for the as option.".mod (((unsupported)).apply ((xbits)) (0)))))))
                                      xasvar.write (xvalue)
                                    (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("Unknown argument for '%s' tag: '%s'. The only options available are 'noop', 'context' \"xxx\", and 'as VAR'.".mod (((unsupported)).apply ((((unsupported)).apply ((xbits)) (0))) ((xoption))))))))
                            bogusForceDataize.write ((((xseen).xadd)).apply ((xoption)))
                    (((unsupported)).apply ((((xTranslateNode)).apply ((xmessage_string)) ((xnoop)) ((xasvar)) ((xmessage_context)))))
            xdo_block_translate.write
              [xparser xtoken]
                memory > xbits
                memory > xsingular
                memory > xoption
                memory > xend_tag_name
                memory > xplural
                memory > xasvar
                memory > xmessage_context
                memory > xextra_context
                memory > xremaining_bits
                memory > xvalue
                memory > xtrimmed
                memory > xoptions
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xbits.write ((((xtoken).xsplit_contents)).apply)
                    xoptions.write (((unsupported)).apply)
                    xremaining_bits.write (((unsupported)).apply ((xbits)) ((((unsupported)).apply (1))))
                    xasvar.write "None: is there a None literal in the EO language?"
                    while.
                      (xremaining_bits)
                      [unused]
                        seq > @
                          seq
                            xoption.write ((((xremaining_bits).xpop)).apply (0))
                            (((unsupported)).apply ((xoption)) ((xoptions))).if
                              (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("The %r option was specified more than once.".mod (xoption))))))
                            ((xoption).eq "with").if
                              seq
                                xvalue.write (((unsupported)).apply ((xtoken_kwargs)) ((xremaining_bits)) ((xparser)) (TRUE))
                                ((xvalue).not).if
                                  (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("\"with\" in %r tag needs at least one keyword argument.".mod (((unsupported)).apply ((xbits)) (0)))))))
                              ((xoption).eq "count").if
                                seq
                                  xvalue.write (((unsupported)).apply ((xtoken_kwargs)) ((xremaining_bits)) ((xparser)) (TRUE))
                                  ((((xlen)).apply ((xvalue))).neq 1).if
                                    (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("\"count\" in %r tag expected exactly one keyword argument.".mod (((unsupported)).apply ((xbits)) (0)))))))
                                ((xoption).eq "context").if
                                  (((unsupported)).apply ((xException)))
                                    seq
                                      xvalue.write ((((xremaining_bits).xpop)).apply (0))
                                      xvalue.write ((((xparser).xcompile_filter)).apply ((xvalue)))
                                    (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("\"context\" in %r tag expected exactly one argument.".mod (((unsupported)).apply ((xbits)) (0)))))))
                                  ((xoption).eq "trimmed").if
                                    xvalue.write TRUE
                                    ((xoption).eq "asvar").if
                                      seq
                                        (((unsupported)).apply ((xIndexError)))
                                          xvalue.write ((((xremaining_bits).xpop)).apply (0))
                                          (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("No argument provided to the '%s' tag for the asvar option.".mod (((unsupported)).apply ((xbits)) (0)))))))
                                        xasvar.write (xvalue)
                                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("Unknown argument for %r tag: %r.".mod (((unsupported)).apply ((((unsupported)).apply ((xbits)) (0))) ((xoption))))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xoptions)) ((xoption)))) ((xvalue)))
                    (((unsupported)).apply ("count") ((xoptions))).if
                      (((unsupported)).apply ((((unsupported)).apply ((xcountervar)) ((xcounter)))) ((((xnext)).apply ((((xiter)).apply (((((((unsupported)).apply ((xoptions)) ("count")).xitems)).apply)))))))
                      (((unsupported)).apply ((((unsupported)).apply ((xcountervar)) ((xcounter)))) ((((unsupported)).apply ("None: is there a None literal in the EO language?") ("None: is there a None literal in the EO language?"))))
                    (((unsupported)).apply ("context") ((xoptions))).if
                      xmessage_context.write (((unsupported)).apply ((xoptions)) ("context"))
                      xmessage_context.write "None: is there a None literal in the EO language?"
                    xextra_context.write ((((xoptions).xget)).apply ("with") ((((unsupported)).apply)))
                    xtrimmed.write ((((xoptions).xget)).apply ("trimmed") (FALSE))
                    xsingular.write (((unsupported)).apply)
                    xplural.write (((unsupported)).apply)
                    while.
                      ((xparser).xtokens)
                      [unused]
                        seq > @
                          seq
                            xtoken.write ((((xparser).xnext_token)).apply)
                            (((unsupported)).apply (((xtoken).xtoken_type)) ((((unsupported)).apply (((xTokenType).xVAR)) (((xTokenType).xTEXT))))).if
                              bogusForceDataize.write ((((xsingular).xappend)).apply ((xtoken)))
                              (((unsupported)).apply)
                    ((xcountervar).and (xcounter)).if
                      seq
                        ((((((xtoken).xcontents).xstrip)).apply).neq "plural").if
                          (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("%r doesn't allow other block tags inside it".mod (((unsupported)).apply ((xbits)) (0)))))))
                        while.
                          ((xparser).xtokens)
                          [unused]
                            seq > @
                              seq
                                xtoken.write ((((xparser).xnext_token)).apply)
                                (((unsupported)).apply (((xtoken).xtoken_type)) ((((unsupported)).apply (((xTokenType).xVAR)) (((xTokenType).xTEXT))))).if
                                  bogusForceDataize.write ((((xplural).xappend)).apply ((xtoken)))
                                  (((unsupported)).apply)
                    xend_tag_name.write ("end%s".mod (((unsupported)).apply ((xbits)) (0)))
                    ((((((xtoken).xcontents).xstrip)).apply).neq (xend_tag_name)).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("%r doesn't allow other block tags (seen %r) inside it".mod (((unsupported)).apply ((((unsupported)).apply ((xbits)) (0))) (((xtoken).xcontents))))))))
                    (((unsupported)).apply ((((unsupported)).apply ((xBlockTranslateNode)) ((xextra_context)) ((xsingular)) ((xplural)) ((xcountervar)) ((xcounter)) ((xmessage_context)) ((xtrimmed)) ((xasvar)) ((((unsupported)).apply ((xbits)) (0))))))
            xlanguage.write
              [xparser xtoken]
                memory > xbits
                memory > xlanguage
                memory > xnodelist
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xbits.write ((((xtoken).xsplit_contents)).apply)
                    ((((xlen)).apply ((xbits))).neq 2).if
                      (((unsupported)).apply ((((xTemplateSyntaxError)).apply (("'%s' takes one argument (language)".mod (((unsupported)).apply ((xbits)) (0)))))))
                    xlanguage.write ((((xparser).xcompile_filter)).apply ((((unsupported)).apply ((xbits)) (1))))
                    xnodelist.write ((((xparser).xparse)).apply ((((unsupported)).apply ("endlanguage"))))
                    bogusForceDataize.write ((((xparser).xdelete_first_token)).apply)
                    (((unsupported)).apply ((((xLanguageNode)).apply ((xnodelist)) ((xlanguage)))))