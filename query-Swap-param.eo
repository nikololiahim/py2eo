memory > xCount
memory > xAND
memory > xk
memory > xNode
memory > xfinal_field
memory > xJoinPromoter
memory > xcopy
memory > xjoin_list
memory > xDEFAULT_DB_ALIAS
memory > xfilter_lhs
memory > xfield
memory > xIterator
memory > xrelation_field_parts
memory > xmin
memory > xchild_clause
memory > xvalues
memory > xINNER
memory > xtrimmed_prefix
memory > xc
memory > xordering
memory > xAttributeError
memory > xFieldDoesNotExist
memory > xtable
memory > xRef
memory > xcount
memory > xcolumn_meta
memory > xlist
memory > xRuntimeError
memory > xenumerate
memory > xtargets
memory > xdifflib
memory > xexpression_lookups
memory > xcheck_rel_lookup_compatibility
memory > xOuterRef
memory > xneeded_inner
memory > xparts
memory > xValueError
memory > xfrozenset
memory > xstr
memory > xQ
memory > xselected_annotation
memory > xnames_with_path
memory > xFieldError
memory > xlookups
memory > xinfo
memory > xfields
memory > xcombined_query
memory > xproduct
memory > xRawQuery
memory > xt
memory > xpivot
memory > xSINGLE
memory > xpos
memory > xrelation_lookup_parts
memory > xLOOKUP_SEP
memory > xannotation
memory > xjoins
memory > xrest
memory > xrange
memory > xfinal_alias
memory > xexpr
memory > xvalue
memory > xcur_refcount
memory > xpart
memory > xWhereNode
memory > xOR
memory > xalias
memory > xQuery
memory > xResolvedOuterRef
memory > xprefix
memory > x_
memory > xint_model
memory > xField
memory > xNothingNode
memory > xMultiJoin
memory > xnamedtuple
memory > xp
memory > xfield_names
memory > xpaths
memory > xnew_alias
memory > xreversed
memory > xany
memory > xtype
memory > xcallable
memory > xpath
memory > xf
memory > xset
memory > xlookup
memory > xBaseExpression
memory > xcol
memory > xhasattr
memory > xCounter
memory > xr
memory > xconnections
memory > xdefer
memory > xExists
memory > xparams
memory > xNotSupportedError
memory > xF
memory > xarg
memory > xexisting
memory > xs
memory > xsys
memory > xbool
memory > xlookup_field_part
memory > xquery
memory > xtuple
memory > xMapping
memory > xNotImplemented
memory > xRecursionError
memory > xold_alias
memory > xchr
memory > xaliased
memory > xinner_pos
memory > xsorted
memory > xargs
memory > xLOUTER
memory > xascii_uppercase
memory > xBaseTable
memory > xchild
memory > xgetattr
memory > xv
memory > xid
memory > xtrimmed_paths
memory > xval
memory > xCol
memory > xiter
memory > xe
memory > xexpression
memory > xsql
memory > xLookup
memory > xtarget
memory > xlookup_field_parts
memory > xsub_value
memory > xtransforms
memory > xreffed_expression
memory > xord
memory > xname
memory > xzip
memory > xcontains_louter
memory > xJoin
memory > xidx
memory > xexc
memory > xORDER_DIR
memory > xcondition
memory > xnext
memory > xMultiColSource
memory > xEmpty
memory > xrefs_expression
memory > xlookup_parts
memory > xn
memory > xfiltered_relation_path
memory > xoptions
memory > xkwargs
memory > xor_null_condition
memory > xvotes
memory > xAggregateQuery
memory > xfield_name
memory > xfunctools
memory > xlen
memory > xdict
memory > xExtraWhere
memory > xclause
memory > xj
memory > xisinstance
memory > xnew_only
memory > xnew_existing
memory > xTypeError
memory > xkey
memory > xa
[] > query
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xset_annotation_mask
        memory > xcompiler
        memory > xget_children_from_q
        memory > xsplit_exclude
        memory > xjoin_class
        memory > xget_aggregation
        memory > xadd_extra
        memory > xclear_where
        memory > xorder_by
        memory > x__str__
        memory > xcheck_query_object_type
        memory > xget_order_dir
        memory > xdefault_cols
        memory > xparams_type
        memory > x__deepcopy__
        memory > xExplainInfo
        memory > xselect_for_update_skip_locked
        memory > xrelabeled_clone
        memory > xhas_results
        memory > xjoin
        memory > xget_meta
        memory > x__repr__
        memory > xmax_depth
        memory > xempty_result_set_value
        memory > xadd_ordering
        memory > xhas_select_fields
        memory > xset_select
        memory > xbase_table
        memory > xsubquery
        memory > xget_initial_alias
        memory > xadd_fields
        memory > xalias_prefix
        memory > x_get_col
        memory > xget_count
        memory > xclear_deferred_loading
        memory > xresolve_ref
        memory > xtrim_start
        memory > xadd_deferred_loading
        memory > xadd_q
        memory > xadd_filter
        memory > xget_columns
        memory > xexplain
        memory > xgroup_by
        memory > xis_empty
        memory > xclone
        memory > xnames_to_path
        memory > x__iter__
        memory > xhigh_mark
        memory > xis_sliced
        memory > xtry_transform
        memory > xsetup_joins
        memory > xcount_active_tables
        memory > xannotation_select_mask
        memory > xselect_for_update
        memory > xsql_with_params
        memory > xfilter_is_sticky
        memory > xset_group_by
        memory > xbase_table_class
        memory > xbuild_lookup
        memory > xclear_select_clause
        memory > xcombinator
        memory > xlow_mark
        memory > xJoinInfo
        memory > xjoin_parent_model
        memory > xselect
        memory > xresolve_lookup_value
        memory > xset_empty
        memory > xextra_select
        memory > xvalues_select
        memory > xannotation_select
        memory > xget_field_names_from_opts
        memory > xdeferred_to_data
        memory > xhas_limit_one
        memory > xsubq_aliases
        memory > xsolve_lookup_type
        memory > xadd_immediate_loading
        memory > xas_sql
        memory > xbuild_where
        memory > x_gen_col_aliases
        memory > xselect_for_no_key_update
        memory > x_extra_select_cache
        memory > xdistinct
        memory > xextra_select_mask
        memory > xadd_distinct_fields
        memory > xget_compiler
        memory > xappend_annotation_mask
        memory > xbuild_filtered_relation_q
        memory > x_annotation_select_cache
        memory > xselect_for_update_of
        memory > xpromote_joins
        memory > xchain
        memory > xstandard_ordering
        memory > xdeferred_loading
        memory > xselect_for_update_nowait
        memory > xclear_limits
        memory > xadd_to_dict
        memory > xreset_refcounts
        memory > xhas_filters
        memory > xchange_aliases
        memory > xdefault_ordering
        memory > xis_reverse_o2o
        memory > xbuild_filter
        memory > xtable_alias
        memory > x__all__
        memory > xextra_tables
        memory > xget_group_by_cols
        memory > xadd_select_related
        memory > xrewrite_cols
        memory > x_gen_cols
        memory > xupdate_join_types
        memory > xexists
        memory > xcombined_queries
        memory > xclear_select_fields
        memory > x__init__
        memory > xoutput_field
        memory > xtrim_joins
        memory > xcheck_related_objects
        memory > xset_values
        memory > xis_nullable
        memory > xcheck_filterable
        memory > xadd_filtered_relation
        memory > xunref_alias
        memory > xget_external_cols
        memory > x_execute_query
        memory > xresolve_expression
        memory > xset_limits
        memory > xdemote_joins
        memory > xadd_select_col
        memory > xdistinct_fields
        memory > xclear_ordering
        memory > xcan_filter
        memory > xset_extra_mask
        memory > xadd_annotation
        memory > xcombine
        memory > xref_alias
        memory > xadd_votes
        memory > xbump_prefix
        memory > xcombinator_all
        memory > xselect_related
        memory > x_add_q
        memory > xextra_order_by
        memory > xexplain_info
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x__all__.write (((unsupported)).apply ("Query") ("RawQuery"))
            xget_field_names_from_opts.write
              [xopts]
                seq > @
                  seq
                    (((unsupported)).apply ((xopts)) ("None: is there a None literal in the EO language?")).if
                      (((unsupported)).apply ((((xset)).apply)))
                    (((unsupported)).apply ((((xset)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply ((((xf).xconcrete).if (((unsupported)).apply (((xf).xname)) (((xf).xattname))) (((unsupported)).apply (((xf).xname))))) ((xf)) (((((xopts).xget_fields)).apply)))))))))
            xget_children_from_q.write
              [xq]
                seq > @
                  (((unsupported)).apply ((xchild)) (((xq).xchildren)))
                    (((xisinstance)).apply ((xchild)) ((xNode))).if
                      (((unsupported)).apply ((((xget_children_from_q)).apply ((xchild)))))
                      (((unsupported)).apply ((xchild)))
            xJoinInfo.write (((xnamedtuple)).apply ("JoinInfo") ((((unsupported)).apply ("final_field") ("targets") ("opts") ("joins") ("path") ("transform_function"))))
            (((unsupported)).apply)
              seq
                unsupported
                x__init__.write
                  [xself xsql xusing xparams]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xparams)) ((xparams)))
                        (((unsupported)).apply (((xself).xsql)) ((xsql)))
                        (((unsupported)).apply (((xself).xusing)) ((xusing)))
                        (((unsupported)).apply (((xself).xcursor)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xlow_mark)) (((xself).xhigh_mark)))) ((((unsupported)).apply (0) ("None: is there a None literal in the EO language?"))))
                        (((unsupported)).apply (((xself).xextra_select)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xannotation_select)) ((((unsupported)).apply)))
                xchain.write
                  [xself xusing]
                    seq > @
                      (((unsupported)).apply (((((xself).xclone)).apply ((xusing)))))
                xclone.write
                  [xself xusing]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ((xRawQuery)) (((xself).xsql)) ((xusing)) (((xself).xparams)))))
                xget_columns.write
                  [xself]
                    memory > xconverter
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xcursor)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xself).x_execute_query)).apply)
                        xconverter.write (((((unsupported)).apply ((xconnections)) (((xself).xusing))).xintrospection).xidentifier_converter)
                        (((unsupported)).apply ((((unsupported)).apply ((((xconverter)).apply ((((unsupported)).apply ((xcolumn_meta)) (0))))) ((xcolumn_meta)) ((((xself).xcursor).xdescription)))))
                x__iter__.write
                  [xself]
                    memory > xresult
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).x_execute_query)).apply)
                        ((((((unsupported)).apply ((xconnections)) (((xself).xusing))).xfeatures).xcan_use_chunked_reads).not).if
                          xresult.write (((xlist)).apply (((xself).xcursor)))
                          xresult.write ((xself).xcursor)
                        (((unsupported)).apply ((((xiter)).apply ((xresult)))))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<%s: %s>".mod (((unsupported)).apply ((((xself).x__class__).x__name__)) ((xself))))))
                xparams_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xparams)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((((xisinstance)).apply (((xself).xparams)) ((xMapping))).if (xdict) (xtuple))))
                x__str__.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xparams_type)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xsql)))
                        (((unsupported)).apply ((((xself).xsql).mod ((((xself).xparams_type)).apply (((xself).xparams))))))
                x_execute_query.write
                  [xself]
                    memory > xconnection
                    memory > xparams_type
                    memory > xparams
                    memory > xadapter
                    seq > @
                      seq
                        xconnection.write (((unsupported)).apply ((xconnections)) (((xself).xusing)))
                        xparams_type.write ((xself).xparams_type)
                        xadapter.write (((xconnection).xops).xadapt_unknown_value)
                        (((unsupported)).apply ((xparams_type)) ((xtuple))).if
                          xparams.write (((xtuple)).apply ((((unsupported)).apply ((((xadapter)).apply ((xval)))) ((xval)) (((xself).xparams)))))
                          (((unsupported)).apply ((xparams_type)) ((xdict))).if
                            xparams.write (((unsupported)).apply ((xkey)) ((((xadapter)).apply ((xval)))) ((((unsupported)).apply ((xkey)) ((xval)))) ((((((xself).xparams).xitems)).apply)))
                            (((unsupported)).apply ((xparams_type)) ("None: is there a None literal in the EO language?")).if
                              xparams.write "None: is there a None literal in the EO language?"
                              (((unsupported)).apply ((((xRuntimeError)).apply (("Unexpected params type: %s".mod (xparams_type))))))
                        (((unsupported)).apply (((xself).xcursor)) (((((xconnection).xcursor)).apply)))
                        bogusForceDataize.write (((((xself).xcursor).xexecute)).apply (((xself).xsql)) ((xparams)))
            xExplainInfo.write (((xnamedtuple)).apply ("ExplainInfo") ((((unsupported)).apply ("format") ("options"))))
            (((unsupported)).apply ((xBaseExpression)))
              seq
                unsupported
                xalias_prefix.write "T"
                xempty_result_set_value.write "None: is there a None literal in the EO language?"
                xsubq_aliases.write (((xfrozenset)).apply ((((unsupported)).apply ((xalias_prefix)))))
                xcompiler.write "SQLCompiler"
                xbase_table_class.write (xBaseTable)
                xjoin_class.write (xJoin)
                xdefault_cols.write TRUE
                xdefault_ordering.write TRUE
                xstandard_ordering.write TRUE
                xfilter_is_sticky.write FALSE
                xsubquery.write FALSE
                xselect.write (((unsupported)).apply)
                xgroup_by.write "None: is there a None literal in the EO language?"
                xorder_by.write (((unsupported)).apply)
                xlow_mark.write 0
                xhigh_mark.write "None: is there a None literal in the EO language?"
                xdistinct.write FALSE
                xdistinct_fields.write (((unsupported)).apply)
                xselect_for_update.write FALSE
                xselect_for_update_nowait.write FALSE
                xselect_for_update_skip_locked.write FALSE
                xselect_for_update_of.write (((unsupported)).apply)
                xselect_for_no_key_update.write FALSE
                xselect_related.write FALSE
                xmax_depth.write 5
                xvalues_select.write (((unsupported)).apply)
                xannotation_select_mask.write "None: is there a None literal in the EO language?"
                x_annotation_select_cache.write "None: is there a None literal in the EO language?"
                xcombinator.write "None: is there a None literal in the EO language?"
                xcombinator_all.write FALSE
                xcombined_queries.write (((unsupported)).apply)
                xextra_select_mask.write "None: is there a None literal in the EO language?"
                x_extra_select_cache.write "None: is there a None literal in the EO language?"
                xextra_tables.write (((unsupported)).apply)
                xextra_order_by.write (((unsupported)).apply)
                xdeferred_loading.write (((unsupported)).apply ((((xfrozenset)).apply)) (TRUE))
                xexplain_info.write "None: is there a None literal in the EO language?"
                x__init__.write
                  [xself xmodel xalias_cols]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xmodel)) ((xmodel)))
                        (((unsupported)).apply (((xself).xalias_refcount)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xalias_map)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xalias_cols)) ((xalias_cols)))
                        (((unsupported)).apply (((xself).xexternal_aliases)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xtable_map)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xused_aliases)) ((((xset)).apply)))
                        (((unsupported)).apply (((xself).xwhere)) ((((xWhereNode)).apply)))
                        (((unsupported)).apply (((xself).xannotations)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xextra)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).x_filtered_relations)) ((((unsupported)).apply)))
                xoutput_field.write
                  [xself]
                    memory > xselect
                    seq > @
                      (((unsupported)).apply)
                        ((((xlen)).apply (((xself).xselect))).eq 1).if
                          seq
                            xselect.write (((unsupported)).apply (((xself).xselect)) (0))
                            (((unsupported)).apply (((((xgetattr)).apply ((xselect)) ("target") ("None: is there a None literal in the EO language?")).or ((xselect).xfield))))
                          ((((xlen)).apply (((xself).xannotation_select))).eq 1).if
                            (((unsupported)).apply (((((xnext)).apply ((((xiter)).apply ((((((xself).xannotation_select).xvalues)).apply))))).xoutput_field)))
                xhas_select_fields.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xbool)).apply (((((xself).xselect).or ((xself).xannotation_select_mask)).or ((xself).xextra_select_mask))))))
                xbase_table.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xalias)) (((xself).xalias_map)))
                          (((unsupported)).apply ((xalias)))
                x__str__.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xsql_with_params)).apply)))
                        (((unsupported)).apply (((xsql).mod (xparams))))
                xsql_with_params.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((((((xself).xget_compiler)).apply ((xDEFAULT_DB_ALIAS))).xas_sql)).apply)))
                x__deepcopy__.write
                  [xself xmemo]
                    memory > xresult
                    seq > @
                      seq
                        unsupported
                        xresult.write ((((xself).xclone)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xmemo)) ((((xid)).apply ((xself)))))) ((xresult)))
                        (((unsupported)).apply ((xresult)))
                xget_compiler.write
                  [xself xusing xconnection xelide_empty]
                    seq > @
                      (((unsupported)).apply)
                        ((((unsupported)).apply ((xusing)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xconnection)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Need either using or connection"))))
                        (xusing).if
                          xconnection.write (((unsupported)).apply ((xconnections)) ((xusing)))
                        (((unsupported)).apply ((((((((xconnection).xops).xcompiler)).apply (((xself).xcompiler)))).apply ((xself)) ((xconnection)) ((xusing)) ((xelide_empty)))))
                xget_meta.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((xself).xmodel).if
                          (((unsupported)).apply ((((xself).xmodel).x_meta)))
                xclone.write
                  [xself]
                    memory > xobj
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xobj.write (((xEmpty)).apply)
                        (((unsupported)).apply (((xobj).x__class__)) (((xself).x__class__)))
                        (((unsupported)).apply (((xobj).x__dict__)) ((((((xself).x__dict__).xcopy)).apply)))
                        (((unsupported)).apply (((xobj).xalias_refcount)) ((((((xself).xalias_refcount).xcopy)).apply)))
                        (((unsupported)).apply (((xobj).xalias_map)) ((((((xself).xalias_map).xcopy)).apply)))
                        (((unsupported)).apply (((xobj).xexternal_aliases)) ((((((xself).xexternal_aliases).xcopy)).apply)))
                        (((unsupported)).apply (((xobj).xtable_map)) ((((((xself).xtable_map).xcopy)).apply)))
                        (((unsupported)).apply (((xobj).xwhere)) ((((((xself).xwhere).xclone)).apply)))
                        (((unsupported)).apply (((xobj).xannotations)) ((((((xself).xannotations).xcopy)).apply)))
                        (((unsupported)).apply (((xself).xannotation_select_mask)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xobj).xannotation_select_mask)) ((((((xself).xannotation_select_mask).xcopy)).apply)))
                        ((xself).xcombined_queries).if
                          (((unsupported)).apply (((xobj).xcombined_queries)) ((((xtuple)).apply ((((unsupported)).apply (((((xquery).xclone)).apply)) ((xquery)) (((xself).xcombined_queries)))))))
                        (((unsupported)).apply (((xobj).x_annotation_select_cache)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xobj).xextra)) ((((((xself).xextra).xcopy)).apply)))
                        (((unsupported)).apply (((xself).xextra_select_mask)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xobj).xextra_select_mask)) ((((((xself).xextra_select_mask).xcopy)).apply)))
                        (((unsupported)).apply (((xself).x_extra_select_cache)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xobj).x_extra_select_cache)) ((((((xself).x_extra_select_cache).xcopy)).apply)))
                        (((unsupported)).apply (((xself).xselect_related)) (FALSE)).if
                          (((unsupported)).apply (((xobj).xselect_related)) (((((xcopy).xdeepcopy)).apply (((xobj).xselect_related)))))
                        (((unsupported)).apply ("subq_aliases") (((xself).x__dict__))).if
                          (((unsupported)).apply (((xobj).xsubq_aliases)) ((((((xself).xsubq_aliases).xcopy)).apply)))
                        (((unsupported)).apply (((xobj).xused_aliases)) ((((((xself).xused_aliases).xcopy)).apply)))
                        (((unsupported)).apply (((xobj).x_filtered_relations)) ((((((xself).x_filtered_relations).xcopy)).apply)))
                        bogusForceDataize.write (((((xobj).x__dict__).xpop)).apply ("base_table") ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xobj)))
                xchain.write
                  [xself xklass]
                    memory > xobj
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xobj.write ((((xself).xclone)).apply)
                        ((xklass).and (((xobj).x__class__).neq (xklass))).if
                          (((unsupported)).apply (((xobj).x__class__)) ((xklass)))
                        (((xobj).xfilter_is_sticky).not).if
                          (((unsupported)).apply (((xobj).xused_aliases)) ((((xset)).apply)))
                        (((unsupported)).apply (((xobj).xfilter_is_sticky)) (FALSE))
                        (((xhasattr)).apply ((xobj)) ("_setup_query")).if
                          bogusForceDataize.write ((((xobj).x_setup_query)).apply)
                        (((unsupported)).apply ((xobj)))
                xrelabeled_clone.write
                  [xself xchange_map]
                    memory > xclone
                    seq > @
                      seq
                        xclone.write ((((xself).xclone)).apply)
                        bogusForceDataize.write ((((xclone).xchange_aliases)).apply ((xchange_map)))
                        (((unsupported)).apply ((xclone)))
                x_get_col.write
                  [xself xtarget xfield xalias]
                    seq > @
                      seq
                        (((xself).xalias_cols).not).if
                          xalias.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply (((((xtarget).xget_col)).apply ((xalias)) ((xfield)))))
                xrewrite_cols.write
                  [xself xannotation xcol_cnt]
                    memory > xcol_alias
                    memory > xnew_exprs
                    memory > xnew_expr
                    memory > xorig_exprs
                    seq > @
                      seq
                        xorig_exprs.write ((((xannotation).xget_source_expressions)).apply)
                        xnew_exprs.write (((unsupported)).apply)
                        (((unsupported)).apply ((xexpr)) ((xorig_exprs)))
                          (((xisinstance)).apply ((xexpr)) ((xRef))).if
                            bogusForceDataize.write ((((xnew_exprs).xappend)).apply ((xexpr)))
                            (((xisinstance)).apply ((xexpr)) ((((unsupported)).apply ((xWhereNode)) ((xLookup))))).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xnew_expr)) ((xcol_cnt)))) (((((xself).xrewrite_cols)).apply ((xexpr)) ((xcol_cnt)))))
                                bogusForceDataize.write ((((xnew_exprs).xappend)).apply ((xnew_expr)))
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xcol_alias)) ((xselected_annotation)))) ((((((xself).xannotation_select).xitems)).apply)))
                                  (((unsupported)).apply ((xselected_annotation)) ((xexpr))).if
                                    seq
                                      xnew_expr.write (((xRef)).apply ((xcol_alias)) ((xexpr)))
                                      (((unsupported)).apply)
                                  ((((xisinstance)).apply ((xexpr)) ((xCol))).or (((xexpr).xcontains_aggregate).and (((xexpr).xis_summary).not))).if
                                    seq
                                      (((unsupported)).apply ((xcol_cnt)) (1))
                                      xcol_alias.write ("__col%d".mod (xcol_cnt))
                                      (((unsupported)).apply ((((unsupported)).apply (((xself).xannotations)) ((xcol_alias)))) ((xexpr)))
                                      bogusForceDataize.write ((((xself).xappend_annotation_mask)).apply ((((unsupported)).apply ((xcol_alias)))))
                                      xnew_expr.write (((xRef)).apply ((xcol_alias)) ((xexpr)))
                                    (((unsupported)).apply ((((unsupported)).apply ((xnew_expr)) ((xcol_cnt)))) (((((xself).xrewrite_cols)).apply ((xexpr)) ((xcol_cnt)))))
                                bogusForceDataize.write ((((xnew_exprs).xappend)).apply ((xnew_expr)))
                        bogusForceDataize.write ((((xannotation).xset_source_expressions)).apply ((xnew_exprs)))
                        (((unsupported)).apply ((((unsupported)).apply ((xannotation)) ((xcol_cnt)))))
                xget_aggregation.write
                  [xself xusing xadded_aggregate_names]
                    memory > xcompiler
                    memory > xempty_set_result
                    memory > xannotation_select_mask
                    memory > xelide_empty
                    memory > xrelabels
                    memory > xhas_existing_aggregate_annotations
                    memory > xinner_query
                    memory > xcol_cnt
                    memory > xresult
                    memory > xconverters
                    memory > xouter_query
                    memory > xexisting_annotations
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xself).xannotation_select).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xexisting_annotations.write (((unsupported)).apply ((xannotation)) ((((unsupported)).apply ((xalias)) ((xannotation)))) ((((((xself).xannotations).xitems)).apply)) ((((unsupported)).apply ((xalias)) ((xadded_aggregate_names)))))
                        (((((((xisinstance)).apply (((xself).xgroup_by)) ((xtuple))).or ((xself).xis_sliced)).or (xexisting_annotations)).or ((xself).xdistinct)).or ((xself).xcombinator)).if
                          seq
                            (((unsupported)).apply)
                            xinner_query.write ((((xself).xclone)).apply)
                            (((unsupported)).apply (((xinner_query).xsubquery)) (TRUE))
                            xouter_query.write (((xAggregateQuery)).apply (((xself).xmodel)) ((xinner_query)))
                            (((unsupported)).apply (((xinner_query).xselect_for_update)) (FALSE))
                            (((unsupported)).apply (((xinner_query).xselect_related)) (FALSE))
                            bogusForceDataize.write ((((xinner_query).xset_annotation_mask)).apply (((xself).xannotation_select)))
                            (((unsupported)).apply (((xinner_query).xclear_ordering)) (FALSE))
                            (((xinner_query).xdistinct).not).if
                              seq
                                xhas_existing_aggregate_annotations.write (((xany)).apply ((((unsupported)).apply ((xannotation)) ((xannotation)) ((xexisting_annotations)) ((((xgetattr)).apply ((xannotation)) ("contains_aggregate") (TRUE))))))
                                (((xinner_query).xdefault_cols).and (xhas_existing_aggregate_annotations)).if
                                  (((unsupported)).apply (((xinner_query).xgroup_by)) ((((unsupported)).apply ((((((((xself).xmodel).x_meta).xpk).xget_col)).apply (((((xinner_query).xget_initial_alias)).apply)))))))
                                (((unsupported)).apply (((xinner_query).xdefault_cols)) (FALSE))
                            xrelabels.write (((unsupported)).apply ((xt)) ("subquery") ((xt)) (((xinner_query).xalias_map)))
                            (((unsupported)).apply ((((unsupported)).apply ((xrelabels)) ("None: is there a None literal in the EO language?"))) ("subquery"))
                            xcol_cnt.write 0
                            (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((xexpression)))) ((((xlist)).apply ((((((xinner_query).xannotation_select).xitems)).apply)))))
                              seq
                                xannotation_select_mask.write ((xinner_query).xannotation_select_mask)
                                ((xexpression).xis_summary).if
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply ((xexpression)) ((xcol_cnt)))) (((((xinner_query).xrewrite_cols)).apply ((xexpression)) ((xcol_cnt)))))
                                    (((unsupported)).apply ((((unsupported)).apply (((xouter_query).xannotations)) ((xalias)))) (((((xexpression).xrelabeled_clone)).apply ((xrelabels)))))
                                    (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xinner_query).xannotations)) ((xalias)))))))))
                                    bogusForceDataize.write ((((xannotation_select_mask).xremove)).apply ((xalias)))
                                bogusForceDataize.write ((((xinner_query).xset_annotation_mask)).apply (((xinner_query).xannotation_select_mask)))
                            (((((xinner_query).xselect).eq (((unsupported)).apply)).and (((xinner_query).xdefault_cols).not)).and (((xinner_query).xannotation_select_mask).not)).if
                              (((unsupported)).apply (((xinner_query).xselect)) ((((unsupported)).apply ((((((((xself).xmodel).x_meta).xpk).xget_col)).apply (((((xinner_query).xget_initial_alias)).apply)))))))
                          seq
                            xouter_query.write (xself)
                            (((unsupported)).apply (((xself).xselect)) ((((unsupported)).apply)))
                            (((unsupported)).apply (((xself).xdefault_cols)) (FALSE))
                            (((unsupported)).apply (((xself).xextra)) ((((unsupported)).apply)))
                        xempty_set_result.write (((unsupported)).apply (((xexpression).xempty_result_set_value)) ((xexpression)) ((((((xouter_query).xannotation_select).xvalues)).apply)))
                        xelide_empty.write ((((xany)).apply ((((unsupported)).apply ((((unsupported)).apply ((xresult)) ((xNotImplemented)))) ((xresult)) ((xempty_set_result))))).not)
                        (((unsupported)).apply (((xouter_query).xclear_ordering)) (TRUE))
                        bogusForceDataize.write ((((xouter_query).xclear_limits)).apply)
                        (((unsupported)).apply (((xouter_query).xselect_for_update)) (FALSE))
                        (((unsupported)).apply (((xouter_query).xselect_related)) (FALSE))
                        xcompiler.write (((unsupported)).apply (((xouter_query).xget_compiler)) ((xusing)) ((xelide_empty)))
                        xresult.write ((((xcompiler).xexecute_sql)).apply ((xSINGLE)))
                        (((unsupported)).apply ((xresult)) ("None: is there a None literal in the EO language?")).if
                          xresult.write (xempty_set_result)
                        xconverters.write ((((xcompiler).xget_converters)).apply ((((((xouter_query).xannotation_select).xvalues)).apply)))
                        xresult.write (((xnext)).apply (((((xcompiler).xapply_converters)).apply ((((unsupported)).apply ((xresult)))) ((xconverters)))))
                        (((unsupported)).apply ((((xdict)).apply ((((xzip)).apply (((xouter_query).xannotation_select)) ((xresult)))))))
                xget_count.write
                  [xself xusing]
                    memory > xobj
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xobj.write ((((xself).xclone)).apply)
                        (((unsupported)).apply (((xobj).xadd_annotation)) ((((xCount)).apply ("*"))) ("__count") (TRUE))
                        (((unsupported)).apply ((((unsupported)).apply (((((xobj).xget_aggregation)).apply ((xusing)) ((((unsupported)).apply ("__count"))))) ("__count"))))
                xhas_filters.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xself).xwhere)))
                xexists.write
                  [xself xusing xlimit]
                    memory > xlimit_combined
                    memory > xq
                    seq > @
                      (((unsupported)).apply)
                        xq.write ((((xself).xclone)).apply)
                        (((xq).xdistinct).not).if
                          seq
                            (((unsupported)).apply (((xq).xgroup_by)) (TRUE)).if
                              seq
                                bogusForceDataize.write ((((xq).xadd_fields)).apply ((((unsupported)).apply (((xf).xattname)) ((xf)) (((((xself).xmodel).x_meta).xconcrete_fields)))) (FALSE))
                                (((unsupported)).apply (((xq).xset_group_by)) (FALSE))
                            bogusForceDataize.write ((((xq).xclear_select_clause)).apply)
                        (((xq).xcombined_queries).and (((xq).xcombinator).eq "union")).if
                          seq
                            xlimit_combined.write (((((unsupported)).apply ((xconnections)) ((xusing))).xfeatures).xsupports_slicing_ordering_in_compound)
                            (((unsupported)).apply (((xq).xcombined_queries)) ((((xtuple)).apply ((((unsupported)).apply ((((unsupported)).apply (((xcombined_query).xexists)) ((xusing)) ((xlimit_combined)))) ((xcombined_query)) (((xq).xcombined_queries)))))))
                        (((unsupported)).apply (((xq).xclear_ordering)) (TRUE))
                        (xlimit).if
                          (((unsupported)).apply (((xq).xset_limits)) (1))
                        bogusForceDataize.write ((((xq).xadd_extra)).apply ((((unsupported)).apply ("a") (1))) ("None: is there a None literal in the EO language?") ("None: is there a None literal in the EO language?") ("None: is there a None literal in the EO language?") ("None: is there a None literal in the EO language?") ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xq).xset_extra_mask)).apply ((((unsupported)).apply ("a"))))
                        (((unsupported)).apply ((xq)))
                xhas_results.write
                  [xself xusing]
                    memory > xcompiler
                    memory > xq
                    seq > @
                      seq
                        xq.write ((((xself).xexists)).apply ((xusing)))
                        xcompiler.write (((unsupported)).apply (((xq).xget_compiler)) ((xusing)))
                        (((unsupported)).apply (((((xcompiler).xhas_results)).apply)))
                xexplain.write
                  [xself xusing xformat]
                    memory > xcompiler
                    memory > xq
                    seq > @
                      (((unsupported)).apply)
                        xq.write ((((xself).xclone)).apply)
                        (((unsupported)).apply (((xq).xexplain_info)) ((((xExplainInfo)).apply ((xformat)) ((xoptions)))))
                        xcompiler.write (((unsupported)).apply (((xq).xget_compiler)) ((xusing)))
                        (((unsupported)).apply (((("n".xjoin)).apply (((((xcompiler).xexplain_query)).apply)))))
                xcombine.write
                  [xself xrhs xconnector]
                    memory > xjoin
                    memory > xconjunction
                    memory > xnew_alias
                    memory > xw
                    memory > xrhs_votes
                    memory > xchange_map
                    memory > xrhs_tables
                    memory > xjoinpromoter
                    memory > xinitial_alias
                    memory > xreuse
                    memory > xextra_select_mask
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xself).xmodel).neq ((xrhs).xmodel)).if
                          (((unsupported)).apply ((((xTypeError)).apply ("Cannot combine queries on two different base models."))))
                        ((xself).xis_sliced).if
                          (((unsupported)).apply ((((xTypeError)).apply ("Cannot combine queries once a slice has been taken."))))
                        (((xself).xdistinct).neq ((xrhs).xdistinct)).if
                          (((unsupported)).apply ((((xTypeError)).apply ("Cannot combine a unique query with a non-unique query."))))
                        (((xself).xdistinct_fields).neq ((xrhs).xdistinct_fields)).if
                          (((unsupported)).apply ((((xTypeError)).apply ("Cannot combine queries with different distinct fields."))))
                        xinitial_alias.write ((((xself).xget_initial_alias)).apply)
                        (((unsupported)).apply (((xrhs).xbump_prefix)) ((xself)) ((((unsupported)).apply ((xinitial_alias)))))
                        xchange_map.write (((unsupported)).apply)
                        xconjunction.write ((xconnector).eq (xAND))
                        xreuse.write ((xconjunction).if (((xset)).apply) (((xset)).apply (((xself).xalias_map))))
                        xjoinpromoter.write (((xJoinPromoter)).apply ((xconnector)) (2) (FALSE))
                        bogusForceDataize.write ((((xjoinpromoter).xadd_votes)).apply ((((unsupported)).apply ((xj)) ((xj)) (((xself).xalias_map)) ((((((unsupported)).apply (((xself).xalias_map)) ((xj))).xjoin_type).eq (xINNER))))))
                        xrhs_votes.write (((xset)).apply)
                        xrhs_tables.write (((unsupported)).apply ((((xlist)).apply (((xrhs).xalias_map)))) ((((unsupported)).apply (1))))
                        (((unsupported)).apply ((xalias)) ((xrhs_tables)))
                          seq
                            xjoin.write (((unsupported)).apply (((xrhs).xalias_map)) ((xalias)))
                            xjoin.write ((((xjoin).xrelabeled_clone)).apply ((xchange_map)))
                            xnew_alias.write (((unsupported)).apply (((xself).xjoin)) ((xjoin)) ((xreuse)))
                            (((xjoin).xjoin_type).eq (xINNER)).if
                              bogusForceDataize.write ((((xrhs_votes).xadd)).apply ((xnew_alias)))
                            bogusForceDataize.write ((((xreuse).xdiscard)).apply ((xnew_alias)))
                            ((xalias).neq (xnew_alias)).if
                              (((unsupported)).apply ((((unsupported)).apply ((xchange_map)) ((xalias)))) ((xnew_alias)))
                            ((((unsupported)).apply (((xrhs).xalias_refcount)) ((xalias))).not).if
                              bogusForceDataize.write ((((xself).xunref_alias)).apply ((xnew_alias)))
                        bogusForceDataize.write ((((xjoinpromoter).xadd_votes)).apply ((xrhs_votes)))
                        bogusForceDataize.write ((((xjoinpromoter).xupdate_join_types)).apply ((xself)))
                        (((unsupported)).apply (((xself).xsubq_aliases)) (((xrhs).xsubq_aliases)))
                        xw.write (((((xrhs).xwhere).xclone)).apply)
                        bogusForceDataize.write ((((xw).xrelabel_aliases)).apply ((xchange_map)))
                        bogusForceDataize.write (((((xself).xwhere).xadd)).apply ((xw)) ((xconnector)))
                        ((xrhs).xselect).if
                          bogusForceDataize.write ((((xself).xset_select)).apply ((((unsupported)).apply (((((xcol).xrelabeled_clone)).apply ((xchange_map)))) ((xcol)) (((xrhs).xselect)))))
                          (((unsupported)).apply (((xself).xselect)) ((((unsupported)).apply)))
                        ((xconnector).eq (xOR)).if
                          (((xself).xextra).and ((xrhs).xextra)).if
                            (((unsupported)).apply ((((xValueError)).apply ("When merging querysets using 'or', you cannot have extra(select=...) on both sides."))))
                        bogusForceDataize.write (((((xself).xextra).xupdate)).apply (((xrhs).xextra)))
                        xextra_select_mask.write (((xset)).apply)
                        (((unsupported)).apply (((xself).xextra_select_mask)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xextra_select_mask).xupdate)).apply (((xself).xextra_select_mask)))
                        (((unsupported)).apply (((xrhs).xextra_select_mask)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xextra_select_mask).xupdate)).apply (((xrhs).xextra_select_mask)))
                        (xextra_select_mask).if
                          bogusForceDataize.write ((((xself).xset_extra_mask)).apply ((xextra_select_mask)))
                        (((unsupported)).apply (((xself).xextra_tables)) (((xrhs).xextra_tables)))
                        (((unsupported)).apply (((xself).xorder_by)) ((((xrhs).xorder_by).or ((xself).xorder_by))))
                        (((unsupported)).apply (((xself).xextra_order_by)) ((((xrhs).xextra_order_by).or ((xself).xextra_order_by))))
                xdeferred_to_data.write
                  [xself xtarget]
                    memory > xfield
                    memory > xworkset
                    memory > xparts
                    memory > xopts
                    memory > xmust_include
                    memory > xcur_model
                    memory > xm
                    memory > xseen
                    memory > xold_model
                    memory > xmodel
                    memory > xorig_opts
                    memory > xis_reverse_object
                    memory > xname
                    memory > xsource
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xfield_names)) ((xdefer)))) (((xself).xdeferred_loading)))
                        ((xfield_names).not).if
                          (((unsupported)).apply)
                        xorig_opts.write ((((xself).xget_meta)).apply)
                        xseen.write (((unsupported)).apply)
                        xmust_include.write (((unsupported)).apply (((xorig_opts).xconcrete_model)) ((((unsupported)).apply (((xorig_opts).xpk)))))
                        (((unsupported)).apply ((xfield_name)) ((xfield_names)))
                          seq
                            xparts.write ((((xfield_name).xsplit)).apply ((xLOOKUP_SEP)))
                            xcur_model.write ((((xself).xmodel).x_meta).xconcrete_model)
                            xopts.write (xorig_opts)
                            (((unsupported)).apply ((xname)) ((((unsupported)).apply ((xparts)) ((((unsupported)).apply ((1.neg)))))))
                              seq
                                xold_model.write (xcur_model)
                                (((unsupported)).apply ((xname)) (((xself).x_filtered_relations))).if
                                  xname.write ((((unsupported)).apply (((xself).x_filtered_relations)) ((xname))).xrelation_name)
                                xsource.write ((((xopts).xget_field)).apply ((xname)))
                                (((xis_reverse_o2o)).apply ((xsource))).if
                                  xcur_model.write ((xsource).xrelated_model)
                                  xcur_model.write (((xsource).xremote_field).xmodel)
                                xopts.write ((xcur_model).x_meta)
                                ((((xis_reverse_o2o)).apply ((xsource))).not).if
                                  bogusForceDataize.write ((((((unsupported)).apply ((xmust_include)) ((xold_model))).xadd)).apply ((xsource)))
                                bogusForceDataize.write (((xadd_to_dict)).apply ((xmust_include)) ((xcur_model)) (((xopts).xpk)))
                            xfield.write ((((xopts).xget_field)).apply ((((unsupported)).apply ((xparts)) ((1.neg)))))
                            xis_reverse_object.write (((xfield).xauto_created).and (((xfield).xconcrete).not))
                            xmodel.write ((xis_reverse_object).if ((xfield).xrelated_model) ((xfield).xmodel))
                            xmodel.write (((xmodel).x_meta).xconcrete_model)
                            ((xmodel).eq ((xopts).xmodel)).if
                              xmodel.write (xcur_model)
                            ((((xis_reverse_o2o)).apply ((xfield))).not).if
                              bogusForceDataize.write (((xadd_to_dict)).apply ((xseen)) ((xmodel)) ((xfield)))
                        (xdefer).if
                          seq
                            xworkset.write (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xmodel)) ((xvalues)))) (((((xseen).xitems)).apply)))
                              (((unsupported)).apply ((xfield)) ((((xmodel).x_meta).xlocal_fields)))
                                (((unsupported)).apply ((xfield)) ((xvalues))).if
                                  seq
                                    xm.write ((((xfield).xmodel).x_meta).xconcrete_model)
                                    bogusForceDataize.write (((xadd_to_dict)).apply ((xworkset)) ((xm)) ((xfield)))
                            (((unsupported)).apply ((((unsupported)).apply ((xmodel)) ((xvalues)))) (((((xmust_include).xitems)).apply)))
                              (((unsupported)).apply ((xmodel)) ((xworkset))).if
                                bogusForceDataize.write ((((((unsupported)).apply ((xworkset)) ((xmodel))).xupdate)).apply ((xvalues)))
                            (((unsupported)).apply ((((unsupported)).apply ((xmodel)) ((xfields)))) (((((xworkset).xitems)).apply)))
                              (((unsupported)).apply ((((unsupported)).apply ((xtarget)) ((xmodel)))) ((((unsupported)).apply (((xf).xattname)) ((xf)) ((xfields)))))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xmodel)) ((xvalues)))) (((((xmust_include).xitems)).apply)))
                              (((unsupported)).apply ((xmodel)) ((xseen))).if
                                bogusForceDataize.write ((((((unsupported)).apply ((xseen)) ((xmodel))).xupdate)).apply ((xvalues)))
                                (((unsupported)).apply ((((unsupported)).apply ((xseen)) ((xmodel)))) ((xvalues)))
                            (((unsupported)).apply ((xmodel)) (((((xorig_opts).xget_parent_list)).apply)))
                              bogusForceDataize.write ((((xseen).xsetdefault)).apply ((xmodel)) ((((xset)).apply)))
                            (((unsupported)).apply ((((unsupported)).apply ((xmodel)) ((xfields)))) (((((xseen).xitems)).apply)))
                              (((unsupported)).apply ((((unsupported)).apply ((xtarget)) ((xmodel)))) ((((unsupported)).apply (((xf).xattname)) ((xf)) ((xfields)))))
                xtable_alias.write
                  [xself xtable_name xcreate xfiltered_relation]
                    memory > xalias
                    memory > xalias_list
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xalias_list.write (((((xself).xtable_map).xget)).apply ((xtable_name)))
                        (((xcreate).not).and (xalias_list)).if
                          seq
                            xalias.write (((unsupported)).apply ((xalias_list)) (0))
                            (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_refcount)) ((xalias)))) (1))
                            (((unsupported)).apply ((((unsupported)).apply ((xalias)) (FALSE))))
                        (xalias_list).if
                          seq
                            xalias.write ("%s%d".mod (((unsupported)).apply (((xself).xalias_prefix)) (((((xlen)).apply (((xself).xalias_map))).add 1))))
                            bogusForceDataize.write ((((xalias_list).xappend)).apply ((xalias)))
                          seq
                            xalias.write ((((unsupported)).apply ((xfiltered_relation)) ("None: is there a None literal in the EO language?")).if ((xfiltered_relation).xalias) (xtable_name))
                            (((unsupported)).apply ((((unsupported)).apply (((xself).xtable_map)) ((xtable_name)))) ((((unsupported)).apply ((xalias)))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_refcount)) ((xalias)))) (1))
                        (((unsupported)).apply ((((unsupported)).apply ((xalias)) (TRUE))))
                xref_alias.write
                  [xself xalias]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_refcount)) ((xalias)))) (1))
                xunref_alias.write
                  [xself xalias xamount]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_refcount)) ((xalias)))) ((xamount)))
                xpromote_joins.write
                  [xself xaliases]
                    memory > xalready_louter
                    memory > xalias
                    memory > xparent_louter
                    memory > xparent_alias
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xaliases.write (((xlist)).apply ((xaliases)))
                        while.
                          (xaliases)
                          [unused]
                            seq > @
                              seq
                                xalias.write ((((xaliases).xpop)).apply (0))
                                (((unsupported)).apply (((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xjoin_type)) ("None: is there a None literal in the EO language?")).if
                                  (((unsupported)).apply)
                                (((unsupported)).apply ((((unsupported)).apply (((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xjoin_type)) ("None: is there a None literal in the EO language?"))))
                                xparent_alias.write ((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xparent_alias)
                                xparent_louter.write ((xparent_alias).and (((((unsupported)).apply (((xself).xalias_map)) ((xparent_alias))).xjoin_type).eq (xLOUTER)))
                                xalready_louter.write (((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xjoin_type).eq (xLOUTER))
                                ((((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xnullable).or (xparent_louter)).and ((xalready_louter).not)).if
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_map)) ((xalias)))) (((((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xpromote)).apply)))
                                    bogusForceDataize.write ((((xaliases).xextend)).apply ((((unsupported)).apply ((xjoin)) ((xjoin)) (((xself).xalias_map)) (((((((unsupported)).apply (((xself).xalias_map)) ((xjoin))).xparent_alias).eq (xalias)).and (((unsupported)).apply ((xjoin)) ((xaliases))))))))
                xdemote_joins.write
                  [xself xaliases]
                    memory > xalias
                    memory > xparent_alias
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xaliases.write (((xlist)).apply ((xaliases)))
                        while.
                          (xaliases)
                          [unused]
                            seq > @
                              seq
                                xalias.write ((((xaliases).xpop)).apply (0))
                                (((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xjoin_type).eq (xLOUTER)).if
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_map)) ((xalias)))) (((((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xdemote)).apply)))
                                    xparent_alias.write ((((unsupported)).apply (((xself).xalias_map)) ((xalias))).xparent_alias)
                                    (((((unsupported)).apply (((xself).xalias_map)) ((xparent_alias))).xjoin_type).eq (xINNER)).if
                                      bogusForceDataize.write ((((xaliases).xappend)).apply ((xparent_alias)))
                xreset_refcounts.write
                  [xself xto_counts]
                    memory > xunref_amount
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((xcur_refcount)))) (((((((((xself).xalias_refcount).xcopy)).apply).xitems)).apply)))
                          seq
                            xunref_amount.write ((xcur_refcount).sub ((((xto_counts).xget)).apply ((xalias)) (0)))
                            bogusForceDataize.write ((((xself).xunref_alias)).apply ((xalias)) ((xunref_amount)))
                xchange_aliases.write
                  [xself xchange_map]
                    memory > xtable_aliases
                    memory > xalias_data
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((((xset)).apply ((xchange_map))).xisdisjoint)).apply (((((xchange_map).xvalues)).apply)))))
                        bogusForceDataize.write (((((xself).xwhere).xrelabel_aliases)).apply ((xchange_map)))
                        (((xisinstance)).apply (((xself).xgroup_by)) ((xtuple))).if
                          (((unsupported)).apply (((xself).xgroup_by)) ((((xtuple)).apply ((((unsupported)).apply (((((xcol).xrelabeled_clone)).apply ((xchange_map)))) ((xcol)) (((xself).xgroup_by)))))))
                        (((unsupported)).apply (((xself).xselect)) ((((xtuple)).apply ((((unsupported)).apply (((((xcol).xrelabeled_clone)).apply ((xchange_map)))) ((xcol)) (((xself).xselect)))))))
                        (((unsupported)).apply (((xself).xannotations)) ((((xself).xannotations).and (((unsupported)).apply ((xkey)) (((((xcol).xrelabeled_clone)).apply ((xchange_map)))) ((((unsupported)).apply ((xkey)) ((xcol)))) ((((((xself).xannotations).xitems)).apply))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xold_alias)) ((xnew_alias)))) (((((xchange_map).xitems)).apply)))
                          seq
                            (((unsupported)).apply ((xold_alias)) (((xself).xalias_map))).if
                              (((unsupported)).apply)
                            xalias_data.write ((((((unsupported)).apply (((xself).xalias_map)) ((xold_alias))).xrelabeled_clone)).apply ((xchange_map)))
                            (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_map)) ((xnew_alias)))) ((xalias_data)))
                            (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_refcount)) ((xnew_alias)))) ((((unsupported)).apply (((xself).xalias_refcount)) ((xold_alias)))))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xself).xalias_refcount)) ((xold_alias)))))))))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xself).xalias_map)) ((xold_alias)))))))))
                            xtable_aliases.write (((unsupported)).apply (((xself).xtable_map)) (((xalias_data).xtable_name)))
                            (((unsupported)).apply ((((unsupported)).apply ((xpos)) ((xalias)))) ((((xenumerate)).apply ((xtable_aliases)))))
                              ((xalias).eq (xold_alias)).if
                                seq
                                  (((unsupported)).apply ((((unsupported)).apply ((xtable_aliases)) ((xpos)))) ((xnew_alias)))
                                  (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xexternal_aliases)) ((((unsupported)).apply (((((xchange_map).xget)).apply ((xalias)) ((xalias)))) (((xaliased).or (((unsupported)).apply ((xalias)) ((xchange_map))))) ((((unsupported)).apply ((xalias)) ((xaliased)))) ((((((xself).xexternal_aliases).xitems)).apply)))))
                xbump_prefix.write
                  [xself xother_query xexclude]
                    memory > xlocal_recursion_limit
                    memory > xprefix_gen
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xprefix_gen.write
                          []
                            memory > xseq
                            memory > xalphabet
                            memory > xprefix
                            seq > @
                              seq
                                (((unsupported)).apply)
                                xalphabet.write (xascii_uppercase)
                                xprefix.write (((xchr)).apply (((((xord)).apply (((xself).xalias_prefix))).add 1)))
                                (((unsupported)).apply ((xprefix)))
                                (((unsupported)).apply ((xn)) ((((xcount)).apply (1))))
                                  seq
                                    xseq.write ((xprefix).if (((unsupported)).apply ((xalphabet)) ((((unsupported)).apply (((((xalphabet).xindex)).apply ((xprefix))))))) (xalphabet))
                                    (((unsupported)).apply ((xs)) ((((unsupported)).apply ((xproduct)) ((xseq)) ((xn)))))
                                      (((unsupported)).apply (((("".xjoin)).apply ((xs)))))
                                    xprefix.write "None: is there a None literal in the EO language?"
                        (((xself).xalias_prefix).neq ((xother_query).xalias_prefix)).if
                          (((unsupported)).apply)
                        xlocal_recursion_limit.write (((unsupported)).apply (((((xsys).xgetrecursionlimit)).apply)) (16))
                        (((unsupported)).apply ((((unsupported)).apply ((xpos)) ((xprefix)))) ((((xenumerate)).apply ((((xprefix_gen)).apply)))))
                          seq
                            (((unsupported)).apply ((xprefix)) (((xself).xsubq_aliases))).if
                              seq
                                (((unsupported)).apply (((xself).xalias_prefix)) ((xprefix)))
                                (((unsupported)).apply)
                            ((xpos).greater (xlocal_recursion_limit)).if
                              (((unsupported)).apply ((((xRecursionError)).apply ("Maximum recursion depth exceeded: too many subqueries."))))
                        (((unsupported)).apply (((xself).xsubq_aliases)) ((((((xself).xsubq_aliases).xunion)).apply ((((unsupported)).apply (((xself).xalias_prefix)))))))
                        (((unsupported)).apply (((xother_query).xsubq_aliases)) ((((((xother_query).xsubq_aliases).xunion)).apply (((xself).xsubq_aliases)))))
                        (((unsupported)).apply ((xexclude)) ("None: is there a None literal in the EO language?")).if
                          xexclude.write (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xchange_aliases)).apply ((((unsupported)).apply ((xalias)) (("%s%d".mod (((unsupported)).apply (((xself).xalias_prefix)) ((xpos))))) ((((unsupported)).apply ((xpos)) ((xalias)))) ((((xenumerate)).apply (((xself).xalias_map)))) ((((unsupported)).apply ((xalias)) ((xexclude)))))))
                xget_initial_alias.write
                  [xself]
                    memory > xalias
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((xself).xalias_map).if
                          seq
                            xalias.write ((xself).xbase_table)
                            bogusForceDataize.write ((((xself).xref_alias)).apply ((xalias)))
                          ((xself).xmodel).if
                            xalias.write ((((xself).xjoin)).apply (((((xself).xbase_table_class)).apply ((((((xself).xget_meta)).apply).xdb_table)) ("None: is there a None literal in the EO language?"))))
                            xalias.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply ((xalias)))
                xcount_active_tables.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xlen)).apply ((((unsupported)).apply (1) ((xcount)) ((((((xself).xalias_refcount).xvalues)).apply)) ((xcount)))))))
                xjoin.write
                  [xself xjoin xreuse xreuse_with_filtered_relation]
                    memory > xjoin_type
                    memory > xreuse_aliases
                    memory > xreuse_alias
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        ((xreuse_with_filtered_relation).and (xreuse)).if
                          xreuse_aliases.write (((unsupported)).apply ((xa)) ((((unsupported)).apply ((xa)) ((xj)))) ((((((xself).xalias_map).xitems)).apply)) (((((unsupported)).apply ((xa)) ((xreuse))).and ((((xj).xequals)).apply ((xjoin))))))
                          xreuse_aliases.write (((unsupported)).apply ((xa)) ((((unsupported)).apply ((xa)) ((xj)))) ((((((xself).xalias_map).xitems)).apply)) ((((((unsupported)).apply ((xreuse)) ("None: is there a None literal in the EO language?")).or (((unsupported)).apply ((xa)) ((xreuse)))).and ((xj).eq (xjoin)))))
                        (xreuse_aliases).if
                          seq
                            (((unsupported)).apply (((xjoin).xtable_alias)) ((xreuse_aliases))).if
                              xreuse_alias.write ((xjoin).xtable_alias)
                              xreuse_alias.write (((unsupported)).apply ((xreuse_aliases)) ((1.neg)))
                            bogusForceDataize.write ((((xself).xref_alias)).apply ((xreuse_alias)))
                            (((unsupported)).apply ((xreuse_alias)))
                        (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((x_)))) ((((unsupported)).apply (((xself).xtable_alias)) (((xjoin).xtable_name)) (TRUE) (((xjoin).xfiltered_relation)))))
                        ((xjoin).xjoin_type).if
                          seq
                            ((((((unsupported)).apply (((xself).xalias_map)) (((xjoin).xparent_alias))).xjoin_type).eq (xLOUTER)).or ((xjoin).xnullable)).if
                              xjoin_type.write (xLOUTER)
                              xjoin_type.write (xINNER)
                            (((unsupported)).apply (((xjoin).xjoin_type)) ((xjoin_type)))
                        (((unsupported)).apply (((xjoin).xtable_alias)) ((xalias)))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_map)) ((xalias)))) ((xjoin)))
                        (((unsupported)).apply ((xalias)))
                xjoin_parent_model.write
                  [xself xopts xmodel xalias xseen]
                    memory > xlink_field
                    memory > xchain
                    memory > xcurr_opts
                    memory > xjoin_info
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xmodel)) ((xseen))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xseen)) ((xmodel)))))
                        xchain.write ((((xopts).xget_base_chain)).apply ((xmodel)))
                        ((xchain).not).if
                          (((unsupported)).apply ((xalias)))
                        xcurr_opts.write (xopts)
                        (((unsupported)).apply ((xint_model)) ((xchain)))
                          seq
                            (((unsupported)).apply ((xint_model)) ((xseen))).if
                              seq
                                xcurr_opts.write ((xint_model).x_meta)
                                xalias.write (((unsupported)).apply ((xseen)) ((xint_model)))
                                (((unsupported)).apply)
                            ((((unsupported)).apply (((xcurr_opts).xparents)) ((xint_model))).not).if
                              seq
                                xcurr_opts.write ((xint_model).x_meta)
                                (((unsupported)).apply)
                            xlink_field.write ((((xcurr_opts).xget_ancestor_link)).apply ((xint_model)))
                            xjoin_info.write ((((xself).xsetup_joins)).apply ((((unsupported)).apply (((xlink_field).xname)))) ((xcurr_opts)) ((xalias)))
                            xcurr_opts.write ((xint_model).x_meta)
                            (((unsupported)).apply ((xalias)) ((((unsupported)).apply ((xseen)) ((xint_model)))) ((((unsupported)).apply (((xjoin_info).xjoins)) ((1.neg)))))
                        (((unsupported)).apply (((xalias).or (((unsupported)).apply ((xseen)) ("None: is there a None literal in the EO language?")))))
                xadd_annotation.write
                  [xself xannotation xalias xis_summary xselect]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xannotation.write (((unsupported)).apply (((xannotation).xresolve_expression)) ((xself)) (TRUE) ("None: is there a None literal in the EO language?") ((xis_summary)))
                        (xselect).if
                          bogusForceDataize.write ((((xself).xappend_annotation_mask)).apply ((((unsupported)).apply ((xalias)))))
                          bogusForceDataize.write ((((xself).xset_annotation_mask)).apply (((((((xset)).apply (((xself).xannotation_select))).xdifference)).apply ((((unsupported)).apply ((xalias)))))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xannotations)) ((xalias)))) ((xannotation)))
                xresolve_expression.write
                  [xself xquery]
                    memory > xclone
                    memory > xresolved
                    seq > @
                      (((unsupported)).apply)
                        xclone.write ((((xself).xclone)).apply)
                        bogusForceDataize.write ((((xclone).xbump_prefix)).apply ((xquery)))
                        (((unsupported)).apply (((xclone).xsubquery)) (TRUE))
                        bogusForceDataize.write (((((xclone).xwhere).xresolve_expression)).apply ((xquery)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        ((xclone).xcombinator).if
                          (((unsupported)).apply (((xclone).xcombined_queries)) ((((xtuple)).apply ((((unsupported)).apply (((((xcombined_query).xresolve_expression)).apply ((xquery)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))) ((xcombined_query)) (((xclone).xcombined_queries)))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xvalue)))) ((((((xclone).xannotations).xitems)).apply)))
                          seq
                            xresolved.write ((((xvalue).xresolve_expression)).apply ((xquery)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                            (((xhasattr)).apply ((xresolved)) ("external_aliases")).if
                              bogusForceDataize.write (((((xresolved).xexternal_aliases).xupdate)).apply (((xclone).xexternal_aliases)))
                            (((unsupported)).apply ((((unsupported)).apply (((xclone).xannotations)) ((xkey)))) ((xresolved)))
                        (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((xtable)))) ((((((xquery).xalias_map).xitems)).apply)))
                          (((unsupported)).apply ((((unsupported)).apply (((xclone).xexternal_aliases)) ((xalias)))) ((((((xisinstance)).apply ((xtable)) ((xJoin))).and ((((((xtable).xjoin_field).xrelated_model).x_meta).xdb_table).neq (xalias))).or ((((xisinstance)).apply ((xtable)) ((xBaseTable))).and (((xtable).xtable_name).neq ((xtable).xtable_alias))))))
                        (((unsupported)).apply ((xclone)))
                xget_external_cols.write
                  [xself]
                    memory > xexprs
                    seq > @
                      seq
                        xexprs.write (((xchain)).apply ((((((xself).xannotations).xvalues)).apply)) ((((xself).xwhere).xchildren)))
                        (((unsupported)).apply ((((unsupported)).apply ((xcol)) ((xcol)) ((((unsupported)).apply (((xself).x_gen_cols)) ((xexprs)) (TRUE))) ((((unsupported)).apply (((xcol).xalias)) (((xself).xexternal_aliases)))))))
                xget_group_by_cols.write
                  [xself xalias]
                    memory > xexternal_cols
                    seq > @
                      (((unsupported)).apply)
                        (xalias).if
                          (((unsupported)).apply ((((unsupported)).apply ((((xRef)).apply ((xalias)) ((xself)))))))
                        xexternal_cols.write ((((xself).xget_external_cols)).apply)
                        (((xany)).apply ((((unsupported)).apply (((xcol).xpossibly_multivalued)) ((xcol)) ((xexternal_cols))))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xself)))))
                        (((unsupported)).apply ((xexternal_cols)))
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xsql
                    seq > @
                      seq
                        (((xself).xsubquery).and ((((xconnection).xfeatures).xignores_unnecessary_order_by_in_subqueries).not)).if
                          (((unsupported)).apply (((xself).xclear_ordering)) (FALSE))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((((unsupported)).apply (((xself).xget_compiler)) ((xconnection))).xas_sql)).apply)))
                        ((xself).xsubquery).if
                          xsql.write ("(%s)".mod (xsql))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                xresolve_lookup_value.write
                  [xself xvalue xcan_reuse xallow_joins]
                    memory > xtype_
                    memory > xvalues
                    seq > @
                      seq
                        (((xhasattr)).apply ((xvalue)) ("resolve_expression")).if
                          xvalue.write (((unsupported)).apply (((xvalue).xresolve_expression)) ((xself)) ((xcan_reuse)) ((xallow_joins)))
                          (((xisinstance)).apply ((xvalue)) ((((unsupported)).apply ((xlist)) ((xtuple))))).if
                            seq
                              xvalues.write (((unsupported)).apply (((((xself).xresolve_lookup_value)).apply ((xsub_value)) ((xcan_reuse)) ((xallow_joins)))) ((xsub_value)) ((xvalue)))
                              xtype_.write (((xtype)).apply ((xvalue)))
                              (((xhasattr)).apply ((xtype_)) ("_make")).if
                                (((unsupported)).apply ((((xtype_)).apply ((((unsupported)).apply ((xvalues)))))))
                              (((unsupported)).apply ((((xtype_)).apply ((xvalues)))))
                        (((unsupported)).apply ((xvalue)))
                xsolve_lookup_type.write
                  [xself xlookup]
                    memory > xlookup_splitted
                    memory > xfield_parts
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xlookup_splitted.write ((((xlookup).xsplit)).apply ((xLOOKUP_SEP)))
                        ((xself).xannotations).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xexpression)) ((xexpression_lookups)))) ((((xrefs_expression)).apply ((xlookup_splitted)) (((xself).xannotations)))))
                            (xexpression).if
                              (((unsupported)).apply ((((unsupported)).apply ((xexpression_lookups)) ((((unsupported)).apply)) ((xexpression)))))
                        (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xfield)) ((x_)) ((xlookup_parts)))) (((((xself).xnames_to_path)).apply ((xlookup_splitted)) (((((xself).xget_meta)).apply)))))
                        xfield_parts.write (((unsupported)).apply ((xlookup_splitted)) ((((unsupported)).apply (0) (((((xlen)).apply ((xlookup_splitted))).sub (((xlen)).apply ((xlookup_parts))))))))
                        (((((xlen)).apply ((xlookup_parts))).greater 1).and ((xfield_parts).not)).if
                          (((unsupported)).apply ((((xFieldError)).apply (("Invalid lookup \"%s\" for model %s\".".mod (((unsupported)).apply ((xlookup)) (((((((xself).xget_meta)).apply).xmodel).x__name__))))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xlookup_parts)) ((xfield_parts)) (FALSE))))
                xcheck_query_object_type.write
                  [xself xvalue xopts xfield]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xhasattr)).apply ((xvalue)) ("_meta")).if
                          ((((xcheck_rel_lookup_compatibility)).apply ((((xvalue).x_meta).xmodel)) ((xopts)) ((xfield))).not).if
                            (((unsupported)).apply ((((xValueError)).apply (("Cannot query \"%s\": Must be \"%s\" instance.".mod (((unsupported)).apply ((xvalue)) (((xopts).xobject_name))))))))
                xcheck_related_objects.write
                  [xself xfield xvalue xopts]
                    seq > @
                      seq
                        unsupported
                        ((xfield).xis_relation).if
                          (((((xisinstance)).apply ((xvalue)) ((xQuery))).and (((xvalue).xhas_select_fields).not)).and ((((xcheck_rel_lookup_compatibility)).apply (((xvalue).xmodel)) ((xopts)) ((xfield))).not)).if
                            (((unsupported)).apply ((((xValueError)).apply (("Cannot use QuerySet for \"%s\": Use a QuerySet for \"%s\".".mod (((unsupported)).apply (((((xvalue).xmodel).x_meta).xobject_name)) (((xopts).xobject_name))))))))
                            (((xhasattr)).apply ((xvalue)) ("_meta")).if
                              bogusForceDataize.write ((((xself).xcheck_query_object_type)).apply ((xvalue)) ((xopts)) ((xfield)))
                              (((xhasattr)).apply ((xvalue)) ("__iter__")).if
                                (((unsupported)).apply ((xv)) ((xvalue)))
                                  bogusForceDataize.write ((((xself).xcheck_query_object_type)).apply ((xv)) ((xopts)) ((xfield)))
                xcheck_filterable.write
                  [xself xexpression]
                    seq > @
                      seq
                        unsupported
                        ((((xhasattr)).apply ((xexpression)) ("resolve_expression")).and ((((xgetattr)).apply ((xexpression)) ("filterable") (TRUE)).not)).if
                          (((unsupported)).apply ((((xNotSupportedError)).apply (((((xexpression).x__class__).x__name__).add " is disallowed in the filter clause.")))))
                        (((xhasattr)).apply ((xexpression)) ("get_source_expressions")).if
                          (((unsupported)).apply ((xexpr)) (((((xexpression).xget_source_expressions)).apply)))
                            bogusForceDataize.write ((((xself).xcheck_filterable)).apply ((xexpr)))
                xbuild_lookup.write
                  [xself xlookups xlhs xrhs]
                    memory > xlookup_class
                    memory > xlookup
                    memory > xlookup_name
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xtransforms)))) ((xlookup_name)))) (((xlookups).or (((unsupported)).apply ("exact")))))
                        (((unsupported)).apply ((xname)) ((xtransforms)))
                          xlhs.write ((((xself).xtry_transform)).apply ((xlhs)) ((xname)))
                        xlookup_class.write ((((xlhs).xget_lookup)).apply ((xlookup_name)))
                        ((xlookup_class).not).if
                          seq
                            (((xlhs).xfield).xis_relation).if
                              (((unsupported)).apply ((((xFieldError)).apply (((("Related Field got invalid lookup: {}".xformat)).apply ((xlookup_name)))))))
                            xlhs.write ((((xself).xtry_transform)).apply ((xlhs)) ((xlookup_name)))
                            xlookup_name.write "exact"
                            xlookup_class.write ((((xlhs).xget_lookup)).apply ((xlookup_name)))
                            ((xlookup_class).not).if
                              (((unsupported)).apply)
                        xlookup.write (((xlookup_class)).apply ((xlhs)) ((xrhs)))
                        ((((unsupported)).apply (((xlookup).xrhs)) ("None: is there a None literal in the EO language?")).and (((xlookup).xcan_use_none_as_rhs).not)).if
                          seq
                            (((unsupported)).apply ((xlookup_name)) ((((unsupported)).apply ("exact") ("iexact")))).if
                              (((unsupported)).apply ((((xValueError)).apply ("Cannot use None as a query value"))))
                            (((unsupported)).apply (((((((xlhs).xget_lookup)).apply ("isnull"))).apply ((xlhs)) (TRUE))))
                        ((((xlookup_name).eq "exact").and (((xlookup).xrhs).eq "")).and (((((unsupported)).apply ((xconnections)) ((xDEFAULT_DB_ALIAS))).xfeatures).xinterprets_empty_strings_as_nulls)).if
                          (((unsupported)).apply (((((((xlhs).xget_lookup)).apply ("isnull"))).apply ((xlhs)) (TRUE))))
                        (((unsupported)).apply ((xlookup)))
                xtry_transform.write
                  [xself xlhs xname]
                    memory > xoutput_field
                    memory > xtransform_class
                    memory > xsuggestion
                    memory > xsuggested_lookups
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xtransform_class.write ((((xlhs).xget_transform)).apply ((xname)))
                        (xtransform_class).if
                          (((unsupported)).apply ((((xtransform_class)).apply ((xlhs)))))
                          seq
                            xoutput_field.write (((xlhs).xoutput_field).x__class__)
                            xsuggested_lookups.write ((((xdifflib).xget_close_matches)).apply ((xname)) (((((xoutput_field).xget_lookups)).apply)))
                            (xsuggested_lookups).if
                              xsuggestion.write (", perhaps you meant %s?".mod (((" or ".xjoin)).apply ((xsuggested_lookups))))
                              xsuggestion.write "."
                            (((unsupported)).apply ((((xFieldError)).apply (("Unsupported lookup '%s' for %s or join on the field not permitted%s".mod (((unsupported)).apply ((xname)) (((xoutput_field).x__name__)) ((xsuggestion))))))))
                xbuild_filter.write
                  [xself xfilter_expr xbranch_negated xcurrent_negated xcan_reuse xallow_joins xsplit_subq xreuse_with_filtered_relation xcheck_filterable]
                    memory > xalias
                    memory > xlookup_type
                    memory > xcol
                    memory > xlookup_class
                    memory > xnum_lookups
                    memory > xcondition
                    memory > xclause
                    memory > xallow_many
                    memory > xopts
                    memory > xused_joins
                    memory > xjoin_info
                    memory > xrequire_outer
                    memory > xvalue
                    memory > xpre_joins
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xisinstance)).apply ((xfilter_expr)) ((xdict))).if
                          (((unsupported)).apply ((((xFieldError)).apply ("Cannot parse keyword query as dict"))))
                        (((xisinstance)).apply ((xfilter_expr)) ((xQ))).if
                          (((unsupported)).apply ((((unsupported)).apply (((xself).x_add_q)) ((xfilter_expr)) ((xbranch_negated)) ((xcurrent_negated)) ((xcan_reuse)) ((xallow_joins)) ((xsplit_subq)) ((xcheck_filterable)))))
                        (((xhasattr)).apply ((xfilter_expr)) ("resolve_expression")).if
                          seq
                            ((((xgetattr)).apply ((xfilter_expr)) ("conditional") (FALSE)).not).if
                              (((unsupported)).apply ((((xTypeError)).apply ("Cannot filter against a non-conditional expression."))))
                            xcondition.write (((unsupported)).apply (((xfilter_expr).xresolve_expression)) ((xself)) ((xallow_joins)))
                            ((((xisinstance)).apply ((xcondition)) ((xLookup))).not).if
                              xcondition.write ((((xself).xbuild_lookup)).apply ((((unsupported)).apply ("exact"))) ((xcondition)) (TRUE))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xWhereNode)) ((((unsupported)).apply ((xcondition)))) ((xAND)))) ((((unsupported)).apply)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xarg)) ((xvalue)))) ((xfilter_expr)))
                        ((xarg).not).if
                          (((unsupported)).apply ((((xFieldError)).apply (("Cannot parse keyword query %r".mod (xarg))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xlookups)) ((xparts)) ((xreffed_expression)))) (((((xself).xsolve_lookup_type)).apply ((xarg)))))
                        (xcheck_filterable).if
                          bogusForceDataize.write ((((xself).xcheck_filterable)).apply ((xreffed_expression)))
                        (((xallow_joins).not).and ((((xlen)).apply ((xparts))).greater 1)).if
                          (((unsupported)).apply ((((xFieldError)).apply ("Joined field references are not permitted in this query"))))
                        xpre_joins.write (((((xself).xalias_refcount).xcopy)).apply)
                        xvalue.write ((((xself).xresolve_lookup_value)).apply ((xvalue)) ((xcan_reuse)) ((xallow_joins)))
                        xused_joins.write (((unsupported)).apply ((xk)) ((((unsupported)).apply ((xk)) ((xv)))) ((((((xself).xalias_refcount).xitems)).apply)) (((xv).greater ((((xpre_joins).xget)).apply ((xk)) (0)))))
                        (xcheck_filterable).if
                          bogusForceDataize.write ((((xself).xcheck_filterable)).apply ((xvalue)))
                        (xreffed_expression).if
                          seq
                            xcondition.write ((((xself).xbuild_lookup)).apply ((xlookups)) ((xreffed_expression)) ((xvalue)))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xWhereNode)) ((((unsupported)).apply ((xcondition)))) ((xAND)))) ((((unsupported)).apply)))))
                        xopts.write ((((xself).xget_meta)).apply)
                        xalias.write ((((xself).xget_initial_alias)).apply)
                        xallow_many.write (((xbranch_negated).not).or ((xsplit_subq).not))
                        (((unsupported)).apply ((xMultiJoin)))
                          seq
                            xjoin_info.write (((unsupported)).apply (((xself).xsetup_joins)) ((xparts)) ((xopts)) ((xalias)) ((xcan_reuse)) ((xallow_many)) ((xreuse_with_filtered_relation)))
                            (((xisinstance)).apply ((xvalue)) ((xIterator))).if
                              xvalue.write (((xlist)).apply ((xvalue)))
                            bogusForceDataize.write ((((xself).xcheck_related_objects)).apply (((xjoin_info).xfinal_field)) ((xvalue)) (((xjoin_info).xopts)))
                            (((unsupported)).apply (((xself).x_lookup_joins)) (((xjoin_info).xjoins)))
                          (((unsupported)).apply (((((xself).xsplit_exclude)).apply ((xfilter_expr)) ((xcan_reuse)) (((xe).xnames_with_path)))))
                        bogusForceDataize.write ((((xused_joins).xupdate)).apply (((xjoin_info).xjoins)))
                        (((unsupported)).apply ((((unsupported)).apply ((xtargets)) ((xalias)) ((xjoin_list)))) (((((xself).xtrim_joins)).apply (((xjoin_info).xtargets)) (((xjoin_info).xjoins)) (((xjoin_info).xpath)))))
                        (((unsupported)).apply ((xcan_reuse)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xcan_reuse).xupdate)).apply ((xjoin_list)))
                        (((xjoin_info).xfinal_field).xis_relation).if
                          seq
                            xnum_lookups.write (((xlen)).apply ((xlookups)))
                            ((xnum_lookups).greater 1).if
                              (((unsupported)).apply ((((xFieldError)).apply (((("Related Field got invalid lookup: {}".xformat)).apply ((((unsupported)).apply ((xlookups)) (0))))))))
                            ((((xlen)).apply ((xtargets))).eq 1).if
                              xcol.write ((((xself).x_get_col)).apply ((((unsupported)).apply ((xtargets)) (0))) (((xjoin_info).xfinal_field)) ((xalias)))
                              xcol.write (((xMultiColSource)).apply ((xalias)) ((xtargets)) (((xjoin_info).xtargets)) (((xjoin_info).xfinal_field)))
                          xcol.write ((((xself).x_get_col)).apply ((((unsupported)).apply ((xtargets)) (0))) (((xjoin_info).xfinal_field)) ((xalias)))
                        xcondition.write ((((xself).xbuild_lookup)).apply ((xlookups)) ((xcol)) ((xvalue)))
                        xlookup_type.write ((xcondition).xlookup_name)
                        xclause.write (((unsupported)).apply ((xWhereNode)) ((((unsupported)).apply ((xcondition)))) ((xAND)))
                        xrequire_outer.write ((((xlookup_type).eq "isnull").and (((unsupported)).apply (((xcondition).xrhs)) (TRUE))).and ((xcurrent_negated).not))
                        (((xcurrent_negated).and (((xlookup_type).neq "isnull").or (((unsupported)).apply (((xcondition).xrhs)) (FALSE)))).and (((unsupported)).apply (((xcondition).xrhs)) ("None: is there a None literal in the EO language?"))).if
                          seq
                            xrequire_outer.write TRUE
                            ((xlookup_type).neq "isnull").if
                              seq
                                (((((xself).xis_nullable)).apply ((((unsupported)).apply ((xtargets)) (0)))).or (((((unsupported)).apply (((xself).xalias_map)) ((((unsupported)).apply ((xjoin_list)) ((1.neg))))).xjoin_type).eq (xLOUTER))).if
                                  seq
                                    xlookup_class.write ((((((unsupported)).apply ((xtargets)) (0)).xget_lookup)).apply ("isnull"))
                                    xcol.write ((((xself).x_get_col)).apply ((((unsupported)).apply ((xtargets)) (0))) ((((unsupported)).apply (((xjoin_info).xtargets)) (0))) ((xalias)))
                                    bogusForceDataize.write ((((xclause).xadd)).apply ((((xlookup_class)).apply ((xcol)) (FALSE))) ((xAND)))
                                ((((xisinstance)).apply ((xvalue)) ((xCol))).and ((((xself).xis_nullable)).apply (((xvalue).xtarget)))).if
                                  seq
                                    xlookup_class.write (((((xvalue).xtarget).xget_lookup)).apply ("isnull"))
                                    bogusForceDataize.write ((((xclause).xadd)).apply ((((xlookup_class)).apply ((xvalue)) (FALSE))) ((xAND)))
                        (((unsupported)).apply ((((unsupported)).apply ((xclause)) ((((xrequire_outer).not).if (xused_joins) (((unsupported)).apply))))))
                xadd_filter.write
                  [xself xfilter_lhs xfilter_rhs]
                    seq > @
                      bogusForceDataize.write ((((xself).xadd_q)).apply ((((xQ)).apply ((((unsupported)).apply ((xfilter_lhs)) ((xfilter_rhs)))))))
                xadd_q.write
                  [xself xq_object]
                    memory > xexisting_inner
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xexisting_inner.write (((unsupported)).apply ((xa)) ((xa)) (((xself).xalias_map)) ((((((unsupported)).apply (((xself).xalias_map)) ((xa))).xjoin_type).eq (xINNER))))
                        (((unsupported)).apply ((((unsupported)).apply ((xclause)) ((x_)))) (((((xself).x_add_q)).apply ((xq_object)) (((xself).xused_aliases)))))
                        (xclause).if
                          bogusForceDataize.write (((((xself).xwhere).xadd)).apply ((xclause)) ((xAND)))
                        bogusForceDataize.write ((((xself).xdemote_joins)).apply ((xexisting_inner)))
                xbuild_where.write
                  [xself xfilter_expr]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xself).xbuild_filter)) ((xfilter_expr)) (FALSE))) (0))))
                xclear_where.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xself).xwhere)) ((((xWhereNode)).apply)))
                x_add_q.write
                  [xself xq_object xused_aliases xbranch_negated xcurrent_negated xallow_joins xsplit_subq xcheck_filterable]
                    memory > xconnector
                    memory > xtarget_clause
                    memory > xneeded_inner
                    memory > xjoinpromoter
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xconnector.write ((xq_object).xconnector)
                        xcurrent_negated.write (((unsupported)).apply ((xcurrent_negated)) (((xq_object).xnegated)))
                        xbranch_negated.write ((xbranch_negated).or ((xq_object).xnegated))
                        xtarget_clause.write (((unsupported)).apply ((xWhereNode)) ((xconnector)) (((xq_object).xnegated)))
                        xjoinpromoter.write (((xJoinPromoter)).apply (((xq_object).xconnector)) ((((xlen)).apply (((xq_object).xchildren)))) ((xcurrent_negated)))
                        (((unsupported)).apply ((xchild)) (((xq_object).xchildren)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xchild_clause)) ((xneeded_inner)))) ((((unsupported)).apply (((xself).xbuild_filter)) ((xchild)) ((xused_aliases)) ((xbranch_negated)) ((xcurrent_negated)) ((xallow_joins)) ((xsplit_subq)) ((xcheck_filterable)))))
                            bogusForceDataize.write ((((xjoinpromoter).xadd_votes)).apply ((xneeded_inner)))
                            (xchild_clause).if
                              bogusForceDataize.write ((((xtarget_clause).xadd)).apply ((xchild_clause)) ((xconnector)))
                        xneeded_inner.write ((((xjoinpromoter).xupdate_join_types)).apply ((xself)))
                        (((unsupported)).apply ((((unsupported)).apply ((xtarget_clause)) ((xneeded_inner)))))
                xbuild_filtered_relation_q.write
                  [xself xq_object xreuse xbranch_negated xcurrent_negated]
                    memory > xconnector
                    memory > xtarget_clause
                    memory > xchild_clause
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xconnector.write ((xq_object).xconnector)
                        (((unsupported)).apply ((xcurrent_negated)) (((xq_object).xnegated)))
                        xbranch_negated.write ((xbranch_negated).or ((xq_object).xnegated))
                        xtarget_clause.write (((unsupported)).apply ((xWhereNode)) ((xconnector)) (((xq_object).xnegated)))
                        (((unsupported)).apply ((xchild)) (((xq_object).xchildren)))
                          seq
                            (((xisinstance)).apply ((xchild)) ((xNode))).if
                              xchild_clause.write (((unsupported)).apply (((xself).xbuild_filtered_relation_q)) ((xchild)) ((xreuse)) ((xbranch_negated)) ((xcurrent_negated)))
                              (((unsupported)).apply ((((unsupported)).apply ((xchild_clause)) ((x_)))) ((((unsupported)).apply (((xself).xbuild_filter)) ((xchild)) ((xreuse)) ((xbranch_negated)) ((xcurrent_negated)) (TRUE) (FALSE) (TRUE))))
                            bogusForceDataize.write ((((xtarget_clause).xadd)).apply ((xchild_clause)) ((xconnector)))
                        (((unsupported)).apply ((xtarget_clause)))
                xadd_filtered_relation.write
                  [xself xfiltered_relation xalias]
                    memory > xshift
                    memory > xlookups
                    memory > xlookup_field_path
                    seq > @
                      seq
                        (((unsupported)).apply (((xfiltered_relation).xalias)) ((xalias)))
                        xlookups.write (((xdict)).apply ((((xget_children_from_q)).apply (((xfiltered_relation).xcondition)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrelation_lookup_parts)) ((xrelation_field_parts)) ((x_)))) (((((xself).xsolve_lookup_type)).apply (((xfiltered_relation).xrelation_name)))))
                        (xrelation_lookup_parts).if
                          (((unsupported)).apply ((((xValueError)).apply (("FilteredRelation's relation_name cannot contain lookups (got %r).".mod ((xfiltered_relation).xrelation_name))))))
                        (((unsupported)).apply ((xlookup)) ((((xchain)).apply ((xlookups)))))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlookup_parts)) ((xlookup_field_parts)) ((x_)))) (((((xself).xsolve_lookup_type)).apply ((xlookup)))))
                            xshift.write (((xlookup_parts).not).if 2 1)
                            xlookup_field_path.write (((unsupported)).apply ((xlookup_field_parts)) ((((unsupported)).apply (((xshift).neg)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xidx)) ((xlookup_field_part)))) ((((xenumerate)).apply ((xlookup_field_path)))))
                              ((((xlen)).apply ((xrelation_field_parts))).greater (xidx)).if
                                ((((unsupported)).apply ((xrelation_field_parts)) ((xidx))).neq (xlookup_field_part)).if
                                  (((unsupported)).apply ((((xValueError)).apply (("FilteredRelation's condition doesn't support relations outside the %r (got %r).".mod (((unsupported)).apply (((xfiltered_relation).xrelation_name)) ((xlookup))))))))
                                (((unsupported)).apply ((((xValueError)).apply (("FilteredRelation's condition doesn't support nested relations deeper than the relation_name (got %r for %r).".mod (((unsupported)).apply ((xlookup)) (((xfiltered_relation).xrelation_name))))))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).x_filtered_relations)) (((xfiltered_relation).xalias)))) ((xfiltered_relation)))
                xnames_to_path.write
                  [xself xnames xopts xallow_many xfail_on_missing]
                    memory > xfinal_field
                    memory > xtargets
                    memory > xparts
                    memory > xavailable
                    memory > xpath_to_parent
                    memory > xlast
                    memory > xname
                    memory > xfiltered_relation
                    memory > xpathinfos
                    memory > xfield
                    memory > xcur_names_with_path
                    memory > xmodel
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xnames_with_path)))) ((((unsupported)).apply ((((unsupported)).apply)) ((((unsupported)).apply)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xpos)) ((xname)))) ((((xenumerate)).apply ((xnames)))))
                          seq
                            xcur_names_with_path.write (((unsupported)).apply ((xname)) ((((unsupported)).apply)))
                            ((xname).eq "pk").if
                              xname.write (((xopts).xpk).xname)
                            xfield.write "None: is there a None literal in the EO language?"
                            xfiltered_relation.write "None: is there a None literal in the EO language?"
                            (((unsupported)).apply ((xFieldDoesNotExist)))
                              seq
                                (((unsupported)).apply ((xopts)) ("None: is there a None literal in the EO language?")).if
                                  (((unsupported)).apply ((xFieldDoesNotExist)))
                                xfield.write ((((xopts).xget_field)).apply ((xname)))
                              (((unsupported)).apply ((xname)) (((xself).xannotation_select))).if
                                xfield.write ((((unsupported)).apply (((xself).xannotation_select)) ((xname))).xoutput_field)
                                ((((unsupported)).apply ((xname)) (((xself).x_filtered_relations))).and ((xpos).eq 0)).if
                                  seq
                                    xfiltered_relation.write (((unsupported)).apply (((xself).x_filtered_relations)) ((xname)))
                                    (((unsupported)).apply ((xLOOKUP_SEP)) (((xfiltered_relation).xrelation_name))).if
                                      seq
                                        xparts.write (((((xfiltered_relation).xrelation_name).xsplit)).apply ((xLOOKUP_SEP)))
                                        (((unsupported)).apply ((((unsupported)).apply ((xfiltered_relation_path)) ((xfield)) ((x_)) ((x_)))) (((((xself).xnames_to_path)).apply ((xparts)) ((xopts)) ((xallow_many)) ((xfail_on_missing)))))
                                        bogusForceDataize.write ((((xpath).xextend)).apply ((((unsupported)).apply ((xfiltered_relation_path)) ((((unsupported)).apply ((1.neg)))))))
                                      xfield.write ((((xopts).xget_field)).apply (((xfiltered_relation).xrelation_name)))
                            (((unsupported)).apply ((xfield)) ("None: is there a None literal in the EO language?")).if
                              seq
                                (((xfield).xis_relation).and (((xfield).xrelated_model).not)).if
                                  (((unsupported)).apply ((((xFieldError)).apply (("Field %r does not generate an automatic reverse relation and therefore cannot be used for reverse querying. If it is a GenericForeignKey, consider adding a GenericRelation.".mod (xname))))))
                                (((unsupported)).apply ((xAttributeError)))
                                  xmodel.write ((((xfield).xmodel).x_meta).xconcrete_model)
                                  xmodel.write "None: is there a None literal in the EO language?"
                              seq
                                (((unsupported)).apply ((xpos)) (1))
                                (((xpos).eq (1.neg)).or (xfail_on_missing)).if
                                  seq
                                    xavailable.write (((xsorted)).apply ((((unsupported)).apply ((((unsupported)).apply ((((xget_field_names_from_opts)).apply ((xopts)))))) ((((unsupported)).apply (((xself).xannotation_select)))) ((((unsupported)).apply (((xself).x_filtered_relations)))))))
                                    (((unsupported)).apply ((((xFieldError)).apply (("Cannot resolve keyword '%s' into field. Choices are: %s".mod (((unsupported)).apply ((xname)) ((((", ".xjoin)).apply ((xavailable))))))))))
                                (((unsupported)).apply)
                            ((((unsupported)).apply ((xopts)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xmodel)) (((xopts).xmodel)))).if
                              seq
                                xpath_to_parent.write ((((xopts).xget_path_to_parent)).apply ((xmodel)))
                                (xpath_to_parent).if
                                  seq
                                    bogusForceDataize.write ((((xpath).xextend)).apply ((xpath_to_parent)))
                                    bogusForceDataize.write ((((((unsupported)).apply ((xcur_names_with_path)) (1)).xextend)).apply ((xpath_to_parent)))
                                    xopts.write ((((unsupported)).apply ((xpath_to_parent)) ((1.neg))).xto_opts)
                            (((xhasattr)).apply ((xfield)) ("path_infos")).if
                              seq
                                (xfiltered_relation).if
                                  xpathinfos.write ((((xfield).xget_path_info)).apply ((xfiltered_relation)))
                                  xpathinfos.write ((xfield).xpath_infos)
                                ((xallow_many).not).if
                                  (((unsupported)).apply ((((unsupported)).apply ((xinner_pos)) ((xp)))) ((((xenumerate)).apply ((xpathinfos)))))
                                    ((xp).xm2m).if
                                      seq
                                        bogusForceDataize.write ((((((unsupported)).apply ((xcur_names_with_path)) (1)).xextend)).apply ((((unsupported)).apply ((xpathinfos)) ((((unsupported)).apply (0) (((xinner_pos).add 1)))))))
                                        bogusForceDataize.write ((((xnames_with_path).xappend)).apply ((xcur_names_with_path)))
                                        (((unsupported)).apply ((((xMultiJoin)).apply (((xpos).add 1)) ((xnames_with_path)))))
                                xlast.write (((unsupported)).apply ((xpathinfos)) ((1.neg)))
                                bogusForceDataize.write ((((xpath).xextend)).apply ((xpathinfos)))
                                xfinal_field.write ((xlast).xjoin_field)
                                xopts.write ((xlast).xto_opts)
                                xtargets.write ((xlast).xtarget_fields)
                                bogusForceDataize.write ((((((unsupported)).apply ((xcur_names_with_path)) (1)).xextend)).apply ((xpathinfos)))
                                bogusForceDataize.write ((((xnames_with_path).xappend)).apply ((xcur_names_with_path)))
                              seq
                                xfinal_field.write (xfield)
                                xtargets.write (((unsupported)).apply ((xfield)))
                                ((xfail_on_missing).and (((xpos).add 1).neq (((xlen)).apply ((xnames))))).if
                                  (((unsupported)).apply ((((xFieldError)).apply (("Cannot resolve keyword %r into field. Join on '%s' not permitted.".mod (((unsupported)).apply ((((unsupported)).apply ((xnames)) (((xpos).add 1)))) ((xname))))))))
                                (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xfinal_field)) ((xtargets)) ((((unsupported)).apply ((xnames)) ((((unsupported)).apply (((xpos).add 1)))))))))
                xsetup_joins.write
                  [xself xnames xopts xalias xcan_reuse xallow_many xreuse_with_filtered_relation]
                    memory > xjoins
                    memory > xconnection
                    memory > xreuse
                    memory > xnullable
                    memory > xfinal_transformer
                    memory > xtransforms
                    memory > xfiltered_relation
                    memory > xlast_field_exception
                    memory > xtable_alias
                    memory > xtransform
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xjoins.write (((unsupported)).apply ((xalias)))
                        xfinal_transformer.write
                          [xfield xalias]
                            seq > @
                              seq
                                (((xself).xalias_cols).not).if
                                  xalias.write "None: is there a None literal in the EO language?"
                                (((unsupported)).apply (((((xfield).xget_col)).apply ((xalias)))))
                        xlast_field_exception.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply ((xpivot)) ((((xrange)).apply ((((xlen)).apply ((xnames)))) (0) ((1.neg)))))
                          (((unsupported)).apply ((xFieldError)))
                            (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xfinal_field)) ((xtargets)) ((xrest)))) ((((unsupported)).apply (((xself).xnames_to_path)) ((((unsupported)).apply ((xnames)) ((((unsupported)).apply ((xpivot)))))) ((xopts)) ((xallow_many)) (TRUE))))
                            ((xpivot).eq 1).if
                              (((unsupported)).apply)
                              xlast_field_exception.write (xexc)
                            seq
                              xtransforms.write (((unsupported)).apply ((xnames)) ((((unsupported)).apply ((xpivot)))))
                              (((unsupported)).apply)
                        (((unsupported)).apply ((xname)) ((xtransforms)))
                          seq
                            xtransform.write
                              [xfield xalias xname xprevious]
                                memory > xwrapped
                                seq > @
                                  (((unsupported)).apply)
                                    (((unsupported)).apply ((xFieldError)))
                                      seq
                                        xwrapped.write (((xprevious)).apply ((xfield)) ((xalias)))
                                        (((unsupported)).apply (((((xself).xtry_transform)).apply ((xwrapped)) ((xname)))))
                                      ((((xisinstance)).apply ((xfinal_field)) ((xField))).and (xlast_field_exception)).if
                                        (((unsupported)).apply ((xlast_field_exception)))
                                        (((unsupported)).apply)
                            xfinal_transformer.write (((unsupported)).apply (((xfunctools).xpartial)) ((xtransform)) ((xname)) ((xfinal_transformer)))
                        (((unsupported)).apply ((xjoin)) ((xpath)))
                          seq
                            ((xjoin).xfiltered_relation).if
                              seq
                                xfiltered_relation.write (((((xjoin).xfiltered_relation).xclone)).apply)
                                xtable_alias.write ((xfiltered_relation).xalias)
                              seq
                                xfiltered_relation.write "None: is there a None literal in the EO language?"
                                xtable_alias.write "None: is there a None literal in the EO language?"
                            xopts.write ((xjoin).xto_opts)
                            ((xjoin).xdirect).if
                              xnullable.write ((((xself).xis_nullable)).apply (((xjoin).xjoin_field)))
                              xnullable.write TRUE
                            xconnection.write (((unsupported)).apply (((xself).xjoin_class)) (((xopts).xdb_table)) ((xalias)) ((xtable_alias)) ((xINNER)) (((xjoin).xjoin_field)) ((xnullable)) ((xfiltered_relation)))
                            xreuse.write ((((xjoin).xm2m).or (xreuse_with_filtered_relation)).if (xcan_reuse) "None: is there a None literal in the EO language?")
                            xalias.write (((unsupported)).apply (((xself).xjoin)) ((xconnection)) ((xreuse)) ((xreuse_with_filtered_relation)))
                            bogusForceDataize.write ((((xjoins).xappend)).apply ((xalias)))
                            (xfiltered_relation).if
                              (((unsupported)).apply (((xfiltered_relation).xpath)) ((((unsupported)).apply ((xjoins)) ((((unsupported)).apply)))))
                        (((unsupported)).apply ((((xJoinInfo)).apply ((xfinal_field)) ((xtargets)) ((xopts)) ((xjoins)) ((xpath)) ((xfinal_transformer)))))
                xtrim_joins.write
                  [xself xtargets xjoins xpath]
                    memory > xtargets_dict
                    memory > xjoin_targets
                    memory > xcur_targets
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xjoins.write (((unsupported)).apply ((xjoins)) ((((unsupported)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((xpos)) ((xinfo)))) ((((xenumerate)).apply ((((xreversed)).apply ((xpath)))))))
                          seq
                            (((((xlen)).apply ((xjoins))).eq 1).or (((xinfo).xdirect).not)).if
                              (((unsupported)).apply)
                            ((xinfo).xfiltered_relation).if
                              (((unsupported)).apply)
                            xjoin_targets.write (((unsupported)).apply (((xt).xcolumn)) ((xt)) ((((xinfo).xjoin_field).xforeign_related_fields)))
                            xcur_targets.write (((unsupported)).apply (((xt).xcolumn)) ((xt)) ((xtargets)))
                            (((((xcur_targets).xissubset)).apply ((xjoin_targets))).not).if
                              (((unsupported)).apply)
                            xtargets_dict.write (((unsupported)).apply (((((unsupported)).apply ((xr)) (1)).xcolumn)) ((((unsupported)).apply ((xr)) (0))) ((xr)) ((((xinfo).xjoin_field).xrelated_fields)) ((((unsupported)).apply (((((unsupported)).apply ((xr)) (1)).xcolumn)) ((xcur_targets)))))
                            xtargets.write (((xtuple)).apply ((((unsupported)).apply ((((unsupported)).apply ((xtargets_dict)) (((xt).xcolumn)))) ((xt)) ((xtargets)))))
                            bogusForceDataize.write ((((xself).xunref_alias)).apply (((((xjoins).xpop)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((xtargets)) ((((unsupported)).apply ((xjoins)) ((1.neg)))) ((xjoins)))))
                x_gen_cols.write
                  [xcls xexprs xinclude_external]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xexpr)) ((xexprs)))
                          (((xisinstance)).apply ((xexpr)) ((xCol))).if
                            (((unsupported)).apply ((xexpr)))
                            ((xinclude_external).and (((xcallable)).apply ((((xgetattr)).apply ((xexpr)) ("get_external_cols") ("None: is there a None literal in the EO language?"))))).if
                              (((unsupported)).apply (((((xexpr).xget_external_cols)).apply)))
                              (((xhasattr)).apply ((xexpr)) ("get_source_expressions")).if
                                (((unsupported)).apply ((((unsupported)).apply (((xcls).x_gen_cols)) (((((xexpr).xget_source_expressions)).apply)) ((xinclude_external)))))
                x_gen_col_aliases.write
                  [xcls xexprs]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xexpr).xalias)) ((xexpr)) (((((xcls).x_gen_cols)).apply ((xexprs)))))))
                xresolve_ref.write
                  [xself xname xallow_joins xreuse xsummarize]
                    memory > xfield_list
                    memory > xtransform
                    memory > xannotation
                    memory > xjoin_info
                    seq > @
                      (((unsupported)).apply)
                        xannotation.write (((((xself).xannotations).xget)).apply ((xname)))
                        (((unsupported)).apply ((xannotation)) ("None: is there a None literal in the EO language?")).if
                          seq
                            ((xallow_joins).not).if
                              (((unsupported)).apply ((xalias)) (((((xself).x_gen_col_aliases)).apply ((((unsupported)).apply ((xannotation)))))))
                                (((xisinstance)).apply ((((unsupported)).apply (((xself).xalias_map)) ((xalias)))) ((xJoin))).if
                                  (((unsupported)).apply ((((xFieldError)).apply ("Joined field references are not permitted in this query"))))
                            (xsummarize).if
                              seq
                                (((unsupported)).apply ((xname)) (((xself).xannotation_select))).if
                                  (((unsupported)).apply ((((xFieldError)).apply (("Cannot aggregate over the '%s' alias. Use annotate() to promote it.".mod (xname))))))
                                (((unsupported)).apply ((((xRef)).apply ((xname)) ((((unsupported)).apply (((xself).xannotation_select)) ((xname)))))))
                              (((unsupported)).apply ((xannotation)))
                          seq
                            xfield_list.write ((((xname).xsplit)).apply ((xLOOKUP_SEP)))
                            xannotation.write (((((xself).xannotations).xget)).apply ((((unsupported)).apply ((xfield_list)) (0))))
                            (((unsupported)).apply ((xannotation)) ("None: is there a None literal in the EO language?")).if
                              seq
                                (((unsupported)).apply ((xtransform)) ((((unsupported)).apply ((xfield_list)) ((((unsupported)).apply (1))))))
                                  xannotation.write ((((xself).xtry_transform)).apply ((xannotation)) ((xtransform)))
                                (((unsupported)).apply ((xannotation)))
                            xjoin_info.write (((unsupported)).apply (((xself).xsetup_joins)) ((xfield_list)) (((((xself).xget_meta)).apply)) (((((xself).xget_initial_alias)).apply)) ((xreuse)))
                            (((unsupported)).apply ((((unsupported)).apply ((xtargets)) ((xfinal_alias)) ((xjoin_list)))) (((((xself).xtrim_joins)).apply (((xjoin_info).xtargets)) (((xjoin_info).xjoins)) (((xjoin_info).xpath)))))
                            (((xallow_joins).not).and ((((xlen)).apply ((xjoin_list))).greater 1)).if
                              (((unsupported)).apply ((((xFieldError)).apply ("Joined field references are not permitted in this query"))))
                            ((((xlen)).apply ((xtargets))).greater 1).if
                              (((unsupported)).apply ((((xFieldError)).apply ("Referencing multicolumn fields with F() objects isn't supported"))))
                            xtransform.write ((((xjoin_info).xtransform_function)).apply ((((unsupported)).apply ((xtargets)) (0))) ((xfinal_alias)))
                            (((unsupported)).apply ((xreuse)) ("None: is there a None literal in the EO language?")).if
                              bogusForceDataize.write ((((xreuse).xupdate)).apply ((xjoin_list)))
                            (((unsupported)).apply ((xtransform)))
                xsplit_exclude.write
                  [xself xfilter_expr xcan_reuse xnames_with_path]
                    memory > xselect_field
                    memory > xalias
                    memory > xpk
                    memory > xlookup
                    memory > xcol
                    memory > xquery
                    memory > xlookup_class
                    memory > xfilter_rhs
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xquery.write ((((xself).x__class__)).apply (((xself).xmodel)))
                        (((unsupported)).apply (((xquery).x_filtered_relations)) (((xself).x_filtered_relations)))
                        (((unsupported)).apply ((((unsupported)).apply ((xfilter_lhs)) ((xfilter_rhs)))) ((xfilter_expr)))
                        (((xisinstance)).apply ((xfilter_rhs)) ((xOuterRef))).if
                          xfilter_rhs.write (((xOuterRef)).apply ((xfilter_rhs)))
                          (((xisinstance)).apply ((xfilter_rhs)) ((xF))).if
                            xfilter_rhs.write (((xOuterRef)).apply (((xfilter_rhs).xname)))
                        bogusForceDataize.write ((((xquery).xadd_filter)).apply ((xfilter_lhs)) ((xfilter_rhs)))
                        (((unsupported)).apply (((xquery).xclear_ordering)) (TRUE))
                        (((unsupported)).apply ((((unsupported)).apply ((xtrimmed_prefix)) ((xcontains_louter)))) (((((xquery).xtrim_start)).apply ((xnames_with_path)))))
                        xcol.write (((unsupported)).apply (((xquery).xselect)) (0))
                        xselect_field.write ((xcol).xtarget)
                        xalias.write ((xcol).xalias)
                        (((unsupported)).apply ((xalias)) ((xcan_reuse))).if
                          seq
                            xpk.write ((((xselect_field).xmodel).x_meta).xpk)
                            bogusForceDataize.write ((((xquery).xbump_prefix)).apply ((xself)))
                            xlookup_class.write ((((xselect_field).xget_lookup)).apply ("exact"))
                            xlookup.write (((xlookup_class)).apply (((((xpk).xget_col)).apply (((((unsupported)).apply (((xquery).xselect)) (0)).xalias)))) (((((xpk).xget_col)).apply ((xalias)))))
                            bogusForceDataize.write (((((xquery).xwhere).xadd)).apply ((xlookup)) ((xAND)))
                            (((unsupported)).apply ((((unsupported)).apply (((xquery).xexternal_aliases)) ((xalias)))) (TRUE))
                        xlookup_class.write ((((xselect_field).xget_lookup)).apply ("exact"))
                        xlookup.write (((xlookup_class)).apply ((xcol)) ((((xResolvedOuterRef)).apply ((xtrimmed_prefix)))))
                        bogusForceDataize.write (((((xquery).xwhere).xadd)).apply ((xlookup)) ((xAND)))
                        (((unsupported)).apply ((((unsupported)).apply ((xcondition)) ((xneeded_inner)))) (((((xself).xbuild_filter)).apply ((((xExists)).apply ((xquery)))))))
                        (xcontains_louter).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xor_null_condition)) ((x_)))) ((((unsupported)).apply (((xself).xbuild_filter)) ((((unsupported)).apply (("%s__isnull".mod (xtrimmed_prefix))) (TRUE))) (TRUE) (TRUE) ((xcan_reuse)))))
                            bogusForceDataize.write ((((xcondition).xadd)).apply ((xor_null_condition)) ((xOR)))
                        (((unsupported)).apply ((((unsupported)).apply ((xcondition)) ((xneeded_inner)))))
                xset_empty.write
                  [xself]
                    seq > @
                      seq
                        bogusForceDataize.write (((((xself).xwhere).xadd)).apply ((((xNothingNode)).apply)) ((xAND)))
                        (((unsupported)).apply ((xquery)) (((xself).xcombined_queries)))
                          bogusForceDataize.write ((((xquery).xset_empty)).apply)
                xis_empty.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xany)).apply ((((unsupported)).apply ((((xisinstance)).apply ((xc)) ((xNothingNode)))) ((xc)) ((((xself).xwhere).xchildren)))))))
                xset_limits.write
                  [xself xlow xhigh]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xhigh)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xhigh_mark)) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply (((xself).xhigh_mark)) ((((xmin)).apply (((xself).xhigh_mark)) ((((xself).xlow_mark).add (xhigh))))))
                            (((unsupported)).apply (((xself).xhigh_mark)) ((((xself).xlow_mark).add (xhigh))))
                        (((unsupported)).apply ((xlow)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xhigh_mark)) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply (((xself).xlow_mark)) ((((xmin)).apply (((xself).xhigh_mark)) ((((xself).xlow_mark).add (xlow))))))
                            (((unsupported)).apply (((xself).xlow_mark)) ((((xself).xlow_mark).add (xlow))))
                        (((xself).xlow_mark).eq ((xself).xhigh_mark)).if
                          bogusForceDataize.write ((((xself).xset_empty)).apply)
                xclear_limits.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xlow_mark)) (((xself).xhigh_mark)))) ((((unsupported)).apply (0) ("None: is there a None literal in the EO language?"))))
                xis_sliced.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xlow_mark).neq 0).or (((unsupported)).apply (((xself).xhigh_mark)) ("None: is there a None literal in the EO language?")))))
                xhas_limit_one.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((((unsupported)).apply (((xself).xhigh_mark)) ("None: is there a None literal in the EO language?")).and ((((xself).xhigh_mark).sub ((xself).xlow_mark)).eq 1))))
                xcan_filter.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).xis_sliced).not)))
                xclear_select_clause.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xself).xselect)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xdefault_cols)) (FALSE))
                        (((unsupported)).apply (((xself).xselect_related)) (FALSE))
                        bogusForceDataize.write ((((xself).xset_extra_mask)).apply ((((unsupported)).apply)))
                        bogusForceDataize.write ((((xself).xset_annotation_mask)).apply ((((unsupported)).apply)))
                xclear_select_fields.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xselect)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xvalues_select)) ((((unsupported)).apply)))
                xadd_select_col.write
                  [xself xcol xname]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xselect)) ((((unsupported)).apply ((xcol)))))
                        (((unsupported)).apply (((xself).xvalues_select)) ((((unsupported)).apply ((xname)))))
                xset_select.write
                  [xself xcols]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xdefault_cols)) (FALSE))
                        (((unsupported)).apply (((xself).xselect)) ((((xtuple)).apply ((xcols)))))
                xadd_distinct_fields.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xdistinct_fields)) ((xfield_names)))
                        (((unsupported)).apply (((xself).xdistinct)) (TRUE))
                xadd_fields.write
                  [xself xfield_names xallow_m2m]
                    memory > xalias
                    memory > xnames
                    memory > xcols
                    memory > xopts
                    memory > xjoin_info
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xalias.write ((((xself).xget_initial_alias)).apply)
                        xopts.write ((((xself).xget_meta)).apply)
                        (((unsupported)).apply ((xMultiJoin)) ((xFieldError)))
                          seq
                            xcols.write (((unsupported)).apply)
                            (((unsupported)).apply ((xname)) ((xfield_names)))
                              seq
                                xjoin_info.write (((unsupported)).apply (((xself).xsetup_joins)) (((((xname).xsplit)).apply ((xLOOKUP_SEP)))) ((xopts)) ((xalias)) ((xallow_m2m)))
                                (((unsupported)).apply ((((unsupported)).apply ((xtargets)) ((xfinal_alias)) ((xjoins)))) (((((xself).xtrim_joins)).apply (((xjoin_info).xtargets)) (((xjoin_info).xjoins)) (((xjoin_info).xpath)))))
                                (((unsupported)).apply ((xtarget)) ((xtargets)))
                                  bogusForceDataize.write ((((xcols).xappend)).apply (((((xjoin_info).xtransform_function)).apply ((xtarget)) ((xfinal_alias)))))
                            (xcols).if
                              bogusForceDataize.write ((((xself).xset_select)).apply ((xcols)))
                          (((unsupported)).apply ((((xFieldError)).apply (("Invalid field name: '%s'".mod (xname))))))
                          (((unsupported)).apply ((xLOOKUP_SEP)) ((xname))).if
                            (((unsupported)).apply)
                            (((unsupported)).apply ((xname)) (((xself).xannotations))).if
                              (((unsupported)).apply ((((xFieldError)).apply (("Cannot select the '%s' alias. Use annotate() to promote it.".mod (xname))))))
                              seq
                                xnames.write (((xsorted)).apply ((((unsupported)).apply ((((unsupported)).apply ((((xget_field_names_from_opts)).apply ((xopts)))))) ((((unsupported)).apply (((xself).xextra)))) ((((unsupported)).apply (((xself).xannotation_select)))) ((((unsupported)).apply (((xself).x_filtered_relations)))))))
                                (((unsupported)).apply ((((xFieldError)).apply (("Cannot resolve keyword %r into field. Choices are: %s".mod (((unsupported)).apply ((xname)) ((((", ".xjoin)).apply ((xnames))))))))))
                xadd_ordering.write
                  [xself]
                    memory > xerrors
                    memory > xitem
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xitem)) ((xordering)))
                          seq
                            (((xisinstance)).apply ((xitem)) ((xstr))).if
                              seq
                                ((xitem).eq "?").if
                                  (((unsupported)).apply)
                                ((((xitem).xstartswith)).apply ("-")).if
                                  xitem.write (((unsupported)).apply ((xitem)) ((((unsupported)).apply (1))))
                                (((unsupported)).apply ((xitem)) (((xself).xannotations))).if
                                  (((unsupported)).apply)
                                (((xself).xextra).and (((unsupported)).apply ((xitem)) (((xself).xextra)))).if
                                  (((unsupported)).apply)
                                bogusForceDataize.write ((((xself).xnames_to_path)).apply (((((xitem).xsplit)).apply ((xLOOKUP_SEP)))) ((((xself).xmodel).x_meta)))
                              ((((xhasattr)).apply ((xitem)) ("resolve_expression")).not).if
                                bogusForceDataize.write ((((xerrors).xappend)).apply ((xitem)))
                            (((xgetattr)).apply ((xitem)) ("contains_aggregate") (FALSE)).if
                              (((unsupported)).apply ((((xFieldError)).apply (("Using an aggregate in order_by() without also including it in annotate() is not allowed: %s".mod (xitem))))))
                        (xerrors).if
                          (((unsupported)).apply ((((xFieldError)).apply (("Invalid order_by arguments: %s".mod (xerrors))))))
                        (xordering).if
                          (((unsupported)).apply (((xself).xorder_by)) ((xordering)))
                          (((unsupported)).apply (((xself).xdefault_ordering)) (FALSE))
                xclear_ordering.write
                  [xself xforce xclear_default]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xforce).not).and ((((xself).xis_sliced).or ((xself).xdistinct_fields)).or ((xself).xselect_for_update))).if
                          (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xorder_by)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xextra_order_by)) ((((unsupported)).apply)))
                        (xclear_default).if
                          (((unsupported)).apply (((xself).xdefault_ordering)) (FALSE))
                xset_group_by.write
                  [xself xallow_aliases]
                    memory > xgroup_by_cols
                    memory > xgroup_by
                    memory > xalias
                    memory > xseen_models
                    memory > xmodel
                    memory > xcolumn_names
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (xallow_aliases).if
                          seq
                            xcolumn_names.write (((xset)).apply)
                            xseen_models.write (((xset)).apply)
                            (((unsupported)).apply ((xjoin)) ((((unsupported)).apply ((((xlist)).apply ((((((xself).xalias_map).xvalues)).apply)))) ((((unsupported)).apply (1))))))
                              seq
                                xmodel.write (((xjoin).xjoin_field).xrelated_model)
                                (((unsupported)).apply ((xmodel)) ((xseen_models))).if
                                  seq
                                    bogusForceDataize.write ((((xcolumn_names).xupdate)).apply ((((unsupported)).apply (((xfield).xcolumn)) ((xfield)) ((((xmodel).x_meta).xlocal_concrete_fields)))))
                                    bogusForceDataize.write ((((xseen_models).xadd)).apply ((xmodel)))
                        xgroup_by.write (((xlist)).apply (((xself).xselect)))
                        ((xself).xannotation_select).if
                          (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((xannotation)))) ((((((xself).xannotation_select).xitems)).apply)))
                            seq
                              (((xallow_aliases).not).or (((unsupported)).apply ((xalias)) ((xcolumn_names)))).if
                                xalias.write "None: is there a None literal in the EO language?"
                              xgroup_by_cols.write (((unsupported)).apply (((xannotation).xget_group_by_cols)) ((xalias)))
                              bogusForceDataize.write ((((xgroup_by).xextend)).apply ((xgroup_by_cols)))
                        (((unsupported)).apply (((xself).xgroup_by)) ((((xtuple)).apply ((xgroup_by)))))
                xadd_select_related.write
                  [xself xfields]
                    memory > xd
                    memory > xfield_dict
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xisinstance)).apply (((xself).xselect_related)) ((xbool))).if
                          xfield_dict.write (((unsupported)).apply)
                          xfield_dict.write ((xself).xselect_related)
                        (((unsupported)).apply ((xfield)) ((xfields)))
                          seq
                            xd.write (xfield_dict)
                            (((unsupported)).apply ((xpart)) (((((xfield).xsplit)).apply ((xLOOKUP_SEP)))))
                              xd.write ((((xd).xsetdefault)).apply ((xpart)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xselect_related)) ((xfield_dict)))
                xadd_extra.write
                  [xself xselect xselect_params xwhere xparams xtables xorder_by]
                    memory > xselect_pairs
                    memory > xentry
                    memory > xparam_iter
                    memory > xentry_params
                    memory > xpos
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (xselect).if
                          seq
                            xselect_pairs.write (((unsupported)).apply)
                            (xselect_params).if
                              xparam_iter.write (((xiter)).apply ((xselect_params)))
                              xparam_iter.write (((xiter)).apply ((((unsupported)).apply)))
                            (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xentry)))) (((((xselect).xitems)).apply)))
                              seq
                                xentry.write (((xstr)).apply ((xentry)))
                                xentry_params.write (((unsupported)).apply)
                                xpos.write ((((xentry).xfind)).apply ("%s"))
                                while.
                                  ((xpos).neq (1.neg))
                                  [unused]
                                    seq > @
                                      seq
                                        (((xpos).eq 0).or ((((unsupported)).apply ((xentry)) (((xpos).sub 1))).neq "%")).if
                                          bogusForceDataize.write ((((xentry_params).xappend)).apply ((((xnext)).apply ((xparam_iter)))))
                                        xpos.write ((((xentry).xfind)).apply ("%s") (((xpos).add 2)))
                                (((unsupported)).apply ((((unsupported)).apply ((xselect_pairs)) ((xname)))) ((((unsupported)).apply ((xentry)) ((xentry_params)))))
                            bogusForceDataize.write (((((xself).xextra).xupdate)).apply ((xselect_pairs)))
                        ((xwhere).or (xparams)).if
                          bogusForceDataize.write (((((xself).xwhere).xadd)).apply ((((xExtraWhere)).apply ((xwhere)) ((xparams)))) ((xAND)))
                        (xtables).if
                          (((unsupported)).apply (((xself).xextra_tables)) ((((xtuple)).apply ((xtables)))))
                        (xorder_by).if
                          (((unsupported)).apply (((xself).xextra_order_by)) ((xorder_by)))
                xclear_deferred_loading.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xself).xdeferred_loading)) ((((unsupported)).apply ((((xfrozenset)).apply)) (TRUE))))
                xadd_deferred_loading.write
                  [xself xfield_names]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xexisting)) ((xdefer)))) (((xself).xdeferred_loading)))
                        (xdefer).if
                          (((unsupported)).apply (((xself).xdeferred_loading)) ((((unsupported)).apply (((((xexisting).xunion)).apply ((xfield_names)))) (TRUE))))
                          (((unsupported)).apply (((((xexisting).xdifference)).apply ((xfield_names))))).if
                            (((unsupported)).apply (((xself).xdeferred_loading)) ((((unsupported)).apply ((xnew_existing)) (FALSE))))
                            seq
                              bogusForceDataize.write ((((xself).xclear_deferred_loading)).apply)
                              (((unsupported)).apply (((((((xset)).apply ((xfield_names))).xdifference)).apply ((xexisting))))).if
                                (((unsupported)).apply (((xself).xdeferred_loading)) ((((unsupported)).apply ((xnew_only)) (TRUE))))
                xadd_immediate_loading.write
                  [xself xfield_names]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xexisting)) ((xdefer)))) (((xself).xdeferred_loading)))
                        xfield_names.write (((xset)).apply ((xfield_names)))
                        (((unsupported)).apply ("pk") ((xfield_names))).if
                          seq
                            bogusForceDataize.write ((((xfield_names).xremove)).apply ("pk"))
                            bogusForceDataize.write ((((xfield_names).xadd)).apply (((((((xself).xget_meta)).apply).xpk).xname)))
                        (xdefer).if
                          (((unsupported)).apply (((xself).xdeferred_loading)) ((((unsupported)).apply (((((xfield_names).xdifference)).apply ((xexisting)))) (FALSE))))
                          (((unsupported)).apply (((xself).xdeferred_loading)) ((((unsupported)).apply ((((xfrozenset)).apply ((xfield_names)))) (FALSE))))
                xset_annotation_mask.write
                  [xself xnames]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((xnames)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xannotation_select_mask)) ("None: is there a None literal in the EO language?"))
                          (((unsupported)).apply (((xself).xannotation_select_mask)) ((((xset)).apply ((xnames)))))
                        (((unsupported)).apply (((xself).x_annotation_select_cache)) ("None: is there a None literal in the EO language?"))
                xappend_annotation_mask.write
                  [xself xnames]
                    seq > @
                      (((unsupported)).apply (((xself).xannotation_select_mask)) ("None: is there a None literal in the EO language?")).if
                        bogusForceDataize.write ((((xself).xset_annotation_mask)).apply ((((((xself).xannotation_select_mask).xunion)).apply ((xnames)))))
                xset_extra_mask.write
                  [xself xnames]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xnames)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xextra_select_mask)) ("None: is there a None literal in the EO language?"))
                          (((unsupported)).apply (((xself).xextra_select_mask)) ((((xset)).apply ((xnames)))))
                        (((unsupported)).apply (((xself).x_extra_select_cache)) ("None: is there a None literal in the EO language?"))
                xset_values.write
                  [xself xfields]
                    memory > xgroup_by
                    memory > xexpr
                    memory > xextra_names
                    memory > xfield_names
                    memory > xselected
                    memory > xannotation_names
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xselect_related)) (FALSE))
                        bogusForceDataize.write ((((xself).xclear_deferred_loading)).apply)
                        bogusForceDataize.write ((((xself).xclear_select_fields)).apply)
                        (xfields).if
                          seq
                            xfield_names.write (((unsupported)).apply)
                            xextra_names.write (((unsupported)).apply)
                            xannotation_names.write (((unsupported)).apply)
                            ((((xself).xextra).not).and (((xself).xannotations).not)).if
                              xfield_names.write (((xlist)).apply ((xfields)))
                              seq
                                (((unsupported)).apply (((xself).xdefault_cols)) (FALSE))
                                (((unsupported)).apply ((xf)) ((xfields)))
                                  (((unsupported)).apply ((xf)) (((xself).xextra_select))).if
                                    bogusForceDataize.write ((((xextra_names).xappend)).apply ((xf)))
                                    (((unsupported)).apply ((xf)) (((xself).xannotation_select))).if
                                      bogusForceDataize.write ((((xannotation_names).xappend)).apply ((xf)))
                                      bogusForceDataize.write ((((xfield_names).xappend)).apply ((xf)))
                            bogusForceDataize.write ((((xself).xset_extra_mask)).apply ((xextra_names)))
                            bogusForceDataize.write ((((xself).xset_annotation_mask)).apply ((xannotation_names)))
                            xselected.write (((xfrozenset)).apply ((((xfield_names).add (xextra_names)).add (xannotation_names))))
                          seq
                            xfield_names.write (((unsupported)).apply (((xf).xattname)) ((xf)) (((((xself).xmodel).x_meta).xconcrete_fields)))
                            xselected.write (((xfrozenset)).apply ((xfield_names)))
                        (((unsupported)).apply (((xself).xgroup_by)) (TRUE)).if
                          seq
                            bogusForceDataize.write ((((xself).xadd_fields)).apply ((((unsupported)).apply (((xf).xattname)) ((xf)) (((((xself).xmodel).x_meta).xconcrete_fields)))) (FALSE))
                            (((unsupported)).apply (((xself).xset_group_by)) (FALSE))
                            bogusForceDataize.write ((((xself).xclear_select_fields)).apply)
                          ((xself).xgroup_by).if
                            seq
                              xgroup_by.write (((unsupported)).apply)
                              (((unsupported)).apply ((xexpr)) (((xself).xgroup_by)))
                                seq
                                  ((((xisinstance)).apply ((xexpr)) ((xRef))).and (((unsupported)).apply (((xexpr).xrefs)) ((xselected)))).if
                                    xexpr.write (((unsupported)).apply (((xself).xannotations)) (((xexpr).xrefs)))
                                  bogusForceDataize.write ((((xgroup_by).xappend)).apply ((xexpr)))
                              (((unsupported)).apply (((xself).xgroup_by)) ((((xtuple)).apply ((xgroup_by)))))
                        (((unsupported)).apply (((xself).xvalues_select)) ((((xtuple)).apply ((xfield_names)))))
                        bogusForceDataize.write ((((xself).xadd_fields)).apply ((xfield_names)) (TRUE))
                xannotation_select.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_annotation_select_cache)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).x_annotation_select_cache)))
                          (((xself).xannotations).not).if
                            (((unsupported)).apply ((((unsupported)).apply)))
                            (((unsupported)).apply (((xself).xannotation_select_mask)) ("None: is there a None literal in the EO language?")).if
                              seq
                                (((unsupported)).apply (((xself).x_annotation_select_cache)) ((((unsupported)).apply ((xk)) ((xv)) ((((unsupported)).apply ((xk)) ((xv)))) ((((((xself).xannotations).xitems)).apply)) ((((unsupported)).apply ((xk)) (((xself).xannotation_select_mask)))))))
                                (((unsupported)).apply (((xself).x_annotation_select_cache)))
                              (((unsupported)).apply (((xself).xannotations)))
                xextra_select.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_extra_select_cache)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).x_extra_select_cache)))
                        (((xself).xextra).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          (((unsupported)).apply (((xself).xextra_select_mask)) ("None: is there a None literal in the EO language?")).if
                            seq
                              (((unsupported)).apply (((xself).x_extra_select_cache)) ((((unsupported)).apply ((xk)) ((xv)) ((((unsupported)).apply ((xk)) ((xv)))) ((((((xself).xextra).xitems)).apply)) ((((unsupported)).apply ((xk)) (((xself).xextra_select_mask)))))))
                              (((unsupported)).apply (((xself).x_extra_select_cache)))
                            (((unsupported)).apply (((xself).xextra)))
                xtrim_start.write
                  [xself xnames_with_path]
                    memory > xfirst_join
                    memory > xextra_restriction
                    memory > xjoin_field
                    memory > xalias
                    memory > xpaths_in_prefix
                    memory > xselect_alias
                    memory > xcontains_louter
                    memory > xtrimmed_prefix
                    memory > xall_paths
                    memory > xlookup_tables
                    memory > xselect_fields
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xall_paths.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xpaths)))) ((xnames_with_path)))
                          bogusForceDataize.write ((((xall_paths).xextend)).apply ((xpaths)))
                        xcontains_louter.write FALSE
                        xlookup_tables.write (((unsupported)).apply ((xt)) ((xt)) (((xself).xalias_map)) (((((unsupported)).apply ((xt)) (((xself).x_lookup_joins))).or ((xt).eq ((xself).xbase_table)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xtrimmed_paths)) ((xpath)))) ((((xenumerate)).apply ((xall_paths)))))
                          seq
                            ((xpath).xm2m).if
                              (((unsupported)).apply)
                            (((((unsupported)).apply (((xself).xalias_map)) ((((unsupported)).apply ((xlookup_tables)) (((xtrimmed_paths).add 1))))).xjoin_type).eq (xLOUTER)).if
                              xcontains_louter.write TRUE
                            xalias.write (((unsupported)).apply ((xlookup_tables)) ((xtrimmed_paths)))
                            bogusForceDataize.write ((((xself).xunref_alias)).apply ((xalias)))
                        xjoin_field.write (((xpath).xjoin_field).xfield)
                        xpaths_in_prefix.write (xtrimmed_paths)
                        xtrimmed_prefix.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)))) ((xnames_with_path)))
                          seq
                            (((xpaths_in_prefix).sub (((xlen)).apply ((xpath)))).less 0).if
                              (((unsupported)).apply)
                            bogusForceDataize.write ((((xtrimmed_prefix).xappend)).apply ((xname)))
                            (((unsupported)).apply ((xpaths_in_prefix)) ((((xlen)).apply ((xpath)))))
                        bogusForceDataize.write ((((xtrimmed_prefix).xappend)).apply (((((unsupported)).apply (((xjoin_field).xforeign_related_fields)) (0)).xname)))
                        xtrimmed_prefix.write ((((xLOOKUP_SEP).xjoin)).apply ((xtrimmed_prefix)))
                        xfirst_join.write (((unsupported)).apply (((xself).xalias_map)) ((((unsupported)).apply ((xlookup_tables)) (((xtrimmed_paths).add 1)))))
                        ((((xfirst_join).xjoin_type).neq (xLOUTER)).and (((xfirst_join).xfiltered_relation).not)).if
                          seq
                            xselect_fields.write (((unsupported)).apply ((((unsupported)).apply ((xr)) (0))) ((xr)) (((xjoin_field).xrelated_fields)))
                            xselect_alias.write (((unsupported)).apply ((xlookup_tables)) (((xtrimmed_paths).add 1)))
                            bogusForceDataize.write ((((xself).xunref_alias)).apply ((((unsupported)).apply ((xlookup_tables)) ((xtrimmed_paths)))))
                            xextra_restriction.write ((((xjoin_field).xget_extra_restriction)).apply ("None: is there a None literal in the EO language?") ((((unsupported)).apply ((xlookup_tables)) (((xtrimmed_paths).add 1)))))
                            (xextra_restriction).if
                              bogusForceDataize.write (((((xself).xwhere).xadd)).apply ((xextra_restriction)) ((xAND)))
                          seq
                            xselect_fields.write (((unsupported)).apply ((((unsupported)).apply ((xr)) (1))) ((xr)) (((xjoin_field).xrelated_fields)))
                            xselect_alias.write (((unsupported)).apply ((xlookup_tables)) ((xtrimmed_paths)))
                        (((unsupported)).apply ((xtable)) (((xself).xalias_map)))
                          ((((unsupported)).apply (((xself).xalias_refcount)) ((xtable))).greater 0).if
                            seq
                              (((unsupported)).apply ((((unsupported)).apply (((xself).xalias_map)) ((xtable)))) (((((xself).xbase_table_class)).apply (((((unsupported)).apply (((xself).xalias_map)) ((xtable))).xtable_name)) ((xtable)))))
                              (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xset_select)).apply ((((unsupported)).apply (((((xf).xget_col)).apply ((xselect_alias)))) ((xf)) ((xselect_fields)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xtrimmed_prefix)) ((xcontains_louter)))))
                xis_nullable.write
                  [xself xfield]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xfield).xnull).or (((xfield).xempty_strings_allowed).and (((((unsupported)).apply ((xconnections)) ((xDEFAULT_DB_ALIAS))).xfeatures).xinterprets_empty_strings_as_nulls)))))
            xget_order_dir.write
              [xfield xdefault]
                memory > xdirn
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xdirn.write (((unsupported)).apply ((xORDER_DIR)) ((xdefault)))
                    ((((unsupported)).apply ((xfield)) (0)).eq "-").if
                      (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xfield)) ((((unsupported)).apply (1))))) ((((unsupported)).apply ((xdirn)) (1))))))
                    (((unsupported)).apply ((((unsupported)).apply ((xfield)) ((((unsupported)).apply ((xdirn)) (0))))))
            xadd_to_dict.write
              [xdata xkey xvalue]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xkey)) ((xdata))).if
                      bogusForceDataize.write ((((((unsupported)).apply ((xdata)) ((xkey))).xadd)).apply ((xvalue)))
                      (((unsupported)).apply ((((unsupported)).apply ((xdata)) ((xkey)))) ((((unsupported)).apply ((xvalue)))))
            xis_reverse_o2o.write
              [xfield]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply (((((xfield).xis_relation).and ((xfield).xone_to_one)).and (((xfield).xconcrete).not))))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                x__init__.write
                  [xself xconnector xnum_children xnegated]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xconnector)) ((xconnector)))
                        (((unsupported)).apply (((xself).xnegated)) ((xnegated)))
                        ((xself).xnegated).if
                          ((xconnector).eq (xAND)).if
                            (((unsupported)).apply (((xself).xeffective_connector)) ((xOR)))
                            (((unsupported)).apply (((xself).xeffective_connector)) ((xAND)))
                          (((unsupported)).apply (((xself).xeffective_connector)) (((xself).xconnector)))
                        (((unsupported)).apply (((xself).xnum_children)) ((xnum_children)))
                        (((unsupported)).apply (((xself).xvotes)) ((((xCounter)).apply)))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("{self.__class__.__qualname__}(connector={self.connector!r}, num_children={self.num_children!r}, negated={self.negated!r})"))
                xadd_votes.write
                  [xself xvotes]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        bogusForceDataize.write (((((xself).xvotes).xupdate)).apply ((xvotes)))
                xupdate_join_types.write
                  [xself xquery]
                    memory > xto_demote
                    memory > xto_promote
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xto_promote.write (((xset)).apply)
                        xto_demote.write (((xset)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xtable)) ((xvotes)))) ((((((xself).xvotes).xitems)).apply)))
                          seq
                            ((((xself).xeffective_connector).eq "OR").and ((xvotes).less ((xself).xnum_children))).if
                              bogusForceDataize.write ((((xto_promote).xadd)).apply ((xtable)))
                            ((((xself).xeffective_connector).eq "AND").or ((((xself).xeffective_connector).eq "OR").and ((xvotes).eq ((xself).xnum_children)))).if
                              bogusForceDataize.write ((((xto_demote).xadd)).apply ((xtable)))
                        bogusForceDataize.write ((((xquery).xpromote_joins)).apply ((xto_promote)))
                        bogusForceDataize.write ((((xquery).xdemote_joins)).apply ((xto_demote)))
                        (((unsupported)).apply ((xto_demote)))