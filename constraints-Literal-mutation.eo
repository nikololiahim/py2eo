memory > xUniqueConstraint
memory > xlist
memory > xValueError
memory > xp
memory > xrepr
memory > xgetattr
memory > xkwargs
memory > xTypeError
memory > xDeferrable
memory > xBaseConstraint
memory > xstr
memory > xQ
memory > xNotImplementedError
memory > x_
memory > xQuery
memory > xpath
memory > xtype
memory > xparams
memory > xF
memory > xsuper
memory > xCheckConstraint
memory > xbool
memory > xtuple
memory > xexpressions
memory > xargs
memory > xExpressionList
memory > xsql
memory > xexpression
memory > xIndexExpression
memory > xEnum
memory > xisinstance
memory > xfield_name
memory > xlen
[] > constraints
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xIMMEDIATE
        memory > xremove_sql
        memory > x__all__
        memory > xdeconstruct
        memory > xconstraint_sql
        memory > x_get_condition_sql
        memory > x__eq__
        memory > x_get_check_sql
        memory > x__repr__
        memory > xcreate_sql
        memory > xclone
        memory > x_get_index_expressions
        memory > xDEFERRED
        memory > x__init__
        memory > xcontains_expressions
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x__all__.write (((unsupported)).apply ("BaseConstraint") ("CheckConstraint") ("Deferrable") ("UniqueConstraint"))
            (((unsupported)).apply)
              seq
                x__init__.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply (((xself).xname)) ((xname)))
                xcontains_expressions.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (FALSE))
                xconstraint_sql.write
                  [xself xmodel xschema_editor]
                    seq > @
                      (((unsupported)).apply ((((xNotImplementedError)).apply ("This method must be implemented by a subclass."))))
                xcreate_sql.write
                  [xself xmodel xschema_editor]
                    seq > @
                      (((unsupported)).apply ((((xNotImplementedError)).apply ("This method must be implemented by a subclass."))))
                xremove_sql.write
                  [xself xmodel xschema_editor]
                    seq > @
                      (((unsupported)).apply ((((xNotImplementedError)).apply ("This method must be implemented by a subclass."))))
                xdeconstruct.write
                  [xself]
                    memory > xpath
                    seq > @
                      seq
                        xpath.write ("%s.%s".mod (((unsupported)).apply ((((xself).x__class__).x__module__)) ((((xself).x__class__).x__name__))))
                        xpath.write ((((xpath).xreplace)).apply ("django.db.models.constraints") ("django.db.models"))
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((((unsupported)).apply)) ((((unsupported)).apply ("name") (((xself).xname)))))))
                xclone.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xargs)) ((xkwargs)))) (((((xself).xdeconstruct)).apply)))
                        (((unsupported)).apply (((((xself).x__class__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
            (((unsupported)).apply ((xBaseConstraint)))
              seq
                x__init__.write
                  [xself xcheck xname]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xcheck)) ((xcheck)))
                        ((((xgetattr)).apply ((xcheck)) ("conditional") (FALSE)).not).if
                          (((unsupported)).apply ((((xTypeError)).apply ("CheckConstraint.check must be a Q instance or boolean expression."))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xname)))
                x_get_check_sql.write
                  [xself xmodel xschema_editor]
                    memory > xcompiler
                    memory > xwhere
                    memory > xquery
                    seq > @
                      seq
                        xquery.write (((unsupported)).apply ((xQuery)) ((xmodel)) (FALSE))
                        xwhere.write ((((xquery).xbuild_where)).apply (((xself).xcheck)))
                        xcompiler.write (((unsupported)).apply (((xquery).xget_compiler)) (((xschema_editor).xconnection)))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xwhere).xas_sql)).apply ((xcompiler)) (((xschema_editor).xconnection)))))
                        (((unsupported)).apply (((xsql).mod (((xtuple)).apply ((((unsupported)).apply (((((xschema_editor).xquote_value)).apply ((xp)))) ((xp)) ((xparams))))))))
                xconstraint_sql.write
                  [xself xmodel xschema_editor]
                    memory > xcheck
                    seq > @
                      seq
                        xcheck.write ((((xself).x_get_check_sql)).apply ((xmodel)) ((xschema_editor)))
                        (((unsupported)).apply (((((xschema_editor).x_check_sql)).apply (((xself).xname)) ((xcheck)))))
                xcreate_sql.write
                  [xself xmodel xschema_editor]
                    memory > xcheck
                    seq > @
                      seq
                        xcheck.write ((((xself).x_get_check_sql)).apply ((xmodel)) ((xschema_editor)))
                        (((unsupported)).apply (((((xschema_editor).x_create_check_sql)).apply ((xmodel)) (((xself).xname)) ((xcheck)))))
                xremove_sql.write
                  [xself xmodel xschema_editor]
                    seq > @
                      (((unsupported)).apply (((((xschema_editor).x_delete_check_sql)).apply ((xmodel)) (((xself).xname)))))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<%s: check=%s name=%s>".mod (((unsupported)).apply ((((xself).x__class__).x__qualname__)) (((xself).xcheck)) ((((xrepr)).apply (((xself).xname))))))))
                x__eq__.write
                  [xself xother]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xother)) ((xCheckConstraint))).if
                          (((unsupported)).apply (((((xself).xname).eq ((xother).xname)).and (((xself).xcheck).eq ((xother).xcheck)))))
                        (((unsupported)).apply (((((((xsuper)).apply).x__eq__)).apply ((xother)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("check"))) (((xself).xcheck)))
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xargs)) ((xkwargs)))))
            (((unsupported)).apply ((xEnum)))
              seq
                xDEFERRED.write "deferred"
                xIMMEDIATE.write "immediate"
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("{self.__class__.__qualname__}.{self._name_}"))
            (((unsupported)).apply ((xBaseConstraint)))
              seq
                x__init__.write
                  [xself xfields xname xcondition xdeferrable xinclude xopclasses]
                    seq > @
                      (((unsupported)).apply)
                        ((xname).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("A unique constraint must be named."))))
                        (((xexpressions).not).and ((xfields).not)).if
                          (((unsupported)).apply ((((xValueError)).apply ("At least one field or expression is required to define a unique constraint."))))
                        ((xexpressions).and (xfields)).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint.fields and expressions are mutually exclusive."))))
                        ((((xisinstance)).apply ((xcondition)) ((((unsupported)).apply ((((xtype)).apply ("None: is there a None literal in the EO language?"))) ((xQ))))).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint.condition must be a Q instance."))))
                        ((xcondition).and (xdeferrable)).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint with conditions cannot be deferred."))))
                        ((xinclude).and (xdeferrable)).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint with include fields cannot be deferred."))))
                        ((xopclasses).and (xdeferrable)).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint with opclasses cannot be deferred."))))
                        ((xexpressions).and (xdeferrable)).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint with expressions cannot be deferred."))))
                        ((xexpressions).and (xopclasses)).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint.opclasses cannot be used with expressions. Use django.contrib.postgres.indexes.OpClass() instead."))))
                        ((((xisinstance)).apply ((xdeferrable)) ((((unsupported)).apply ((((xtype)).apply ("None: is there a None literal in the EO language?"))) ((xDeferrable))))).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint.deferrable must be a Deferrable instance."))))
                        ((((xisinstance)).apply ((xinclude)) ((((unsupported)).apply ((((xtype)).apply ("None: is there a None literal in the EO language?"))) ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint.include must be a list or tuple."))))
                        ((((xisinstance)).apply ((xopclasses)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint.opclasses must be a list or tuple."))))
                        ((xopclasses).and ((((xlen)).apply ((xfields))).neq (((xlen)).apply ((xopclasses))))).if
                          (((unsupported)).apply ((((xValueError)).apply ("UniqueConstraint.fields and UniqueConstraint.opclasses must have the same number of elements."))))
                        (((unsupported)).apply (((xself).xfields)) ((((xtuple)).apply ((xfields)))))
                        (((unsupported)).apply (((xself).xcondition)) ((xcondition)))
                        (((unsupported)).apply (((xself).xdeferrable)) ((xdeferrable)))
                        (((unsupported)).apply (((xself).xinclude)) (((xinclude).if (((xtuple)).apply ((xinclude))) (((unsupported)).apply))))
                        (((unsupported)).apply (((xself).xopclasses)) ((xopclasses)))
                        (((unsupported)).apply (((xself).xexpressions)) ((((xtuple)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xexpression)) ((xstr))).if (((xF)).apply ((xexpression))) (xexpression))) ((xexpression)) ((xexpressions)))))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xname)))
                xcontains_expressions.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xbool)).apply (((xself).xexpressions)))))
                x_get_condition_sql.write
                  [xself xmodel xschema_editor]
                    memory > xcompiler
                    memory > xwhere
                    memory > xquery
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xcondition)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        xquery.write (((unsupported)).apply ((xQuery)) ((xmodel)) (FALSE))
                        xwhere.write ((((xquery).xbuild_where)).apply (((xself).xcondition)))
                        xcompiler.write (((unsupported)).apply (((xquery).xget_compiler)) (((xschema_editor).xconnection)))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xwhere).xas_sql)).apply ((xcompiler)) (((xschema_editor).xconnection)))))
                        (((unsupported)).apply (((xsql).mod (((xtuple)).apply ((((unsupported)).apply (((((xschema_editor).xquote_value)).apply ((xp)))) ((xp)) ((xparams))))))))
                x_get_index_expressions.write
                  [xself xmodel xschema_editor]
                    memory > xindex_expression
                    memory > xindex_expressions
                    seq > @
                      seq
                        (((xself).xexpressions).not).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        xindex_expressions.write (((unsupported)).apply)
                        (((unsupported)).apply ((xexpression)) (((xself).xexpressions)))
                          seq
                            xindex_expression.write (((xIndexExpression)).apply ((xexpression)))
                            bogusForceDataize.write ((((xindex_expression).xset_wrapper_classes)).apply (((xschema_editor).xconnection)))
                            bogusForceDataize.write ((((xindex_expressions).xappend)).apply ((xindex_expression)))
                        (((unsupported)).apply (((((((xExpressionList)).apply ((((unsupported)).apply ((xindex_expressions))))).xresolve_expression)).apply ((((unsupported)).apply ((xQuery)) ((xmodel)) (FALSE))))))
                xconstraint_sql.write
                  [xself xmodel xschema_editor]
                    memory > xcondition
                    memory > xinclude
                    memory > xexpressions
                    memory > xfields
                    seq > @
                      seq
                        xfields.write (((unsupported)).apply ((((((xmodel).x_meta).xget_field)).apply ((xfield_name)))) ((xfield_name)) (((xself).xfields)))
                        xinclude.write (((unsupported)).apply (((((((xmodel).x_meta).xget_field)).apply ((xfield_name))).xcolumn)) ((xfield_name)) (((xself).xinclude)))
                        xcondition.write ((((xself).x_get_condition_sql)).apply ((xmodel)) ((xschema_editor)))
                        xexpressions.write ((((xself).x_get_index_expressions)).apply ((xmodel)) ((xschema_editor)))
                        (((unsupported)).apply ((((unsupported)).apply (((xschema_editor).x_unique_sql)) ((xmodel)) ((xfields)) (((xself).xname)) ((xcondition)) (((xself).xdeferrable)) ((xinclude)) (((xself).xopclasses)) ((xexpressions)))))
                xcreate_sql.write
                  [xself xmodel xschema_editor]
                    memory > xcondition
                    memory > xinclude
                    memory > xexpressions
                    memory > xfields
                    seq > @
                      seq
                        xfields.write (((unsupported)).apply ((((((xmodel).x_meta).xget_field)).apply ((xfield_name)))) ((xfield_name)) (((xself).xfields)))
                        xinclude.write (((unsupported)).apply (((((((xmodel).x_meta).xget_field)).apply ((xfield_name))).xcolumn)) ((xfield_name)) (((xself).xinclude)))
                        xcondition.write ((((xself).x_get_condition_sql)).apply ((xmodel)) ((xschema_editor)))
                        xexpressions.write ((((xself).x_get_index_expressions)).apply ((xmodel)) ((xschema_editor)))
                        (((unsupported)).apply ((((unsupported)).apply (((xschema_editor).x_create_unique_sql)) ((xmodel)) ((xfields)) (((xself).xname)) ((xcondition)) (((xself).xdeferrable)) ((xinclude)) (((xself).xopclasses)) ((xexpressions)))))
                xremove_sql.write
                  [xself xmodel xschema_editor]
                    memory > xcondition
                    memory > xinclude
                    memory > xexpressions
                    seq > @
                      seq
                        xcondition.write ((((xself).x_get_condition_sql)).apply ((xmodel)) ((xschema_editor)))
                        xinclude.write (((unsupported)).apply (((((((xmodel).x_meta).xget_field)).apply ((xfield_name))).xcolumn)) ((xfield_name)) (((xself).xinclude)))
                        xexpressions.write ((((xself).x_get_index_expressions)).apply ((xmodel)) ((xschema_editor)))
                        (((unsupported)).apply ((((unsupported)).apply (((xschema_editor).x_delete_unique_sql)) ((xmodel)) (((xself).xname)) ((xcondition)) (((xself).xdeferrable)) ((xinclude)) (((xself).xopclasses)) ((xexpressions)))))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<%s:%s%s%s%s%s%s%s>".mod (((unsupported)).apply ((((xself).x__class__).x__qualname__)) (((((xself).xfields).not).if "" (" fields=%s".mod (((xrepr)).apply (((xself).xfields)))))) (((((xself).xexpressions).not).if "" (" expressions=%s".mod (((xrepr)).apply (((xself).xexpressions)))))) ((" name=%s".mod (((xrepr)).apply (((xself).xname))))) (((((unsupported)).apply (((xself).xcondition)) ("None: is there a None literal in the EO language?")).if "" (" condition=%s".mod ((xself).xcondition)))) (((((unsupported)).apply (((xself).xdeferrable)) ("None: is there a None literal in the EO language?")).if "" (" deferrable=%r".mod ((xself).xdeferrable)))) (((((xself).xinclude).not).if "" (" include=%s".mod (((xrepr)).apply (((xself).xinclude)))))) (((((xself).xopclasses).not).if "" (" opclasses=%s".mod (((xrepr)).apply (((xself).xopclasses))))))))))
                x__eq__.write
                  [xself xother]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xother)) ((xUniqueConstraint))).if
                          (((unsupported)).apply ((((((((((xself).xname).eq ((xother).xname)).and (((xself).xfields).eq ((xother).xfields))).and (((xself).xcondition).eq ((xother).xcondition))).and (((xself).xdeferrable).eq ((xother).xdeferrable))).and (((xself).xinclude).eq ((xother).xinclude))).and (((xself).xopclasses).eq ((xother).xopclasses))).and (((xself).xexpressions).eq ((xother).xexpressions)))))
                        (((unsupported)).apply (((((((xsuper)).apply).x__eq__)).apply ((xother)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        ((xself).xfields).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("fields"))) (((xself).xfields)))
                        ((xself).xcondition).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("condition"))) (((xself).xcondition)))
                        ((xself).xdeferrable).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("deferrable"))) (((xself).xdeferrable)))
                        ((xself).xinclude).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("include"))) (((xself).xinclude)))
                        ((xself).xopclasses).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("opclasses"))) (((xself).xopclasses)))
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) (((xself).xexpressions)) ((xkwargs)))))