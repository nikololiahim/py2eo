memory > xformatdate
memory > xc
memory > xValueError
memory > xstr
memory > xvalue
memory > xdivmod
memory > xscheme_chars
memory > xuses_params
memory > xParseResult
memory > xLookupError
memory > xmatch
memory > xnetloc
memory > xSplitResult
memory > x_lazy_re_compile
memory > xdatetime
memory > xMultiValueDict
memory > x_coerce_args
memory > x_splitparams
memory > xunicodedata
memory > xset
memory > xint
memory > xre
memory > xException
memory > xbase64
memory > xhasattr
memory > x_splitnetloc
memory > xbytes
memory > xquery
memory > xiter
memory > xe
memory > xetag
memory > xexc
memory > xregex
memory > xn
memory > x_coerce_result
memory > xisinstance
memory > xlen
memory > xTypeError
memory > xkey
memory > xfragment
[] > http
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > x__Y2
        memory > xhttp_date
        memory > xquote_etag
        memory > xurl_has_allowed_host_and_scheme
        memory > x_urlsplit
        memory > xBinasciiError
        memory > x__T
        memory > xASCTIME_DATE
        memory > xurlsafe_base64_encode
        memory > x_urlparse
        memory > xurlsafe_base64_decode
        memory > x__D2
        memory > x_url_has_allowed_host_and_scheme
        memory > x__M
        memory > xparse_http_date_safe
        memory > xbase36_to_int
        memory > xescape_leading_slashes
        memory > xRFC850_DATE
        memory > xparse_http_date
        memory > xRFC3986_GENDELIMS
        memory > xurlencode
        memory > xis_same_domain
        memory > xoriginal_urlencode
        memory > xint_to_base36
        memory > xMONTHS
        memory > x__Y
        memory > xRFC3986_SUBDELIMS
        memory > xparse_etags
        memory > xRFC1123_DATE
        memory > x__D
        memory > xETAG_MATCH
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            xETAG_MATCH.write (((x_lazy_re_compile)).apply ((((unsupported)).apply)) (((xre).xX)))
            xMONTHS.write ((("jan feb mar apr may jun jul aug sep oct nov dec".xsplit)).apply)
            x__D.write "(?P<day>[0-9]{2})"
            x__D2.write "(?P<day>[ 0-9][0-9])"
            x__M.write "(?P<mon>w{3})"
            x__Y.write "(?P<year>[0-9]{4})"
            x__Y2.write "(?P<year>[0-9]{2})"
            x__T.write "(?P<hour>[0-9]{2}):(?P<min>[0-9]{2}):(?P<sec>[0-9]{2})"
            xRFC1123_DATE.write (((x_lazy_re_compile)).apply (("^w{3}, %s %s %s %s GMT$".mod (((unsupported)).apply ((x__D)) ((x__M)) ((x__Y)) ((x__T))))))
            xRFC850_DATE.write (((x_lazy_re_compile)).apply (("^w{6,9}, %s-%s-%s %s GMT$".mod (((unsupported)).apply ((x__D)) ((x__M)) ((x__Y2)) ((x__T))))))
            xASCTIME_DATE.write (((x_lazy_re_compile)).apply (("^w{3} %s %s %s %s$".mod (((unsupported)).apply ((x__M)) ((x__D2)) ((x__T)) ((x__Y))))))
            xRFC3986_GENDELIMS.write ":/?#[]@"
            xRFC3986_SUBDELIMS.write "!$&'()*-,;="
            xurlencode.write
              [xquery xdoseq]
                memory > xitr
                memory > xquery_val
                memory > xquery_params
                memory > xitem
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((xisinstance)).apply ((xquery)) ((xMultiValueDict))).if
                      xquery.write ((((xquery).xlists)).apply)
                      (((xhasattr)).apply ((xquery)) ("items")).if
                        xquery.write ((((xquery).xitems)).apply)
                    xquery_params.write (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xvalue)))) ((xquery)))
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xTypeError)).apply (("Cannot encode None for key '%s' in a query string. Did you mean to pass an empty string or omit the value?".mod (xkey))))))
                          (((xdoseq).not).or (((xisinstance)).apply ((xvalue)) ((((unsupported)).apply ((xstr)) ((xbytes)))))).if
                            xquery_val.write (xvalue)
                            (((unsupported)).apply ((xTypeError)))
                              xitr.write (((xiter)).apply ((xvalue)))
                              xquery_val.write (xvalue)
                              seq
                                xquery_val.write (((unsupported)).apply)
                                (((unsupported)).apply ((xitem)) ((xitr)))
                                  seq
                                    (((unsupported)).apply ((xitem)) ("None: is there a None literal in the EO language?")).if
                                      (((unsupported)).apply ((((xTypeError)).apply (("Cannot encode None for key '%s' in a query string. Did you mean to pass an empty string or omit the value?".mod (xkey))))))
                                      ((((xisinstance)).apply ((xitem)) ((xbytes))).not).if
                                        xitem.write (((xstr)).apply ((xitem)))
                                    bogusForceDataize.write ((((xquery_val).xappend)).apply ((xitem)))
                        bogusForceDataize.write ((((xquery_params).xappend)).apply ((((unsupported)).apply ((xkey)) ((xquery_val)))))
                    (((unsupported)).apply ((((xoriginal_urlencode)).apply ((xquery_params)) ((xdoseq)))))
            xhttp_date.write
              [xepoch_seconds]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply ((xformatdate)) ((xepoch_seconds)) (TRUE))))
            xparse_http_date.write
              [xdate]
                memory > xtz
                memory > xmin
                memory > xcurrent_year
                memory > xcurrent_century
                memory > xsec
                memory > xmonth
                memory > xday
                memory > xresult
                memory > xyear
                memory > xm
                memory > xhour
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xregex)) ((((unsupported)).apply ((xRFC1123_DATE)) ((xRFC850_DATE)) ((xASCTIME_DATE)))))
                      seq
                        xm.write ((((xregex).xmatch)).apply ((xdate)))
                        (((unsupported)).apply ((xm)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply)
                      (((unsupported)).apply ((((xValueError)).apply (("%r is not in a valid HTTP date format".mod (xdate))))))
                    (((unsupported)).apply ((xException)))
                      seq
                        xtz.write (((xdatetime).xtimezone).xutc)
                        xyear.write (((xint)).apply ((((unsupported)).apply ((xm)) ("year"))))
                        ((xyear).less 100).if
                          seq
                            xcurrent_year.write ((((unsupported)).apply ((((xdatetime).xdatetime).xnow)) ((xtz))).xyear)
                            xcurrent_century.write ((xcurrent_year).sub ((xcurrent_year).mod 100))
                            (((xyear).sub ((xcurrent_year).mod 100)).greater 50).if
                              (((unsupported)).apply ((xyear)) (((xcurrent_century).sub 100)))
                              (((unsupported)).apply ((xyear)) ((xcurrent_century)))
                        xmonth.write (((((xMONTHS).xindex)).apply (((((((unsupported)).apply ((xm)) ("mon")).xlower)).apply))).sub 1)
                        xday.write (((xint)).apply ((((unsupported)).apply ((xm)) ("day"))))
                        xhour.write (((xint)).apply ((((unsupported)).apply ((xm)) ("hour"))))
                        xmin.write (((xint)).apply ((((unsupported)).apply ((xm)) ("min"))))
                        xsec.write (((xint)).apply ((((unsupported)).apply ((xm)) ("sec"))))
                        xresult.write (((unsupported)).apply (((xdatetime).xdatetime)) ((xyear)) ((xmonth)) ((xday)) ((xhour)) ((xmin)) ((xsec)) ((xtz)))
                        (((unsupported)).apply ((((xint)).apply (((((xresult).xtimestamp)).apply)))))
                      (((unsupported)).apply ((((xValueError)).apply (("%r is not a valid date".mod (xdate))))) ((xexc)))
            xparse_http_date_safe.write
              [xdate]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xException)))
                      (((unsupported)).apply ((((xparse_http_date)).apply ((xdate)))))
            xbase36_to_int.write
              [xs]
                seq > @
                  seq
                    (((unsupported)).apply)
                    ((((xlen)).apply ((xs))).greater 13).if
                      (((unsupported)).apply ((((xValueError)).apply ("Base36 input too large"))))
                    (((unsupported)).apply ((((xint)).apply ((xs)) (36))))
            xint_to_base36.write
              [xi]
                memory > xchar_set
                memory > xb36
                seq > @
                  seq
                    unsupported
                    xchar_set.write "0123456789abcdefghijklmnopqrstuvwxyz"
                    ((xi).less 0).if
                      (((unsupported)).apply ((((xValueError)).apply ("Negative base36 conversion input."))))
                    ((xi).less 36).if
                      (((unsupported)).apply ((((unsupported)).apply ((xchar_set)) ((xi)))))
                    xb36.write ""
                    while.
                      ((xi).neq 0)
                      [unused]
                        seq > @
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xi)) ((xn)))) ((((xdivmod)).apply ((xi)) (36))))
                            xb36.write ((((unsupported)).apply ((xchar_set)) ((xn))).sub (xb36))
                    (((unsupported)).apply ((xb36)))
            xurlsafe_base64_encode.write
              [xs]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply (((((((((((xbase64).xurlsafe_b64encode)).apply ((xs))).xrstrip)).apply ("n=")).xdecode)).apply ("ascii"))))
            xurlsafe_base64_decode.write
              [xs]
                seq > @
                  seq
                    (((unsupported)).apply)
                    xs.write ((((xs).xencode)).apply)
                    (((unsupported)).apply ((((unsupported)).apply ((xLookupError)) ((xBinasciiError)))))
                      (((unsupported)).apply (((((xbase64).xurlsafe_b64decode)).apply (((((xs).xljust)).apply (((((xlen)).apply ((xs))).sub ((((xlen)).apply ((xs))).mod 4))) ("="))))))
                      (((unsupported)).apply ((((xValueError)).apply ((xe)))))
            xparse_etags.write
              [xetag_str]
                memory > xetag_matches
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((((xetag_str).xstrip)).apply).eq "*").if
                      (((unsupported)).apply ((((unsupported)).apply ("*"))))
                      seq
                        xetag_matches.write (((unsupported)).apply (((((xETAG_MATCH).xmatch)).apply (((((xetag).xstrip)).apply)))) ((xetag)) (((((xetag_str).xsplit)).apply (","))))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xmatch)) (1))) ((xmatch)) ((xetag_matches)) ((xmatch)))))
            xquote_etag.write
              [xetag_str]
                seq > @
                  seq
                    (((unsupported)).apply)
                    ((((xETAG_MATCH).xmatch)).apply ((xetag_str))).if
                      (((unsupported)).apply ((xetag_str)))
                      (((unsupported)).apply (("\"%s\"".mod (xetag_str))))
            xis_same_domain.write
              [xhost xpattern]
                seq > @
                  seq
                    (((unsupported)).apply)
                    ((xpattern).not).if
                      (((unsupported)).apply (FALSE))
                    xpattern.write ((((xpattern).xlower)).apply)
                    (((unsupported)).apply (((((((unsupported)).apply ((xpattern)) (0)).eq ".").and (((((xhost).xendswith)).apply ((xpattern))).or ((xhost).eq (((unsupported)).apply ((xpattern)) ((((unsupported)).apply (1))))))).or ((xpattern).eq (xhost)))))
            xurl_has_allowed_host_and_scheme.write
              [xurl xallowed_hosts xrequire_https]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xurl)) ("None: is there a None literal in the EO language?")).if
                      xurl.write ((((xurl).xstrip)).apply)
                    ((xurl).not).if
                      (((unsupported)).apply (FALSE))
                    (((unsupported)).apply ((xallowed_hosts)) ("None: is there a None literal in the EO language?")).if
                      xallowed_hosts.write (((xset)).apply)
                      (((xisinstance)).apply ((xallowed_hosts)) ((xstr))).if
                        xallowed_hosts.write (((unsupported)).apply ((xallowed_hosts)))
                    (((unsupported)).apply (((((unsupported)).apply ((x_url_has_allowed_host_and_scheme)) ((xurl)) ((xallowed_hosts)) ((xrequire_https))).and (((unsupported)).apply ((x_url_has_allowed_host_and_scheme)) (((((xurl).xreplace)).apply ("\\") ("/"))) ((xallowed_hosts)) ((xrequire_https))))))
            x_urlparse.write
              [xurl xscheme xallow_fragments]
                memory > xresult
                memory > xparams
                memory > xsplitresult
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply ((xurl)) ((xscheme)) ((x_coerce_result)))) ((((x_coerce_args)).apply ((xurl)) ((xscheme)))))
                    xsplitresult.write (((x_urlsplit)).apply ((xurl)) ((xscheme)) ((xallow_fragments)))
                    (((unsupported)).apply ((((unsupported)).apply ((xscheme)) ((xnetloc)) ((xurl)) ((xquery)) ((xfragment)))) ((xsplitresult)))
                    ((((unsupported)).apply ((xscheme)) ((xuses_params))).and (((unsupported)).apply (";") ((xurl)))).if
                      (((unsupported)).apply ((((unsupported)).apply ((xurl)) ((xparams)))) ((((x_splitparams)).apply ((xurl)))))
                      xparams.write ""
                    xresult.write (((xParseResult)).apply ((xscheme)) ((xnetloc)) ((xurl)) ((xparams)) ((xquery)) ((xfragment)))
                    (((unsupported)).apply ((((x_coerce_result)).apply ((xresult)))))
            x_urlsplit.write
              [xurl xscheme xallow_fragments]
                memory > xnetloc
                memory > xi
                memory > xquery
                memory > xv
                memory > xfragment
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply ((xurl)) ((xscheme)) ((x_coerce_result)))) ((((x_coerce_args)).apply ((xurl)) ((xscheme)))))
                    (((unsupported)).apply ((xnetloc)) ((xquery)) ((xfragment)) (""))
                    xi.write ((((xurl).xfind)).apply (":"))
                    ((xi).greater 0).if
                      (((unsupported)).apply ((xc)) ((((unsupported)).apply ((xurl)) ((((unsupported)).apply ((xi)))))))
                        (((unsupported)).apply ((xc)) ((xscheme_chars))).if
                          (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xscheme)) ((xurl)))) ((((unsupported)).apply (((((((unsupported)).apply ((xurl)) ((((unsupported)).apply ((xi))))).xlower)).apply)) ((((unsupported)).apply ((xurl)) ((((unsupported)).apply (((xi).sub 1)))))))))
                    ((((unsupported)).apply ((xurl)) ((((unsupported)).apply (2)))).eq "//").if
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xnetloc)) ((xurl)))) ((((x_splitnetloc)).apply ((xurl)) (2))))
                        (((((unsupported)).apply ("[") ((xnetloc))).and (((unsupported)).apply ("]") ((xnetloc)))).or ((((unsupported)).apply ("]") ((xnetloc))).and (((unsupported)).apply ("[") ((xnetloc))))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Invalid IPv6 URL"))))
                    ((xallow_fragments).and (((unsupported)).apply ("#") ((xurl)))).if
                      (((unsupported)).apply ((((unsupported)).apply ((xurl)) ((xfragment)))) (((((xurl).xsplit)).apply ("#") (1))))
                    (((unsupported)).apply ("?") ((xurl))).if
                      (((unsupported)).apply ((((unsupported)).apply ((xurl)) ((xquery)))) (((((xurl).xsplit)).apply ("?") (1))))
                    xv.write (((xSplitResult)).apply ((xscheme)) ((xnetloc)) ((xurl)) ((xquery)) ((xfragment)))
                    (((unsupported)).apply ((((x_coerce_result)).apply ((xv)))))
            x_url_has_allowed_host_and_scheme.write
              [xurl xallowed_hosts xrequire_https]
                memory > xvalid_schemes
                memory > xurl_info
                memory > xscheme
                seq > @
                  (((unsupported)).apply)
                    ((((xurl).xstartswith)).apply ("///")).if
                      (((unsupported)).apply (FALSE))
                    (((unsupported)).apply ((xValueError)))
                      xurl_info.write (((x_urlparse)).apply ((xurl)))
                      (((unsupported)).apply (FALSE))
                    ((((xurl_info).xnetloc).not).and ((xurl_info).xscheme)).if
                      (((unsupported)).apply (FALSE))
                    ((((unsupported)).apply (((((xunicodedata).xcategory)).apply ((((unsupported)).apply ((xurl)) (0))))) (0)).eq "C").if
                      (((unsupported)).apply (FALSE))
                    xscheme.write ((xurl_info).xscheme)
                    ((((xurl_info).xscheme).not).and ((xurl_info).xnetloc)).if
                      xscheme.write "http"
                    xvalid_schemes.write ((xrequire_https).if (((unsupported)).apply ("https")) (((unsupported)).apply ("http") ("https")))
                    (((unsupported)).apply ((((((xurl_info).xnetloc).not).or (((unsupported)).apply (((xurl_info).xnetloc)) ((xallowed_hosts)))).and (((xscheme).not).or (((unsupported)).apply ((xscheme)) ((xvalid_schemes)))))))
            xescape_leading_slashes.write
              [xurl]
                seq > @
                  seq
                    (((unsupported)).apply)
                    ((((xurl).xstartswith)).apply ("//")).if
                      xurl.write ((("/%2F{}".xformat)).apply ((((unsupported)).apply ((xurl)) ((((unsupported)).apply (2))))))
                    (((unsupported)).apply ((xurl)))