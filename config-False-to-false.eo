memory > xinspect
memory > xfalse
memory > xlist
memory > ximport_module
memory > ximport_string
memory > x_
memory > xKeyError
memory > xissubclass
memory > xgetattr
memory > xname
memory > xlen
memory > xImportError
memory > xAttributeError
memory > xcandidate
memory > xAppConfig
memory > xRuntimeError
memory > xcls_name
memory > xset
memory > xrepr
memory > xsettings
memory > xException
memory > xhasattr
memory > xmodule_has_submodule
memory > xLookupError
memory > xos
memory > xImproperlyConfigured
memory > xmodel
[] > config
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > x__repr__
        memory > x_is_default_auto_field_overridden
        memory > ximport_models
        memory > xready
        memory > xMODELS_MODULE_NAME
        memory > xdefault_auto_field
        memory > x_path_from_module
        memory > xget_models
        memory > x__init__
        memory > xcreate
        memory > xAPPS_MODULE_NAME
        memory > xget_model
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            xAPPS_MODULE_NAME.write "apps"
            xMODELS_MODULE_NAME.write "models"
            (((unsupported)).apply)
              seq
                unsupported
                x__init__.write
                  [xself xapp_name xapp_module]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xname)) ((xapp_name)))
                        (((unsupported)).apply (((xself).xmodule)) ((xapp_module)))
                        (((unsupported)).apply (((xself).xapps)) ("None: is there a None literal in the EO language?"))
                        ((((xhasattr)).apply ((xself)) ("label")).not).if
                          (((unsupported)).apply (((xself).xlabel)) ((((unsupported)).apply (((((xapp_name).xrpartition)).apply ("."))) (2))))
                        ((((((xself).xlabel).xisidentifier)).apply).not).if
                          (((unsupported)).apply ((((xImproperlyConfigured)).apply (("The app label '%s' is not a valid Python identifier.".mod ((xself).xlabel))))))
                        ((((xhasattr)).apply ((xself)) ("verbose_name")).not).if
                          (((unsupported)).apply (((xself).xverbose_name)) ((((((xself).xlabel).xtitle)).apply)))
                        ((((xhasattr)).apply ((xself)) ("path")).not).if
                          (((unsupported)).apply (((xself).xpath)) (((((xself).x_path_from_module)).apply ((xapp_module)))))
                        (((unsupported)).apply (((xself).xmodels_module)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xmodels)) ("None: is there a None literal in the EO language?"))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<%s: %s>".mod (((unsupported)).apply ((((xself).x__class__).x__name__)) (((xself).xlabel))))))
                xdefault_auto_field.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xsettings).xDEFAULT_AUTO_FIELD)))
                x_is_default_auto_field_overridden.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((xself).x__class__).xdefault_auto_field)) (((xAppConfig).xdefault_auto_field)))))
                x_path_from_module.write
                  [xself xmodule]
                    memory > xpaths
                    memory > xfilename
                    seq > @
                      seq
                        unsupported
                        xpaths.write (((xlist)).apply ((((xgetattr)).apply ((xmodule)) ("__path__") ((((unsupported)).apply)))))
                        ((((xlen)).apply ((xpaths))).neq 1).if
                          seq
                            xfilename.write (((xgetattr)).apply ((xmodule)) ("__file__") ("None: is there a None literal in the EO language?"))
                            (((unsupported)).apply ((xfilename)) ("None: is there a None literal in the EO language?")).if
                              xpaths.write (((unsupported)).apply ((((((xos).xpath).xdirname)).apply ((xfilename)))))
                              xpaths.write (((xlist)).apply ((((xset)).apply ((xpaths)))))
                        ((((xlen)).apply ((xpaths))).greater 1).if
                          (((unsupported)).apply ((((xImproperlyConfigured)).apply (("The app module %r has multiple filesystem locations (%r); you must configure this app with an AppConfig subclass with a 'path' class attribute.".mod (((unsupported)).apply ((xmodule)) ((xpaths))))))))
                          ((xpaths).not).if
                            (((unsupported)).apply ((((xImproperlyConfigured)).apply (("The app module %r has no filesystem location, you must configure this app with an AppConfig subclass with a 'path' class attribute.".mod (xmodule))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xpaths)) (0))))
                xcreate.write
                  [xcls xentry]
                    memory > xmod_path
                    memory > xapp_config_class
                    memory > xapp_configs
                    memory > xapp_module
                    memory > xmsg
                    memory > xcandidates
                    memory > xmod
                    memory > xapp_name
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xapp_config_class.write "None: is there a None literal in the EO language?"
                        xapp_name.write "None: is there a None literal in the EO language?"
                        xapp_module.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply ((xException)))
                          xapp_module.write (((ximport_module)).apply ((xentry)))
                          seq
                            (((xmodule_has_submodule)).apply ((xapp_module)) ((xAPPS_MODULE_NAME))).if
                              seq
                                xmod_path.write ("%s.%s".mod (((unsupported)).apply ((xentry)) ((xAPPS_MODULE_NAME))))
                                xmod.write (((ximport_module)).apply ((xmod_path)))
                                xapp_configs.write (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xcandidate)))) ((((unsupported)).apply ((xname)) ((xcandidate)))) (((((xinspect).xgetmembers)).apply ((xmod)) (((xinspect).xisclass)))) ((((((xissubclass)).apply ((xcandidate)) ((xcls))).and (((unsupported)).apply ((xcandidate)) ((xcls)))).and (((xgetattr)).apply ((xcandidate)) ("default") (TRUE)))))
                                ((((xlen)).apply ((xapp_configs))).eq 1).if
                                  xapp_config_class.write (((unsupported)).apply ((((unsupported)).apply ((xapp_configs)) (0))) (1))
                                  seq
                                    xapp_configs.write (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xcandidate)))) ((((unsupported)).apply ((xname)) ((xcandidate)))) ((xapp_configs)) ((((xgetattr)).apply ((xcandidate)) ("default") ((xfalse)))))
                                    ((((xlen)).apply ((xapp_configs))).greater 1).if
                                      seq
                                        xcandidates.write (((unsupported)).apply ((((xrepr)).apply ((xname)))) ((((unsupported)).apply ((xname)) ((x_)))) ((xapp_configs)))
                                        (((unsupported)).apply ((((xRuntimeError)).apply (("%r declares more than one default AppConfig: %s.".mod (((unsupported)).apply ((xmod_path)) ((((", ".xjoin)).apply ((xcandidates))))))))))
                                      ((((xlen)).apply ((xapp_configs))).eq 1).if
                                        xapp_config_class.write (((unsupported)).apply ((((unsupported)).apply ((xapp_configs)) (0))) (1))
                            (((unsupported)).apply ((xapp_config_class)) ("None: is there a None literal in the EO language?")).if
                              seq
                                xapp_config_class.write (xcls)
                                xapp_name.write (xentry)
                        (((unsupported)).apply ((xapp_config_class)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xException)))
                            xapp_config_class.write (((ximport_string)).apply ((xentry)))
                        ((((unsupported)).apply ((xapp_module)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xapp_config_class)) ("None: is there a None literal in the EO language?"))).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xmod_path)) ((x_)) ((xcls_name)))) (((((xentry).xrpartition)).apply ("."))))
                            ((xmod_path).and ((((((unsupported)).apply ((xcls_name)) (0)).xisupper)).apply)).if
                              seq
                                xmod.write (((ximport_module)).apply ((xmod_path)))
                                xcandidates.write (((unsupported)).apply ((((xrepr)).apply ((xname)))) ((((unsupported)).apply ((xname)) ((xcandidate)))) (((((xinspect).xgetmembers)).apply ((xmod)) (((xinspect).xisclass)))) (((((xissubclass)).apply ((xcandidate)) ((xcls))).and (((unsupported)).apply ((xcandidate)) ((xcls))))))
                                xmsg.write ("Module '%s' does not contain a '%s' class.".mod (((unsupported)).apply ((xmod_path)) ((xcls_name))))
                                (xcandidates).if
                                  (((unsupported)).apply ((xmsg)) ((" Choices are: %s.".mod (((", ".xjoin)).apply ((xcandidates))))))
                                (((unsupported)).apply ((((xImportError)).apply ((xmsg)))))
                              bogusForceDataize.write (((ximport_module)).apply ((xentry)))
                        ((((xissubclass)).apply ((xapp_config_class)) ((xAppConfig))).not).if
                          (((unsupported)).apply ((((xImproperlyConfigured)).apply (("'%s' isn't a subclass of AppConfig.".mod (xentry))))))
                        (((unsupported)).apply ((xapp_name)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xAttributeError)))
                            xapp_name.write ((xapp_config_class).xname)
                            (((unsupported)).apply ((((xImproperlyConfigured)).apply (("'%s' must supply a name attribute.".mod (xentry))))))
                        (((unsupported)).apply ((xImportError)))
                          xapp_module.write (((ximport_module)).apply ((xapp_name)))
                          (((unsupported)).apply ((((xImproperlyConfigured)).apply (("Cannot import '%s'. Check that '%s.%s.name' is correct.".mod (((unsupported)).apply ((xapp_name)) (((xapp_config_class).x__module__)) (((xapp_config_class).x__qualname__))))))))
                        (((unsupported)).apply ((((xapp_config_class)).apply ((xapp_name)) ((xapp_module)))))
                xget_model.write
                  [xself xmodel_name xrequire_ready]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (xrequire_ready).if
                          bogusForceDataize.write (((((xself).xapps).xcheck_models_ready)).apply)
                          bogusForceDataize.write (((((xself).xapps).xcheck_apps_ready)).apply)
                        (((unsupported)).apply ((xKeyError)))
                          (((unsupported)).apply ((((unsupported)).apply (((xself).xmodels)) (((((xmodel_name).xlower)).apply)))))
                          (((unsupported)).apply ((((xLookupError)).apply (("App '%s' doesn't have a '%s' model.".mod (((unsupported)).apply (((xself).xlabel)) ((xmodel_name))))))))
                xget_models.write
                  [xself xinclude_auto_created xinclude_swapped]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        bogusForceDataize.write (((((xself).xapps).xcheck_models_ready)).apply)
                        (((unsupported)).apply ((xmodel)) ((((((xself).xmodels).xvalues)).apply)))
                          seq
                            ((((xmodel).x_meta).xauto_created).and ((xinclude_auto_created).not)).if
                              (((unsupported)).apply)
                            ((((xmodel).x_meta).xswapped).and ((xinclude_swapped).not)).if
                              (((unsupported)).apply)
                            (((unsupported)).apply ((xmodel)))
                ximport_models.write
                  [xself]
                    memory > xmodels_module_name
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xmodels)) ((((unsupported)).apply ((((xself).xapps).xall_models)) (((xself).xlabel)))))
                        (((xmodule_has_submodule)).apply (((xself).xmodule)) ((xMODELS_MODULE_NAME))).if
                          seq
                            xmodels_module_name.write ("%s.%s".mod (((unsupported)).apply (((xself).xname)) ((xMODELS_MODULE_NAME))))
                            (((unsupported)).apply (((xself).xmodels_module)) ((((ximport_module)).apply ((xmodels_module_name)))))
                xready.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)