memory > xRuntimeWarning
memory > xpost_save
memory > xk
memory > xinspect
memory > xCoalesce
memory > xclass_prepared
memory > xsrc_expr
memory > xCASCADE
memory > xcopy
memory > xfield
memory > xUniqueConstraint
memory > xAttributeError
memory > xFieldDoesNotExist
memory > xaccessor
memory > xdjango
memory > xlist
memory > xRuntimeError
memory > xindex
memory > xenumerate
memory > xparent
memory > xkls
memory > xget_text_list
memory > xresolve_relation
memory > xunique_checks
memory > xValueError
memory > xparent_link
memory > xDJANGO_VERSION_PICKLE_KEY
memory > xfrozenset
memory > xmodel_class
memory > xchecks
memory > xQ
memory > xmanager
memory > xstr
memory > xOptions
memory > xforce_str
memory > xwarnings
memory > xFieldError
memory > xapps
memory > xlookups
memory > xfields
memory > xValidationError
memory > xModelStateCacheDescriptor
memory > xunique_for
memory > xLOOKUP_SEP
memory > xrel_name
memory > xmake_model_tuple
memory > xManager
memory > xrouter
memory > xb
memory > xvalue
memory > xpart
memory > xprop
memory > xcolumn_name
memory > xapp_label
memory > xref
memory > xNOT_PROVIDED
memory > xIndexError
memory > xpre_init
memory > xKeyError
memory > xconnection
memory > xIntegerField
memory > xobj_name
memory > xreversed
memory > xany
memory > xNON_FIELD_ERRORS
memory > xtype
memory > xparent_class
memory > xValue
memory > xm2m
memory > xf
memory > xlookup_type
memory > xset
memory > xpost_init
memory > xlookup
memory > xDatabaseError
memory > xrepr
memory > xsettings
memory > xconnections
memory > xhasattr
memory > xproperty
memory > xsum
memory > xx
memory > xdate_checks
memory > xF
memory > xModelState
memory > xchain
memory > xCheckConstraint
memory > xsuper
memory > xinvalid_field
memory > xinclude
memory > xtuple
memory > xcapfirst
memory > xNotImplemented
memory > xObjectDoesNotExist
memory > xCollector
memory > xbytes
memory > xlazy_related_operation
memory > xargs
memory > xobj
memory > xunique_check
memory > xLookupError
memory > xmodel_name
memory > xpre_save
memory > xchild
memory > xmake_hashable
memory > xunique_together
memory > xgetattr
memory > xOneToOneField
memory > xv
memory > xMax
memory > xModel
memory > xconstraint
memory > xiter
memory > xe
memory > xexpression
memory > xModelBase
memory > xsetattr
memory > xattr
memory > xname
memory > xzip
memory > xidx
memory > xDeferred
memory > xmodels
memory > xhash
memory > xExpressionWrapper
memory > xnext
memory > xForeignObjectRel
memory > xn
memory > xorder
memory > xmemoryview
memory > xkwargs
memory > xMultipleObjectsReturned
memory > xisinstance
memory > xtransaction
memory > xfield_name
memory > xlen
memory > xmodel_constraints
memory > xdict
memory > xTypeError
memory > xpartialmethod
[] > base
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > x_save_parents
        memory > x_check_column_name_clashes
        memory > x_check_m2m_through_same_relationship
        memory > xfull_clean
        memory > xDEFERRED
        memory > xrelated_managers_cache
        memory > x_check_ordering
        memory > xserializable_value
        memory > x_default_manager
        memory > xvalidate_unique
        memory > x_check_single_primary_key
        memory > xclean
        memory > xprepare_database_save
        memory > x_check_long_column_names
        memory > xdelete
        memory > x__str__
        memory > x_get_next_or_previous_by_FIELD
        memory > x_get_expr_references
        memory > xdb
        memory > xadding
        memory > xfields_cache
        memory > x__setstate__
        memory > x_check_default_pk
        memory > x__eq__
        memory > x__repr__
        memory > x_perform_unique_checks
        memory > xsave
        memory > x_check_id_field
        memory > xmethod_get_order
        memory > x__reduce__
        memory > x_check_model_name_db_lookup_clashes
        memory > x_check_swappable
        memory > x_base_manager
        memory > x_check_fields
        memory > xcheck
        memory > x_prepare
        memory > x_do_update
        memory > xmodel_unpickle
        memory > x_check_indexes
        memory > x_
        memory > xmethod_set_order
        memory > xpk
        memory > x_has_contribute_to_class
        memory > x_check_managers
        memory > x_set_pk_val
        memory > x__getstate__
        memory > x_prepare_related_fields_for_save
        memory > x_get_next_or_previous_in_order
        memory > x_get_pk_val
        memory > xsave_base
        memory > x_perform_date_checks
        memory > x_check_index_together
        memory > xmake_foreign_order_accessors
        memory > x__get__
        memory > x_check_local_fields
        memory > x_get_unique_checks
        memory > x_save_table
        memory > x__init__
        memory > xfrom_db
        memory > x_check_property_name_related_field_accessor_clashes
        memory > xclean_fields
        memory > x_check_model
        memory > x_get_FIELD_display
        memory > x_do_insert
        memory > xget_deferred_fields
        memory > x__hash__
        memory > xdate_error_message
        memory > x_check_unique_together
        memory > xunique_error_message
        memory > x__set_name__
        memory > xsubclass_exception
        memory > xrefresh_from_db
        memory > x_check_field_name_clashes
        memory > xadd_to_class
        memory > x__new__
        memory > x_check_constraints
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
              seq
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("<Deferred field>"))
                x__str__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("<Deferred field>"))
            xDEFERRED.write (((xDeferred)).apply)
            xsubclass_exception.write
              [xname xbases xmodule xattached_to]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((xtype)).apply ((xname)) ((xbases)) ((((unsupported)).apply ("__module__") ((xmodule)) ("__qualname__") (("%s.%s".mod (((unsupported)).apply (((xattached_to).x__qualname__)) ((xname))))))))))
            x_has_contribute_to_class.write
              [xvalue]
                seq > @
                  (((unsupported)).apply (((((((xinspect).xisclass)).apply ((xvalue))).not).and (((xhasattr)).apply ((xvalue)) ("contribute_to_class")))))
            (((unsupported)).apply ((xtype)))
              seq
                unsupported
                x__new__.write
                  [xcls xname xbases xattrs]
                    memory > xmeta
                    memory > xbase_key
                    memory > xparent_fields
                    memory > xsuper_new
                    memory > xfield_names
                    memory > xmodule
                    memory > xis_proxy
                    memory > xabstract
                    memory > xparents
                    memory > xfield
                    memory > xnew_fields
                    memory > xapp_label
                    memory > xnew_attrs
                    memory > xnew_field
                    memory > xbase_meta
                    memory > xbase_parents
                    memory > xrelated
                    memory > xbase
                    memory > xnew_class
                    memory > xclasscell
                    memory > xattr_meta
                    memory > xinherited_attributes
                    memory > xparent_links
                    memory > xcontributable_attrs
                    memory > xattr_name
                    memory > xapp_config
                    seq > @
                      (((unsupported)).apply)
                        xsuper_new.write ((((xsuper)).apply).x__new__)
                        xparents.write (((unsupported)).apply ((xb)) ((xb)) ((xbases)) ((((xisinstance)).apply ((xb)) ((xModelBase)))))
                        ((xparents).not).if
                          (((unsupported)).apply ((((xsuper_new)).apply ((xcls)) ((xname)) ((xbases)) ((xattrs)))))
                        xmodule.write ((((xattrs).xpop)).apply ("__module__"))
                        xnew_attrs.write (((unsupported)).apply ("__module__") ((xmodule)))
                        xclasscell.write ((((xattrs).xpop)).apply ("__classcell__") ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xclasscell)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xnew_attrs)) ("__classcell__"))) ((xclasscell)))
                        xattr_meta.write ((((xattrs).xpop)).apply ("Meta") ("None: is there a None literal in the EO language?"))
                        xcontributable_attrs.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xobj_name)) ((xobj)))) (((((xattrs).xitems)).apply)))
                          (((x_has_contribute_to_class)).apply ((xobj))).if
                            (((unsupported)).apply ((((unsupported)).apply ((xcontributable_attrs)) ((xobj_name)))) ((xobj)))
                            (((unsupported)).apply ((((unsupported)).apply ((xnew_attrs)) ((xobj_name)))) ((xobj)))
                        xnew_class.write (((xsuper_new)).apply ((xcls)) ((xname)) ((xbases)) ((xnew_attrs)) ((((unsupported)).apply ((xkwargs)))))
                        xabstract.write (((xgetattr)).apply ((xattr_meta)) ("abstract") (FALSE))
                        xmeta.write ((xattr_meta).or (((xgetattr)).apply ((xnew_class)) ("Meta") ("None: is there a None literal in the EO language?")))
                        xbase_meta.write (((xgetattr)).apply ((xnew_class)) ("_meta") ("None: is there a None literal in the EO language?"))
                        xapp_label.write "None: is there a None literal in the EO language?"
                        xapp_config.write ((((xapps).xget_containing_app_config)).apply ((xmodule)))
                        (((unsupported)).apply ((((xgetattr)).apply ((xmeta)) ("app_label") ("None: is there a None literal in the EO language?"))) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xapp_config)) ("None: is there a None literal in the EO language?")).if
                            ((xabstract).not).if
                              (((unsupported)).apply ((((xRuntimeError)).apply (("Model class %s.%s doesn't declare an explicit app_label and isn't in an application in INSTALLED_APPS.".mod (((unsupported)).apply ((xmodule)) ((xname))))))))
                            xapp_label.write ((xapp_config).xlabel)
                        bogusForceDataize.write ((((xnew_class).xadd_to_class)).apply ("_meta") ((((xOptions)).apply ((xmeta)) ((xapp_label)))))
                        ((xabstract).not).if
                          seq
                            bogusForceDataize.write ((((xnew_class).xadd_to_class)).apply ("DoesNotExist") ((((unsupported)).apply ((xsubclass_exception)) ("DoesNotExist") (((((xtuple)).apply ((((unsupported)).apply (((xx).xDoesNotExist)) ((xx)) ((xparents)) (((((xhasattr)).apply ((xx)) ("_meta")).and ((((xx).x_meta).xabstract).not)))))).or (((unsupported)).apply ((xObjectDoesNotExist))))) ((xmodule)) ((xnew_class)))))
                            bogusForceDataize.write ((((xnew_class).xadd_to_class)).apply ("MultipleObjectsReturned") ((((unsupported)).apply ((xsubclass_exception)) ("MultipleObjectsReturned") (((((xtuple)).apply ((((unsupported)).apply (((xx).xMultipleObjectsReturned)) ((xx)) ((xparents)) (((((xhasattr)).apply ((xx)) ("_meta")).and ((((xx).x_meta).xabstract).not)))))).or (((unsupported)).apply ((xMultipleObjectsReturned))))) ((xmodule)) ((xnew_class)))))
                            ((xbase_meta).and (((xbase_meta).xabstract).not)).if
                              seq
                                ((((xhasattr)).apply ((xmeta)) ("ordering")).not).if
                                  (((unsupported)).apply ((((xnew_class).x_meta).xordering)) (((xbase_meta).xordering)))
                                ((((xhasattr)).apply ((xmeta)) ("get_latest_by")).not).if
                                  (((unsupported)).apply ((((xnew_class).x_meta).xget_latest_by)) (((xbase_meta).xget_latest_by)))
                        xis_proxy.write (((xnew_class).x_meta).xproxy)
                        (((xis_proxy).and (xbase_meta)).and ((xbase_meta).xswapped)).if
                          (((unsupported)).apply ((((xTypeError)).apply (("%s cannot proxy the swapped model '%s'.".mod (((unsupported)).apply ((xname)) (((xbase_meta).xswapped))))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xobj_name)) ((xobj)))) (((((xcontributable_attrs).xitems)).apply)))
                          bogusForceDataize.write ((((xnew_class).xadd_to_class)).apply ((xobj_name)) ((xobj)))
                        xnew_fields.write (((xchain)).apply ((((xnew_class).x_meta).xlocal_fields)) ((((xnew_class).x_meta).xlocal_many_to_many)) ((((xnew_class).x_meta).xprivate_fields)))
                        xfield_names.write (((unsupported)).apply (((xf).xname)) ((xf)) ((xnew_fields)))
                        (xis_proxy).if
                          seq
                            xbase.write "None: is there a None literal in the EO language?"
                            (((unsupported)).apply ((xparent)) ((((unsupported)).apply ((xkls)) ((xkls)) ((xparents)) ((((xhasattr)).apply ((xkls)) ("_meta"))))))
                              seq
                                (((xparent).x_meta).xabstract).if
                                  (((xparent).x_meta).xfields).if
                                    (((unsupported)).apply ((((xTypeError)).apply (("Abstract base class containing model fields not permitted for proxy model '%s'.".mod (xname))))))
                                    (((unsupported)).apply)
                                (((unsupported)).apply ((xbase)) ("None: is there a None literal in the EO language?")).if
                                  xbase.write (xparent)
                                  (((unsupported)).apply ((((xparent).x_meta).xconcrete_model)) ((((xbase).x_meta).xconcrete_model))).if
                                    (((unsupported)).apply ((((xTypeError)).apply (("Proxy model '%s' has more than one non-abstract model base class.".mod (xname))))))
                            (((unsupported)).apply ((xbase)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply ((((xTypeError)).apply (("Proxy model '%s' has no non-abstract model base class.".mod (xname))))))
                            bogusForceDataize.write (((((xnew_class).x_meta).xsetup_proxy)).apply ((xbase)))
                            (((unsupported)).apply ((((xnew_class).x_meta).xconcrete_model)) ((((xbase).x_meta).xconcrete_model)))
                          (((unsupported)).apply ((((xnew_class).x_meta).xconcrete_model)) ((xnew_class)))
                        xparent_links.write (((unsupported)).apply)
                        (((unsupported)).apply ((xbase)) ((((xreversed)).apply (((((unsupported)).apply ((xnew_class))).sub (xparents))))))
                          seq
                            ((((xhasattr)).apply ((xbase)) ("_meta")).not).if
                              (((unsupported)).apply)
                            (((xbase).neq (xnew_class)).and ((((xbase).x_meta).xabstract).not)).if
                              (((unsupported)).apply)
                            (((unsupported)).apply ((xfield)) ((((xbase).x_meta).xlocal_fields)))
                              ((((xisinstance)).apply ((xfield)) ((xOneToOneField))).and (((xfield).xremote_field).xparent_link)).if
                                seq
                                  xrelated.write (((xresolve_relation)).apply ((xnew_class)) ((((xfield).xremote_field).xmodel)))
                                  (((unsupported)).apply ((((unsupported)).apply ((xparent_links)) ((((xmake_model_tuple)).apply ((xrelated)))))) ((xfield)))
                        xinherited_attributes.write (((xset)).apply)
                        (((unsupported)).apply ((xbase)) (((((xnew_class).xmro)).apply)))
                          seq
                            ((((unsupported)).apply ((xbase)) ((xparents))).or ((((xhasattr)).apply ((xbase)) ("_meta")).not)).if
                              seq
                                bogusForceDataize.write ((((xinherited_attributes).xupdate)).apply (((xbase).x__dict__)))
                                (((unsupported)).apply)
                            xparent_fields.write ((((xbase).x_meta).xlocal_fields).sub (((xbase).x_meta).xlocal_many_to_many))
                            ((((xbase).x_meta).xabstract).not).if
                              seq
                                (((unsupported)).apply ((xfield)) ((xparent_fields)))
                                  (((unsupported)).apply (((xfield).xname)) ((xfield_names))).if
                                    (((unsupported)).apply ((((xFieldError)).apply (("Local field %r in class %r clashes with field of the same name from base class %r.".mod (((unsupported)).apply (((xfield).xname)) ((xname)) (((xbase).x__name__))))))))
                                    bogusForceDataize.write ((((xinherited_attributes).xadd)).apply (((xfield).xname)))
                                xbase.write (((xbase).x_meta).xconcrete_model)
                                xbase_key.write (((xmake_model_tuple)).apply ((xbase)))
                                (((unsupported)).apply ((xbase_key)) ((xparent_links))).if
                                  xfield.write (((unsupported)).apply ((xparent_links)) ((xbase_key)))
                                  ((xis_proxy).not).if
                                    seq
                                      xattr_name.write ("%s_ptr".mod (((xbase).x_meta).xmodel_name))
                                      xfield.write (((unsupported)).apply ((xOneToOneField)) ((xbase)) ((xCASCADE)) ((xattr_name)) (TRUE) (TRUE))
                                      (((unsupported)).apply ((xattr_name)) ((xfield_names))).if
                                        (((unsupported)).apply ((((xFieldError)).apply (("Auto-generated field '%s' in class %r for parent_link to base class %r clashes with declared field of the same name.".mod (((unsupported)).apply ((xattr_name)) ((xname)) (((xbase).x__name__))))))))
                                      ((((xhasattr)).apply ((xnew_class)) ((xattr_name))).not).if
                                        bogusForceDataize.write ((((xnew_class).xadd_to_class)).apply ((xattr_name)) ((xfield)))
                                    xfield.write "None: is there a None literal in the EO language?"
                                (((unsupported)).apply ((((unsupported)).apply ((((xnew_class).x_meta).xparents)) ((xbase)))) ((xfield)))
                              seq
                                xbase_parents.write ((((((xbase).x_meta).xparents).xcopy)).apply)
                                (((unsupported)).apply ((xfield)) ((xparent_fields)))
                                  (((((unsupported)).apply (((xfield).xname)) ((xfield_names))).and (((unsupported)).apply (((xfield).xname)) (((xnew_class).x__dict__)))).and (((unsupported)).apply (((xfield).xname)) ((xinherited_attributes)))).if
                                    seq
                                      xnew_field.write ((((xcopy).xdeepcopy)).apply ((xfield)))
                                      bogusForceDataize.write ((((xnew_class).xadd_to_class)).apply (((xfield).xname)) ((xnew_field)))
                                      ((xfield).xone_to_one).if
                                        (((unsupported)).apply ((((unsupported)).apply ((xparent)) ((xparent_link)))) (((((xbase_parents).xitems)).apply)))
                                          ((xfield).eq (xparent_link)).if
                                            (((unsupported)).apply ((((unsupported)).apply ((xbase_parents)) ((xparent)))) ((xnew_field)))
                                bogusForceDataize.write ((((((xnew_class).x_meta).xparents).xupdate)).apply ((xbase_parents)))
                            (((unsupported)).apply ((xfield)) ((((xbase).x_meta).xprivate_fields)))
                              (((unsupported)).apply (((xfield).xname)) ((xfield_names))).if
                                ((((xbase).x_meta).xabstract).not).if
                                  (((unsupported)).apply ((((xFieldError)).apply (("Local field %r in class %r clashes with field of the same name from base class %r.".mod (((unsupported)).apply (((xfield).xname)) ((xname)) (((xbase).x__name__))))))))
                                seq
                                  xfield.write ((((xcopy).xdeepcopy)).apply ((xfield)))
                                  ((((xbase).x_meta).xabstract).not).if
                                    (((unsupported)).apply (((xfield).xmti_inherited)) (TRUE))
                                  bogusForceDataize.write ((((xnew_class).xadd_to_class)).apply (((xfield).xname)) ((xfield)))
                        (((unsupported)).apply ((((xnew_class).x_meta).xindexes)) ((((unsupported)).apply (((((xcopy).xdeepcopy)).apply ((xidx)))) ((xidx)) ((((xnew_class).x_meta).xindexes)))))
                        (xabstract).if
                          seq
                            (((unsupported)).apply (((xattr_meta).xabstract)) (FALSE))
                            (((unsupported)).apply (((xnew_class).xMeta)) ((xattr_meta)))
                            (((unsupported)).apply ((xnew_class)))
                        bogusForceDataize.write ((((xnew_class).x_prepare)).apply)
                        bogusForceDataize.write ((((((xnew_class).x_meta).xapps).xregister_model)).apply ((((xnew_class).x_meta).xapp_label)) ((xnew_class)))
                        (((unsupported)).apply ((xnew_class)))
                xadd_to_class.write
                  [xcls xname xvalue]
                    seq > @
                      (((x_has_contribute_to_class)).apply ((xvalue))).if
                        bogusForceDataize.write ((((xvalue).xcontribute_to_class)).apply ((xcls)) ((xname)))
                        bogusForceDataize.write (((xsetattr)).apply ((xcls)) ((xname)) ((xvalue)))
                x_prepare.write
                  [xcls]
                    memory > xremote
                    memory > xmanager
                    memory > xopts
                    memory > xget_absolute_url_override
                    memory > xwrt
                    seq > @
                      seq
                        unsupported
                        xopts.write ((xcls).x_meta)
                        bogusForceDataize.write ((((xopts).x_prepare)).apply ((xcls)))
                        ((xopts).xorder_with_respect_to).if
                          seq
                            (((unsupported)).apply (((xcls).xget_next_in_order)) ((((unsupported)).apply ((xpartialmethod)) (((xcls).x_get_next_or_previous_in_order)) (TRUE))))
                            (((unsupported)).apply (((xcls).xget_previous_in_order)) ((((unsupported)).apply ((xpartialmethod)) (((xcls).x_get_next_or_previous_in_order)) (FALSE))))
                            (((xopts).xorder_with_respect_to).xremote_field).if
                              seq
                                xwrt.write ((xopts).xorder_with_respect_to)
                                xremote.write (((xwrt).xremote_field).xmodel)
                                bogusForceDataize.write (((xlazy_related_operation)).apply ((xmake_foreign_order_accessors)) ((xcls)) ((xremote)))
                        (((unsupported)).apply (((xcls).x__doc__)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xcls).x__doc__)) (("%s(%s)".mod (((unsupported)).apply (((xcls).x__name__)) ((((", ".xjoin)).apply ((((unsupported)).apply (((xf).xname)) ((xf)) (((xopts).xfields))))))))))
                        xget_absolute_url_override.write (((((xsettings).xABSOLUTE_URL_OVERRIDES).xget)).apply (((xopts).xlabel_lower)))
                        (xget_absolute_url_override).if
                          bogusForceDataize.write (((xsetattr)).apply ((xcls)) ("get_absolute_url") ((xget_absolute_url_override)))
                        (((xopts).xmanagers).not).if
                          seq
                            (((xany)).apply ((((unsupported)).apply ((((xf).xname).eq "objects")) ((xf)) (((xopts).xfields))))).if
                              (((unsupported)).apply ((((xValueError)).apply (("Model %s must specify a custom Manager, because it has a field named 'objects'.".mod ((xcls).x__name__))))))
                            xmanager.write (((xManager)).apply)
                            (((unsupported)).apply (((xmanager).xauto_created)) (TRUE))
                            bogusForceDataize.write ((((xcls).xadd_to_class)).apply ("objects") ((xmanager)))
                        (((unsupported)).apply ((xindex)) ((((xcls).x_meta).xindexes)))
                          (((xindex).xname).not).if
                            bogusForceDataize.write ((((xindex).xset_name_with_model)).apply ((xcls)))
                        (((unsupported)).apply (((xclass_prepared).xsend)) ((xcls)))
                x_base_manager.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xcls).x_meta).xbase_manager)))
                x_default_manager.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xcls).x_meta).xdefault_manager)))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                x__set_name__.write
                  [xself xowner xname]
                    seq > @
                      (((unsupported)).apply (((xself).xattribute_name)) ((xname)))
                x__get__.write
                  [xself xinstance xcls]
                    memory > xres
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xinstance)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xself)))
                        (((unsupported)).apply ((xres)) ((((unsupported)).apply (((xinstance).x__dict__)) (((xself).xattribute_name)))) ((((unsupported)).apply)))
                        (((unsupported)).apply ((xres)))
            (((unsupported)).apply)
              seq
                unsupported
                xdb.write "None: is there a None literal in the EO language?"
                xadding.write TRUE
                xfields_cache.write (((xModelStateCacheDescriptor)).apply)
                xrelated_managers_cache.write (((xModelStateCacheDescriptor)).apply)
                x__getstate__.write
                  [xself]
                    memory > xstate
                    seq > @
                      seq
                        xstate.write (((((xself).x__dict__).xcopy)).apply)
                        (((unsupported)).apply ("fields_cache") ((xstate))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xstate)) ("fields_cache"))) ((((((xself).xfields_cache).xcopy)).apply)))
                        (((unsupported)).apply ("related_managers_cache") ((xstate))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xstate)) ("related_managers_cache"))) ((((unsupported)).apply)))
                        (((unsupported)).apply ((xstate)))
            (((unsupported)).apply ((xModelBase)))
              seq
                x__init__.write
                  [xself]
                    memory > x_DEFERRED
                    memory > xfields_iter
                    memory > xopts
                    memory > xunexpected_names
                    memory > xunexpected
                    memory > xcls
                    memory > x_setattr
                    memory > xval
                    memory > xis_related_object
                    memory > xproperty_names
                    memory > xrel_obj
                    seq > @
                      (((unsupported)).apply)
                        xcls.write ((xself).x__class__)
                        xopts.write ((xself).x_meta)
                        x_setattr.write (xsetattr)
                        x_DEFERRED.write (xDEFERRED)
                        ((xopts).xabstract).if
                          (((unsupported)).apply ((((xTypeError)).apply ("Abstract models cannot be instantiated."))))
                        (((unsupported)).apply (((xpre_init).xsend)) ((xcls)) ((xargs)) ((xkwargs)))
                        (((unsupported)).apply (((xself).x_state)) ((((xModelState)).apply)))
                        ((((xlen)).apply ((xargs))).greater (((xlen)).apply (((xopts).xconcrete_fields)))).if
                          (((unsupported)).apply ((((xIndexError)).apply ("Number of args exceeds number of fields"))))
                        ((xkwargs).not).if
                          seq
                            xfields_iter.write (((xiter)).apply (((xopts).xconcrete_fields)))
                            (((unsupported)).apply ((((unsupported)).apply ((xval)) ((xfield)))) ((((xzip)).apply ((xargs)) ((xfields_iter)))))
                              seq
                                (((unsupported)).apply ((xval)) ((x_DEFERRED))).if
                                  (((unsupported)).apply)
                                bogusForceDataize.write (((x_setattr)).apply ((xself)) (((xfield).xattname)) ((xval)))
                          seq
                            xfields_iter.write (((xiter)).apply (((xopts).xfields)))
                            (((unsupported)).apply ((((unsupported)).apply ((xval)) ((xfield)))) ((((xzip)).apply ((xargs)) ((xfields_iter)))))
                              seq
                                (((unsupported)).apply ((xval)) ((x_DEFERRED))).if
                                  (((unsupported)).apply)
                                bogusForceDataize.write (((x_setattr)).apply ((xself)) (((xfield).xattname)) ((xval)))
                                (((unsupported)).apply (((((xkwargs).xpop)).apply (((xfield).xname)) ((xNOT_PROVIDED)))) ((xNOT_PROVIDED))).if
                                  (((unsupported)).apply ((((xTypeError)).apply ("{cls.__qualname__}() got both positional and keyword arguments for field '{field.name}'."))))
                        (((unsupported)).apply ((xfield)) ((xfields_iter)))
                          seq
                            xis_related_object.write FALSE
                            ((((unsupported)).apply (((xfield).xattname)) ((xkwargs))).and (((unsupported)).apply (((xfield).xcolumn)) ("None: is there a None literal in the EO language?"))).if
                              (((unsupported)).apply)
                            (xkwargs).if
                              (((xisinstance)).apply (((xfield).xremote_field)) ((xForeignObjectRel))).if
                                (((unsupported)).apply ((xKeyError)))
                                  seq
                                    xrel_obj.write ((((xkwargs).xpop)).apply (((xfield).xname)))
                                    xis_related_object.write TRUE
                                  (((unsupported)).apply ((xKeyError)))
                                    xval.write ((((xkwargs).xpop)).apply (((xfield).xattname)))
                                    xval.write ((((xfield).xget_default)).apply)
                                (((unsupported)).apply ((xKeyError)))
                                  xval.write ((((xkwargs).xpop)).apply (((xfield).xattname)))
                                  xval.write ((((xfield).xget_default)).apply)
                              xval.write ((((xfield).xget_default)).apply)
                            (xis_related_object).if
                              (((unsupported)).apply ((xrel_obj)) ((x_DEFERRED))).if
                                bogusForceDataize.write (((x_setattr)).apply ((xself)) (((xfield).xname)) ((xrel_obj)))
                              (((unsupported)).apply ((xval)) ((x_DEFERRED))).if
                                bogusForceDataize.write (((x_setattr)).apply ((xself)) (((xfield).xattname)) ((xval)))
                        (xkwargs).if
                          seq
                            xproperty_names.write ((xopts).x_property_names)
                            xunexpected.write (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xprop)) ((xvalue)))) (((((xkwargs).xitems)).apply)))
                              (((unsupported)).apply ((xprop)) ((xproperty_names))).if
                                (((unsupported)).apply ((xvalue)) ((x_DEFERRED))).if
                                  bogusForceDataize.write (((x_setattr)).apply ((xself)) ((xprop)) ((xvalue)))
                                (((unsupported)).apply ((xFieldDoesNotExist)))
                                  bogusForceDataize.write ((((xopts).xget_field)).apply ((xprop)))
                                  (((unsupported)).apply ((xunexpected)) ((((unsupported)).apply ((xprop)))))
                                  (((unsupported)).apply ((xvalue)) ((x_DEFERRED))).if
                                    bogusForceDataize.write (((x_setattr)).apply ((xself)) ((xprop)) ((xvalue)))
                            (xunexpected).if
                              seq
                                xunexpected_names.write (((", ".xjoin)).apply ((((unsupported)).apply ((((xrepr)).apply ((xn)))) ((xn)) ((xunexpected)))))
                                (((unsupported)).apply ((((xTypeError)).apply ("{cls.__name__}() got unexpected keyword arguments: {unexpected_names}"))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply)
                        (((unsupported)).apply (((xpost_init).xsend)) ((xcls)) ((xself)))
                xfrom_db.write
                  [xcls xdb xfield_names xvalues]
                    memory > xvalues_iter
                    memory > xnew
                    seq > @
                      (((unsupported)).apply)
                        ((((xlen)).apply ((xvalues))).neq (((xlen)).apply ((((xcls).x_meta).xconcrete_fields)))).if
                          seq
                            xvalues_iter.write (((xiter)).apply ((xvalues)))
                            xvalues.write (((unsupported)).apply (((((unsupported)).apply (((xf).xattname)) ((xfield_names))).if (((xnext)).apply ((xvalues_iter))) (xDEFERRED))) ((xf)) ((((xcls).x_meta).xconcrete_fields)))
                        xnew.write (((xcls)).apply ((((unsupported)).apply ((xvalues)))))
                        (((unsupported)).apply ((((xnew).x_state).xadding)) (FALSE))
                        (((unsupported)).apply ((((xnew).x_state).xdb)) ((xdb)))
                        (((unsupported)).apply ((xnew)))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<%s: %s>".mod (((unsupported)).apply ((((xself).x__class__).x__name__)) ((xself))))))
                x__str__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("%s object (%s)".mod (((unsupported)).apply ((((xself).x__class__).x__name__)) (((xself).xpk))))))
                x__eq__.write
                  [xself xother]
                    memory > xmy_pk
                    seq > @
                      seq
                        ((((xisinstance)).apply ((xother)) ((xModel))).not).if
                          (((unsupported)).apply ((xNotImplemented)))
                        ((((xself).x_meta).xconcrete_model).neq (((xother).x_meta).xconcrete_model)).if
                          (((unsupported)).apply (FALSE))
                        xmy_pk.write ((xself).xpk)
                        (((unsupported)).apply ((xmy_pk)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xself)) ((xother)))))
                        (((unsupported)).apply (((xmy_pk).eq ((xother).xpk))))
                x__hash__.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xpk)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xTypeError)).apply ("Model instances without primary key value are unhashable"))))
                        (((unsupported)).apply ((((xhash)).apply (((xself).xpk)))))
                x__reduce__.write
                  [xself]
                    memory > xclass_id
                    memory > xdata
                    seq > @
                      seq
                        xdata.write ((((xself).x__getstate__)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xdata)) ((xDJANGO_VERSION_PICKLE_KEY)))) (((xdjango).x__version__)))
                        xclass_id.write (((unsupported)).apply ((((xself).x_meta).xapp_label)) ((((xself).x_meta).xobject_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xmodel_unpickle)) ((((unsupported)).apply ((xclass_id)))) ((xdata)))))
                x__getstate__.write
                  [xself]
                    memory > xstate
                    memory > x_memoryview_attrs
                    seq > @
                      seq
                        unsupported
                        xstate.write (((((xself).x__dict__).xcopy)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xstate)) ("_state"))) (((((xcopy).xcopy)).apply ((((unsupported)).apply ((xstate)) ("_state"))))))
                        x_memoryview_attrs.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xattr)) ((xvalue)))) (((((xstate).xitems)).apply)))
                          (((xisinstance)).apply ((xvalue)) ((xmemoryview))).if
                            bogusForceDataize.write ((((x_memoryview_attrs).xappend)).apply ((((unsupported)).apply ((xattr)) ((((xbytes)).apply ((xvalue)))))))
                        (x_memoryview_attrs).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xstate)) ("_memoryview_attrs"))) ((x_memoryview_attrs)))
                            (((unsupported)).apply ((((unsupported)).apply ((xattr)) ((xvalue)))) ((x_memoryview_attrs)))
                              bogusForceDataize.write ((((xstate).xpop)).apply ((xattr)))
                        (((unsupported)).apply ((xstate)))
                x__setstate__.write
                  [xself xstate]
                    memory > xpickled_version
                    seq > @
                      seq
                        xpickled_version.write ((((xstate).xget)).apply ((xDJANGO_VERSION_PICKLE_KEY)))
                        (xpickled_version).if
                          ((xpickled_version).neq ((xdjango).x__version__)).if
                            (((unsupported)).apply (((xwarnings).xwarn)) (("Pickled model instance's Django version %s does not match the current version %s.".mod (((unsupported)).apply ((xpickled_version)) (((xdjango).x__version__))))) ((xRuntimeWarning)) (2))
                          (((unsupported)).apply (((xwarnings).xwarn)) ("Pickled model instance's Django version is not specified.") ((xRuntimeWarning)) (2))
                        (((unsupported)).apply ("_memoryview_attrs") ((xstate))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xattr)) ((xvalue)))) (((((xstate).xpop)).apply ("_memoryview_attrs"))))
                            (((unsupported)).apply ((((unsupported)).apply ((xstate)) ((xattr)))) ((((xmemoryview)).apply ((xvalue)))))
                        bogusForceDataize.write (((((xself).x__dict__).xupdate)).apply ((xstate)))
                x_get_pk_val.write
                  [xself xmeta]
                    seq > @
                      (((unsupported)).apply)
                        xmeta.write ((xmeta).or ((xself).x_meta))
                        (((unsupported)).apply ((((xgetattr)).apply ((xself)) ((((xmeta).xpk).xattname)))))
                x_set_pk_val.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xparent_link)) (((((((xself).x_meta).xparents).xvalues)).apply)))
                          ((xparent_link).and ((xparent_link).neq (((xself).x_meta).xpk))).if
                            bogusForceDataize.write (((xsetattr)).apply ((xself)) ((((xparent_link).xtarget_field).xattname)) ((xvalue)))
                        (((unsupported)).apply ((((xsetattr)).apply ((xself)) (((((xself).x_meta).xpk).xattname)) ((xvalue)))))
                xpk.write (((xproperty)).apply ((x_get_pk_val)) ((x_set_pk_val)))
                xget_deferred_fields.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xf).xattname)) ((xf)) ((((xself).x_meta).xconcrete_fields)) ((((unsupported)).apply (((xf).xattname)) (((xself).x__dict__)))))))
                xrefresh_from_db.write
                  [xself xusing xfields]
                    memory > xdb_instance
                    memory > xhints
                    memory > xdb_instance_qs
                    memory > xnon_loaded_fields
                    memory > xprefetched_objects_cache
                    memory > xdeferred_fields
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xfields)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).x_prefetched_objects_cache)) ((((unsupported)).apply)))
                          seq
                            xprefetched_objects_cache.write (((xgetattr)).apply ((xself)) ("_prefetched_objects_cache") ((((unsupported)).apply)))
                            (((unsupported)).apply ((xfield)) ((xfields)))
                              (((unsupported)).apply ((xfield)) ((xprefetched_objects_cache))).if
                                seq
                                  (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xprefetched_objects_cache)) ((xfield)))))))
                                  bogusForceDataize.write ((((xfields).xremove)).apply ((xfield)))
                            ((xfields).not).if
                              (((unsupported)).apply)
                            (((xany)).apply ((((unsupported)).apply ((((unsupported)).apply ((xLOOKUP_SEP)) ((xf)))) ((xf)) ((xfields))))).if
                              (((unsupported)).apply ((((xValueError)).apply (("Found \"%s\" in fields argument. Relations and transforms are not allowed in fields.".mod (xLOOKUP_SEP))))))
                        xhints.write (((unsupported)).apply ("instance") ((xself)))
                        xdb_instance_qs.write (((unsupported)).apply (((((unsupported)).apply (((((xself).x__class__).x_base_manager).xdb_manager)) ((xusing)) ((xhints))).xfilter)) (((xself).xpk)))
                        xdeferred_fields.write ((((xself).xget_deferred_fields)).apply)
                        (((unsupported)).apply ((xfields)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xfields.write (((xlist)).apply ((xfields)))
                            xdb_instance_qs.write ((((xdb_instance_qs).xonly)).apply ((((unsupported)).apply ((xfields)))))
                          (xdeferred_fields).if
                            seq
                              xfields.write (((unsupported)).apply (((xf).xattname)) ((xf)) ((((xself).x_meta).xconcrete_fields)) ((((unsupported)).apply (((xf).xattname)) ((xdeferred_fields)))))
                              xdb_instance_qs.write ((((xdb_instance_qs).xonly)).apply ((((unsupported)).apply ((xfields)))))
                        xdb_instance.write ((((xdb_instance_qs).xget)).apply)
                        xnon_loaded_fields.write ((((xdb_instance).xget_deferred_fields)).apply)
                        (((unsupported)).apply ((xfield)) ((((xself).x_meta).xconcrete_fields)))
                          seq
                            (((unsupported)).apply (((xfield).xattname)) ((xnon_loaded_fields))).if
                              (((unsupported)).apply)
                            bogusForceDataize.write (((xsetattr)).apply ((xself)) (((xfield).xattname)) ((((xgetattr)).apply ((xdb_instance)) (((xfield).xattname)))))
                            (((xfield).xis_relation).and ((((xfield).xis_cached)).apply ((xself)))).if
                              bogusForceDataize.write ((((xfield).xdelete_cached_value)).apply ((xself)))
                        (((unsupported)).apply ((xfield)) ((((xself).x_meta).xrelated_objects)))
                          ((((xfield).xis_cached)).apply ((xself))).if
                            bogusForceDataize.write ((((xfield).xdelete_cached_value)).apply ((xself)))
                        (((unsupported)).apply ((((xself).x_state).xdb)) ((((xdb_instance).x_state).xdb)))
                xserializable_value.write
                  [xself xfield_name]
                    memory > xfield
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write (((((xself).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((xgetattr)).apply ((xself)) ((xfield_name)))))
                        (((unsupported)).apply ((((xgetattr)).apply ((xself)) (((xfield).xattname)))))
                xsave.write
                  [xself xforce_insert xforce_update xusing xupdate_fields]
                    memory > xnon_model_fields
                    memory > xloaded_fields
                    memory > xdeferred_fields
                    memory > xfield_names
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_prepare_related_fields_for_save)) ("save"))
                        xusing.write ((xusing).or (((unsupported)).apply (((xrouter).xdb_for_write)) (((xself).x__class__)) ((xself))))
                        ((xforce_insert).and ((xforce_update).or (xupdate_fields))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Cannot force both insert and updating in model saving."))))
                        xdeferred_fields.write ((((xself).xget_deferred_fields)).apply)
                        (((unsupported)).apply ((xupdate_fields)) ("None: is there a None literal in the EO language?")).if
                          seq
                            ((xupdate_fields).not).if
                              (((unsupported)).apply)
                            xupdate_fields.write (((xfrozenset)).apply ((xupdate_fields)))
                            xfield_names.write (((xset)).apply)
                            (((unsupported)).apply ((xfield)) ((((xself).x_meta).xconcrete_fields)))
                              (((xfield).xprimary_key).not).if
                                seq
                                  bogusForceDataize.write ((((xfield_names).xadd)).apply (((xfield).xname)))
                                  (((xfield).xname).neq ((xfield).xattname)).if
                                    bogusForceDataize.write ((((xfield_names).xadd)).apply (((xfield).xattname)))
                            xnon_model_fields.write ((((xupdate_fields).xdifference)).apply ((xfield_names)))
                            (xnon_model_fields).if
                              (((unsupported)).apply ((((xValueError)).apply (("The following fields do not exist in this model, are m2m fields, or are non-concrete fields: %s".mod (((", ".xjoin)).apply ((xnon_model_fields))))))))
                          ((((xforce_insert).not).and (xdeferred_fields)).and ((xusing).eq (((xself).x_state).xdb))).if
                            seq
                              xfield_names.write (((xset)).apply)
                              (((unsupported)).apply ((xfield)) ((((xself).x_meta).xconcrete_fields)))
                                ((((xfield).xprimary_key).not).and ((((xhasattr)).apply ((xfield)) ("through")).not)).if
                                  bogusForceDataize.write ((((xfield_names).xadd)).apply (((xfield).xattname)))
                              xloaded_fields.write ((((xfield_names).xdifference)).apply ((xdeferred_fields)))
                              (xloaded_fields).if
                                xupdate_fields.write (((xfrozenset)).apply ((xloaded_fields)))
                        (((unsupported)).apply (((xself).xsave_base)) ((xusing)) ((xforce_insert)) ((xforce_update)) ((xupdate_fields)))
                (((unsupported)).apply (((xsave).xalters_data)) (TRUE))
                xsave_base.write
                  [xself xraw xforce_insert xforce_update xusing xupdate_fields]
                    memory > xmeta
                    memory > xorigin
                    memory > xcls
                    memory > xparent_inserted
                    memory > xcontext_manager
                    memory > xupdated
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xusing.write ((xusing).or (((unsupported)).apply (((xrouter).xdb_for_write)) (((xself).x__class__)) ((xself))))
                        (((unsupported)).apply ((((xforce_insert).and ((xforce_update).or (xupdate_fields))).not)))
                        (((unsupported)).apply (((((unsupported)).apply ((xupdate_fields)) ("None: is there a None literal in the EO language?")).or (xupdate_fields))))
                        (((unsupported)).apply ((xcls)) ((xorigin)) (((xself).x__class__)))
                        (((xcls).x_meta).xproxy).if
                          xcls.write (((xcls).x_meta).xconcrete_model)
                        xmeta.write ((xcls).x_meta)
                        (((xmeta).xauto_created).not).if
                          (((unsupported)).apply (((xpre_save).xsend)) ((xorigin)) ((xself)) ((xraw)) ((xusing)) ((xupdate_fields)))
                        ((xmeta).xparents).if
                          xcontext_manager.write (((unsupported)).apply (((xtransaction).xatomic)) ((xusing)) (FALSE))
                          xcontext_manager.write (((unsupported)).apply (((xtransaction).xmark_for_rollback_on_error)) ((xusing)))
                        (((unsupported)).apply ((xcontext_manager)))
                          seq
                            xparent_inserted.write FALSE
                            ((xraw).not).if
                              xparent_inserted.write ((((xself).x_save_parents)).apply ((xcls)) ((xusing)) ((xupdate_fields)))
                            xupdated.write ((((xself).x_save_table)).apply ((xraw)) ((xcls)) (((xforce_insert).or (xparent_inserted))) ((xforce_update)) ((xusing)) ((xupdate_fields)))
                        (((unsupported)).apply ((((xself).x_state).xdb)) ((xusing)))
                        (((unsupported)).apply ((((xself).x_state).xadding)) (FALSE))
                        (((xmeta).xauto_created).not).if
                          (((unsupported)).apply (((xpost_save).xsend)) ((xorigin)) ((xself)) (((xupdated).not)) ((xupdate_fields)) ((xraw)) ((xusing)))
                (((unsupported)).apply (((xsave_base).xalters_data)) (TRUE))
                x_save_parents.write
                  [xself xcls xusing xupdate_fields]
                    memory > xupdated
                    memory > xparent_inserted
                    memory > xinserted
                    memory > xmeta
                    seq > @
                      seq
                        unsupported
                        xmeta.write ((xcls).x_meta)
                        xinserted.write FALSE
                        (((unsupported)).apply ((((unsupported)).apply ((xparent)) ((xfield)))) ((((((xmeta).xparents).xitems)).apply)))
                          seq
                            (((xfield).and (((unsupported)).apply ((((xgetattr)).apply ((xself)) (((((xparent).x_meta).xpk).xattname)))) ("None: is there a None literal in the EO language?"))).and (((unsupported)).apply ((((xgetattr)).apply ((xself)) (((xfield).xattname)))) ("None: is there a None literal in the EO language?"))).if
                              bogusForceDataize.write (((xsetattr)).apply ((xself)) (((((xparent).x_meta).xpk).xattname)) ((((xgetattr)).apply ((xself)) (((xfield).xattname)))))
                            xparent_inserted.write (((unsupported)).apply (((xself).x_save_parents)) ((xparent)) ((xusing)) ((xupdate_fields)))
                            xupdated.write (((unsupported)).apply (((xself).x_save_table)) ((xparent)) ((xusing)) ((xupdate_fields)) ((xparent_inserted)))
                            ((xupdated).not).if
                              xinserted.write TRUE
                            (xfield).if
                              seq
                                bogusForceDataize.write (((xsetattr)).apply ((xself)) (((xfield).xattname)) (((((xself).x_get_pk_val)).apply (((xparent).x_meta)))))
                                ((((xfield).xis_cached)).apply ((xself))).if
                                  bogusForceDataize.write ((((xfield).xdelete_cached_value)).apply ((xself)))
                        (((unsupported)).apply ((xinserted)))
                x_save_table.write
                  [xself xraw xcls xforce_insert xforce_update xusing xupdate_fields]
                    memory > xfield
                    memory > xfields
                    memory > xbase_qs
                    memory > xpk_val
                    memory > xreturning_fields
                    memory > xpk_set
                    memory > xfilter_args
                    memory > xupdated
                    memory > xnon_pks
                    memory > xmeta
                    memory > xvalues
                    memory > xforced_update
                    memory > xresults
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xmeta.write ((xcls).x_meta)
                        xnon_pks.write (((unsupported)).apply ((xf)) ((xf)) (((xmeta).xlocal_concrete_fields)) ((((xf).xprimary_key).not)))
                        (xupdate_fields).if
                          xnon_pks.write (((unsupported)).apply ((xf)) ((xf)) ((xnon_pks)) (((((unsupported)).apply (((xf).xname)) ((xupdate_fields))).or (((unsupported)).apply (((xf).xattname)) ((xupdate_fields))))))
                        xpk_val.write ((((xself).x_get_pk_val)).apply ((xmeta)))
                        (((unsupported)).apply ((xpk_val)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xpk_val.write (((((xmeta).xpk).xget_pk_value_on_save)).apply ((xself)))
                            bogusForceDataize.write (((xsetattr)).apply ((xself)) ((((xmeta).xpk).xattname)) ((xpk_val)))
                        xpk_set.write (((unsupported)).apply ((xpk_val)) ("None: is there a None literal in the EO language?"))
                        (((xpk_set).not).and ((xforce_update).or (xupdate_fields))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Cannot force an update in save() with no primary key."))))
                        xupdated.write FALSE
                        ((((((xraw).not).and ((xforce_insert).not)).and (((xself).x_state).xadding)).and (((xmeta).xpk).xdefault)).and (((unsupported)).apply ((((xmeta).xpk).xdefault)) ((xNOT_PROVIDED)))).if
                          xforce_insert.write TRUE
                        ((xpk_set).and ((xforce_insert).not)).if
                          seq
                            xbase_qs.write (((((xcls).x_base_manager).xusing)).apply ((xusing)))
                            xvalues.write (((unsupported)).apply ((((unsupported)).apply ((xf)) ("None: is there a None literal in the EO language?") (((xraw).if (((xgetattr)).apply ((xself)) (((xf).xattname))) ((((xf).xpre_save)).apply ((xself)) (FALSE)))))) ((xf)) ((xnon_pks)))
                            xforced_update.write ((xupdate_fields).or (xforce_update))
                            xupdated.write ((((xself).x_do_update)).apply ((xbase_qs)) ((xusing)) ((xpk_val)) ((xvalues)) ((xupdate_fields)) ((xforced_update)))
                            ((xforce_update).and ((xupdated).not)).if
                              (((unsupported)).apply ((((xDatabaseError)).apply ("Forced update did not affect any rows."))))
                            ((xupdate_fields).and ((xupdated).not)).if
                              (((unsupported)).apply ((((xDatabaseError)).apply ("Save with update_fields did not affect any rows."))))
                        ((xupdated).not).if
                          seq
                            ((xmeta).xorder_with_respect_to).if
                              seq
                                xfield.write ((xmeta).xorder_with_respect_to)
                                xfilter_args.write ((((xfield).xget_filter_kwargs_for_object)).apply ((xself)))
                                (((unsupported)).apply (((xself).x_order)) ((((unsupported)).apply ((((unsupported)).apply ((((((((((xcls).x_base_manager).xusing)).apply ((xusing))).xfilter)).apply ((((unsupported)).apply ((xfilter_args))))).xaggregate)) ((((xCoalesce)).apply ((((unsupported)).apply ((xExpressionWrapper)) (((((xMax)).apply ("_order")).sub (((xValue)).apply (1)))) ((((xIntegerField)).apply)))) ((((xValue)).apply (0))))))) ("_order__max"))))
                            xfields.write ((xmeta).xlocal_concrete_fields)
                            ((xpk_set).not).if
                              xfields.write (((unsupported)).apply ((xf)) ((xf)) ((xfields)) ((((unsupported)).apply ((xf)) (((xmeta).xauto_field)))))
                            xreturning_fields.write ((xmeta).xdb_returning_fields)
                            xresults.write ((((xself).x_do_insert)).apply (((xcls).x_base_manager)) ((xusing)) ((xfields)) ((xreturning_fields)) ((xraw)))
                            (xresults).if
                              (((unsupported)).apply ((((unsupported)).apply ((xvalue)) ((xfield)))) ((((xzip)).apply ((((unsupported)).apply ((xresults)) (0))) ((xreturning_fields)))))
                                bogusForceDataize.write (((xsetattr)).apply ((xself)) (((xfield).xattname)) ((xvalue)))
                        (((unsupported)).apply ((xupdated)))
                x_do_update.write
                  [xself xbase_qs xusing xpk_val xvalues xupdate_fields xforced_update]
                    memory > xfiltered
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xfiltered.write (((unsupported)).apply (((xbase_qs).xfilter)) ((xpk_val)))
                        ((xvalues).not).if
                          (((unsupported)).apply (((((unsupported)).apply ((xupdate_fields)) ("None: is there a None literal in the EO language?")).or ((((xfiltered).xexists)).apply))))
                        ((((xself).x_meta).xselect_on_save).and ((xforced_update).not)).if
                          (((unsupported)).apply ((((((xfiltered).xexists)).apply).and ((((((xfiltered).x_update)).apply ((xvalues))).greater 0).or ((((xfiltered).xexists)).apply)))))
                        (((unsupported)).apply ((((((xfiltered).x_update)).apply ((xvalues))).greater 0)))
                x_do_insert.write
                  [xself xmanager xusing xfields xreturning_fields xraw]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xmanager).x_insert)) ((((unsupported)).apply ((xself)))) ((xfields)) ((xreturning_fields)) ((xusing)) ((xraw)))))
                x_prepare_related_fields_for_save.write
                  [xself xoperation_name xfields]
                    memory > xobj
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xfield)) ((((xself).x_meta).xconcrete_fields)))
                          seq
                            ((xfields).and (((unsupported)).apply ((xfield)) ((xfields)))).if
                              (((unsupported)).apply)
                            (((xfield).xis_relation).and ((((xfield).xis_cached)).apply ((xself)))).if
                              seq
                                xobj.write (((xgetattr)).apply ((xself)) (((xfield).xname)) ("None: is there a None literal in the EO language?"))
                                ((xobj).not).if
                                  (((unsupported)).apply)
                                (((unsupported)).apply (((xobj).xpk)) ("None: is there a None literal in the EO language?")).if
                                  seq
                                    ((((xfield).xremote_field).xmultiple).not).if
                                      bogusForceDataize.write (((((xfield).xremote_field).xdelete_cached_value)).apply ((xobj)))
                                    (((unsupported)).apply ((((xValueError)).apply (("%s() prohibited to prevent data loss due to unsaved related object '%s'.".mod (((unsupported)).apply ((xoperation_name)) (((xfield).xname))))))))
                                  (((unsupported)).apply ((((xgetattr)).apply ((xself)) (((xfield).xattname)))) (((xfield).xempty_values))).if
                                    bogusForceDataize.write (((xsetattr)).apply ((xself)) (((xfield).xattname)) (((xobj).xpk)))
                                ((((xgetattr)).apply ((xobj)) ((((xfield).xtarget_field).xattname))).neq (((xgetattr)).apply ((xself)) (((xfield).xattname)))).if
                                  bogusForceDataize.write ((((xfield).xdelete_cached_value)).apply ((xself)))
                xdelete.write
                  [xself xusing xkeep_parents]
                    memory > xcollector
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xpk)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xValueError)).apply (("%s object can't be deleted because its %s attribute is set to None.".mod (((unsupported)).apply ((((xself).x_meta).xobject_name)) (((((xself).x_meta).xpk).xattname))))))))
                        xusing.write ((xusing).or (((unsupported)).apply (((xrouter).xdb_for_write)) (((xself).x__class__)) ((xself))))
                        xcollector.write (((unsupported)).apply ((xCollector)) ((xusing)) ((xself)))
                        (((unsupported)).apply (((xcollector).xcollect)) ((((unsupported)).apply ((xself)))) ((xkeep_parents)))
                        (((unsupported)).apply (((((xcollector).xdelete)).apply)))
                (((unsupported)).apply (((xdelete).xalters_data)) (TRUE))
                x_get_FIELD_display.write
                  [xself xfield]
                    memory > xvalue
                    memory > xchoices_dict
                    seq > @
                      seq
                        xvalue.write (((xgetattr)).apply ((xself)) (((xfield).xattname)))
                        xchoices_dict.write (((xdict)).apply ((((xmake_hashable)).apply (((xfield).xflatchoices)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xforce_str)) (((((xchoices_dict).xget)).apply ((((xmake_hashable)).apply ((xvalue)))) ((xvalue)))) (TRUE))))
                x_get_next_or_previous_by_FIELD.write
                  [xself xfield xis_next]
                    memory > xqs
                    memory > xq
                    memory > xparam
                    memory > xorder
                    memory > xop
                    seq > @
                      (((unsupported)).apply)
                        (((xself).xpk).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("get_next/get_previous cannot be used on unsaved objects."))))
                        xop.write ((xis_next).if "gt" "lt")
                        xorder.write ((xis_next).if "" "-")
                        xparam.write (((xgetattr)).apply ((xself)) (((xfield).xattname)))
                        xq.write (((unsupported)).apply ((xQ)) ((((unsupported)).apply (((xfield).xname)) ((xparam)))) ((((unsupported)).apply ("pk__{op}") (((xself).xpk)))) (((xQ).xAND)))
                        xq.write (((unsupported)).apply ((xQ)) ((xq)) ((((unsupported)).apply ("{field.name}__{op}") ((xparam)))) (((xQ).xOR)))
                        xqs.write (((((((((((((((xself).x__class__).x_default_manager).xusing)).apply ((((xself).x_state).xdb))).xfilter)).apply ((((unsupported)).apply ((xkwargs))))).xfilter)).apply ((xq))).xorder_by)).apply (("%s%s".mod (((unsupported)).apply ((xorder)) (((xfield).xname))))) (("%spk".mod (xorder))))
                        (((unsupported)).apply ((xIndexError)))
                          (((unsupported)).apply ((((unsupported)).apply ((xqs)) (0))))
                          (((unsupported)).apply (((((xself).xDoesNotExist)).apply (("%s matching query does not exist.".mod ((((xself).x__class__).x_meta).xobject_name))))))
                x_get_next_or_previous_in_order.write
                  [xself xis_next]
                    memory > xorder_field
                    memory > xfilter_args
                    memory > xcachename
                    memory > xobj
                    memory > xorder
                    memory > xop
                    seq > @
                      seq
                        xcachename.write ("__%s_order_cache".mod (xis_next))
                        ((((xhasattr)).apply ((xself)) ((xcachename))).not).if
                          seq
                            xop.write ((xis_next).if "gt" "lt")
                            xorder.write ((xis_next).if "_order" "-_order")
                            xorder_field.write (((xself).x_meta).xorder_with_respect_to)
                            xfilter_args.write ((((xorder_field).xget_filter_kwargs_for_object)).apply ((xself)))
                            xobj.write ((((((unsupported)).apply (((((((((((((xself).x__class__).x_default_manager).xfilter)).apply ((((unsupported)).apply ((xfilter_args))))).xfilter)).apply ((((unsupported)).apply ((((unsupported)).apply (("_order__%s".mod (xop))) ((((((((((xself).x__class__).x_default_manager).xvalues)).apply ("_order")).xfilter)).apply ((((unsupported)).apply ((((unsupported)).apply (((((xself).x_meta).xpk).xname)) (((xself).xpk))))))))))))).xorder_by)).apply ((xorder)))) ((((unsupported)).apply (1)))).xget)).apply)
                            bogusForceDataize.write (((xsetattr)).apply ((xself)) ((xcachename)) ((xobj)))
                        (((unsupported)).apply ((((xgetattr)).apply ((xself)) ((xcachename)))))
                xprepare_database_save.write
                  [xself xfield]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xpk)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xValueError)).apply (("Unsaved model instance %r cannot be used in an ORM query.".mod (xself))))))
                        (((unsupported)).apply ((((xgetattr)).apply ((xself)) (((((((xfield).xremote_field).xget_related_field)).apply).xattname)))))
                xclean.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                xvalidate_unique.write
                  [xself xexclude]
                    memory > xerrors
                    memory > xdate_errors
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xunique_checks)) ((xdate_checks)))) ((((unsupported)).apply (((xself).x_get_unique_checks)) ((xexclude)))))
                        xerrors.write ((((xself).x_perform_unique_checks)).apply ((xunique_checks)))
                        xdate_errors.write ((((xself).x_perform_date_checks)).apply ((xdate_checks)))
                        (((unsupported)).apply ((((unsupported)).apply ((xk)) ((xv)))) (((((xdate_errors).xitems)).apply)))
                          bogusForceDataize.write (((((((xerrors).xsetdefault)).apply ((xk)) ((((unsupported)).apply))).xextend)).apply ((xv)))
                        (xerrors).if
                          (((unsupported)).apply ((((xValidationError)).apply ((xerrors)))))
                x_get_unique_checks.write
                  [xself xexclude]
                    memory > xconstraints
                    memory > xunique_checks
                    memory > xdate_checks
                    memory > xfields_with_class
                    memory > xunique_togethers
                    memory > xname
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xexclude)) ("None: is there a None literal in the EO language?")).if
                          xexclude.write (((xset)).apply)
                        xunique_checks.write (((unsupported)).apply)
                        xunique_togethers.write (((unsupported)).apply ((((unsupported)).apply (((xself).x__class__)) ((((xself).x_meta).xunique_together)))))
                        xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xself).x__class__)) ((((xself).x_meta).xtotal_unique_constraints)))))
                        (((unsupported)).apply ((xparent_class)) ((((((xself).x_meta).xget_parent_list)).apply)))
                          seq
                            (((xparent_class).x_meta).xunique_together).if
                              bogusForceDataize.write ((((xunique_togethers).xappend)).apply ((((unsupported)).apply ((xparent_class)) ((((xparent_class).x_meta).xunique_together)))))
                            (((xparent_class).x_meta).xtotal_unique_constraints).if
                              bogusForceDataize.write ((((xconstraints).xappend)).apply ((((unsupported)).apply ((xparent_class)) ((((xparent_class).x_meta).xtotal_unique_constraints)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xmodel_class)) ((xunique_together)))) ((xunique_togethers)))
                          (((unsupported)).apply ((xcheck)) ((xunique_together)))
                            ((((xany)).apply ((((unsupported)).apply ((((unsupported)).apply ((xname)) ((xexclude)))) ((xname)) ((xcheck))))).not).if
                              bogusForceDataize.write ((((xunique_checks).xappend)).apply ((((unsupported)).apply ((xmodel_class)) ((((xtuple)).apply ((xcheck)))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xmodel_class)) ((xmodel_constraints)))) ((xconstraints)))
                          (((unsupported)).apply ((xconstraint)) ((xmodel_constraints)))
                            ((((xany)).apply ((((unsupported)).apply ((((unsupported)).apply ((xname)) ((xexclude)))) ((xname)) (((xconstraint).xfields))))).not).if
                              bogusForceDataize.write ((((xunique_checks).xappend)).apply ((((unsupported)).apply ((xmodel_class)) (((xconstraint).xfields)))))
                        xdate_checks.write (((unsupported)).apply)
                        xfields_with_class.write (((unsupported)).apply ((((unsupported)).apply (((xself).x__class__)) ((((xself).x_meta).xlocal_fields)))))
                        (((unsupported)).apply ((xparent_class)) ((((((xself).x_meta).xget_parent_list)).apply)))
                          bogusForceDataize.write ((((xfields_with_class).xappend)).apply ((((unsupported)).apply ((xparent_class)) ((((xparent_class).x_meta).xlocal_fields)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xmodel_class)) ((xfields)))) ((xfields_with_class)))
                          (((unsupported)).apply ((xf)) ((xfields)))
                            seq
                              xname.write ((xf).xname)
                              (((unsupported)).apply ((xname)) ((xexclude))).if
                                (((unsupported)).apply)
                              ((xf).xunique).if
                                bogusForceDataize.write ((((xunique_checks).xappend)).apply ((((unsupported)).apply ((xmodel_class)) ((((unsupported)).apply ((xname)))))))
                              (((xf).xunique_for_date).and (((unsupported)).apply (((xf).xunique_for_date)) ((xexclude)))).if
                                bogusForceDataize.write ((((xdate_checks).xappend)).apply ((((unsupported)).apply ((xmodel_class)) ("date") ((xname)) (((xf).xunique_for_date)))))
                              (((xf).xunique_for_year).and (((unsupported)).apply (((xf).xunique_for_year)) ((xexclude)))).if
                                bogusForceDataize.write ((((xdate_checks).xappend)).apply ((((unsupported)).apply ((xmodel_class)) ("year") ((xname)) (((xf).xunique_for_year)))))
                              (((xf).xunique_for_month).and (((unsupported)).apply (((xf).xunique_for_month)) ((xexclude)))).if
                                bogusForceDataize.write ((((xdate_checks).xappend)).apply ((((unsupported)).apply ((xmodel_class)) ("month") ((xname)) (((xf).xunique_for_month)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xunique_checks)) ((xdate_checks)))))
                x_perform_unique_checks.write
                  [xself xunique_checks]
                    memory > xqs
                    memory > xlookup_value
                    memory > xerrors
                    memory > xmodel_class_pk
                    memory > xf
                    memory > xlookup_kwargs
                    memory > xkey
                    seq > @
                      seq
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xmodel_class)) ((xunique_check)))) ((xunique_checks)))
                          seq
                            xlookup_kwargs.write (((unsupported)).apply)
                            (((unsupported)).apply ((xfield_name)) ((xunique_check)))
                              seq
                                xf.write (((((xself).x_meta).xget_field)).apply ((xfield_name)))
                                xlookup_value.write (((xgetattr)).apply ((xself)) (((xf).xattname)))
                                ((((unsupported)).apply ((xlookup_value)) ("None: is there a None literal in the EO language?")).or (((xlookup_value).eq "").and (((xconnection).xfeatures).xinterprets_empty_strings_as_nulls))).if
                                  (((unsupported)).apply)
                                (((xf).xprimary_key).and ((((xself).x_state).xadding).not)).if
                                  (((unsupported)).apply)
                                (((unsupported)).apply ((((unsupported)).apply ((xlookup_kwargs)) ((((xstr)).apply ((xfield_name)))))) ((xlookup_value)))
                            ((((xlen)).apply ((xunique_check))).neq (((xlen)).apply ((xlookup_kwargs)))).if
                              (((unsupported)).apply)
                            xqs.write (((((xmodel_class).x_default_manager).xfilter)).apply ((((unsupported)).apply ((xlookup_kwargs)))))
                            xmodel_class_pk.write ((((xself).x_get_pk_val)).apply (((xmodel_class).x_meta)))
                            (((((xself).x_state).xadding).not).and (((unsupported)).apply ((xmodel_class_pk)) ("None: is there a None literal in the EO language?"))).if
                              xqs.write (((unsupported)).apply (((xqs).xexclude)) ((xmodel_class_pk)))
                            ((((xqs).xexists)).apply).if
                              seq
                                ((((xlen)).apply ((xunique_check))).eq 1).if
                                  xkey.write (((unsupported)).apply ((xunique_check)) (0))
                                  xkey.write (xNON_FIELD_ERRORS)
                                bogusForceDataize.write (((((((xerrors).xsetdefault)).apply ((xkey)) ((((unsupported)).apply))).xappend)).apply (((((xself).xunique_error_message)).apply ((xmodel_class)) ((xunique_check)))))
                        (((unsupported)).apply ((xerrors)))
                x_perform_date_checks.write
                  [xself xdate_checks]
                    memory > xqs
                    memory > xerrors
                    memory > xlookup_kwargs
                    memory > xdate
                    seq > @
                      seq
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xmodel_class)) ((xlookup_type)) ((xfield)) ((xunique_for)))) ((xdate_checks)))
                          seq
                            xlookup_kwargs.write (((unsupported)).apply)
                            xdate.write (((xgetattr)).apply ((xself)) ((xunique_for)))
                            (((unsupported)).apply ((xdate)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply)
                            ((xlookup_type).eq "date").if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xlookup_kwargs)) (("%s__day".mod (xunique_for))))) (((xdate).xday)))
                                (((unsupported)).apply ((((unsupported)).apply ((xlookup_kwargs)) (("%s__month".mod (xunique_for))))) (((xdate).xmonth)))
                                (((unsupported)).apply ((((unsupported)).apply ((xlookup_kwargs)) (("%s__year".mod (xunique_for))))) (((xdate).xyear)))
                              (((unsupported)).apply ((((unsupported)).apply ((xlookup_kwargs)) (("%s__%s".mod (((unsupported)).apply ((xunique_for)) ((xlookup_type))))))) ((((xgetattr)).apply ((xdate)) ((xlookup_type)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xlookup_kwargs)) ((xfield)))) ((((xgetattr)).apply ((xself)) ((xfield)))))
                            xqs.write (((((xmodel_class).x_default_manager).xfilter)).apply ((((unsupported)).apply ((xlookup_kwargs)))))
                            (((((xself).x_state).xadding).not).and (((unsupported)).apply (((xself).xpk)) ("None: is there a None literal in the EO language?"))).if
                              xqs.write (((unsupported)).apply (((xqs).xexclude)) (((xself).xpk)))
                            ((((xqs).xexists)).apply).if
                              bogusForceDataize.write (((((((xerrors).xsetdefault)).apply ((xfield)) ((((unsupported)).apply))).xappend)).apply (((((xself).xdate_error_message)).apply ((xlookup_type)) ((xfield)) ((xunique_for)))))
                        (((unsupported)).apply ((xerrors)))
                xdate_error_message.write
                  [xself xlookup_type xfield_name xunique_for]
                    memory > xfield
                    memory > xopts
                    seq > @
                      seq
                        xopts.write ((xself).x_meta)
                        xfield.write ((((xopts).xget_field)).apply ((xfield_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xValidationError)) ((((unsupported)).apply (((xfield).xerror_messages)) ("unique_for_date"))) ("unique_for_date") ((((unsupported)).apply ("model") ((xself)) ("model_name") ((((xcapfirst)).apply (((xopts).xverbose_name)))) ("lookup_type") ((xlookup_type)) ("field") ((xfield_name)) ("field_label") ((((xcapfirst)).apply (((xfield).xverbose_name)))) ("date_field") ((xunique_for)) ("date_field_label") ((((xcapfirst)).apply ((((((xopts).xget_field)).apply ((xunique_for))).xverbose_name)))))))))
                xunique_error_message.write
                  [xself xmodel_class xunique_check]
                    memory > xfield
                    memory > xopts
                    memory > xparams
                    memory > xfield_labels
                    seq > @
                      seq
                        xopts.write ((xmodel_class).x_meta)
                        xparams.write (((unsupported)).apply ("model") ((xself)) ("model_class") ((xmodel_class)) ("model_name") ((((xcapfirst)).apply (((xopts).xverbose_name)))) ("unique_check") ((xunique_check)))
                        ((((xlen)).apply ((xunique_check))).eq 1).if
                          seq
                            xfield.write ((((xopts).xget_field)).apply ((((unsupported)).apply ((xunique_check)) (0))))
                            (((unsupported)).apply ((((unsupported)).apply ((xparams)) ("field_label"))) ((((xcapfirst)).apply (((xfield).xverbose_name)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xValidationError)) ((((unsupported)).apply (((xfield).xerror_messages)) ("unique"))) ("unique") ((xparams)))))
                          seq
                            xfield_labels.write (((unsupported)).apply ((((xcapfirst)).apply ((((((xopts).xget_field)).apply ((xf))).xverbose_name)))) ((xf)) ((xunique_check)))
                            (((unsupported)).apply ((((unsupported)).apply ((xparams)) ("field_labels"))) ((((xget_text_list)).apply ((xfield_labels)) ((((x_)).apply ("and"))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xValidationError)) ((((x_)).apply ("%(model_name)s with this %(field_labels)s already exists."))) ("unique_together") ((xparams)))))
                xfull_clean.write
                  [xself xexclude xvalidate_unique]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xexclude)) ("None: is there a None literal in the EO language?")).if
                          xexclude.write (((xset)).apply)
                          xexclude.write (((xset)).apply ((xexclude)))
                        (((unsupported)).apply ((xValidationError)))
                          (((unsupported)).apply (((xself).xclean_fields)) ((xexclude)))
                          xerrors.write ((((xe).xupdate_error_dict)).apply ((xerrors)))
                        (((unsupported)).apply ((xValidationError)))
                          bogusForceDataize.write ((((xself).xclean)).apply)
                          xerrors.write ((((xe).xupdate_error_dict)).apply ((xerrors)))
                        (xvalidate_unique).if
                          seq
                            (((unsupported)).apply ((xname)) ((xerrors)))
                              (((xname).neq (xNON_FIELD_ERRORS)).and (((unsupported)).apply ((xname)) ((xexclude)))).if
                                bogusForceDataize.write ((((xexclude).xadd)).apply ((xname)))
                            (((unsupported)).apply ((xValidationError)))
                              (((unsupported)).apply (((xself).xvalidate_unique)) ((xexclude)))
                              xerrors.write ((((xe).xupdate_error_dict)).apply ((xerrors)))
                        (xerrors).if
                          (((unsupported)).apply ((((xValidationError)).apply ((xerrors)))))
                xclean_fields.write
                  [xself xexclude]
                    memory > xerrors
                    memory > xraw_value
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xexclude)) ("None: is there a None literal in the EO language?")).if
                          xexclude.write (((xset)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xf)) ((((xself).x_meta).xfields)))
                          seq
                            (((unsupported)).apply (((xf).xname)) ((xexclude))).if
                              (((unsupported)).apply)
                            xraw_value.write (((xgetattr)).apply ((xself)) (((xf).xattname)))
                            (((xf).xblank).and (((unsupported)).apply ((xraw_value)) (((xf).xempty_values)))).if
                              (((unsupported)).apply)
                            (((unsupported)).apply ((xValidationError)))
                              bogusForceDataize.write (((xsetattr)).apply ((xself)) (((xf).xattname)) (((((xf).xclean)).apply ((xraw_value)) ((xself)))))
                              (((unsupported)).apply ((((unsupported)).apply ((xerrors)) (((xf).xname)))) (((xe).xerror_list)))
                        (xerrors).if
                          (((unsupported)).apply ((((xValidationError)).apply ((xerrors)))))
                xcheck.write
                  [xcls]
                    memory > xclash_errors
                    memory > xerrors
                    memory > xdatabases
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply ((((unsupported)).apply (((((xcls).x_check_swappable)).apply)))) ((((unsupported)).apply (((((xcls).x_check_model)).apply)))) ((((unsupported)).apply (((((xcls).x_check_managers)).apply ((((unsupported)).apply ((xkwargs)))))))))
                        ((((xcls).x_meta).xswapped).not).if
                          seq
                            xdatabases.write (((((xkwargs).xget)).apply ("databases")).or (((unsupported)).apply))
                            (((unsupported)).apply ((xerrors)) ((((unsupported)).apply ((((unsupported)).apply (((((xcls).x_check_fields)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xcls).x_check_m2m_through_same_relationship)).apply)))) ((((unsupported)).apply (((((xcls).x_check_long_column_names)).apply ((xdatabases)))))))))
                            xclash_errors.write (((unsupported)).apply ((((unsupported)).apply (((((xcls).x_check_id_field)).apply)))) ((((unsupported)).apply (((((xcls).x_check_field_name_clashes)).apply)))) ((((unsupported)).apply (((((xcls).x_check_model_name_db_lookup_clashes)).apply)))) ((((unsupported)).apply (((((xcls).x_check_property_name_related_field_accessor_clashes)).apply)))) ((((unsupported)).apply (((((xcls).x_check_single_primary_key)).apply)))))
                            bogusForceDataize.write ((((xerrors).xextend)).apply ((xclash_errors)))
                            ((xclash_errors).not).if
                              bogusForceDataize.write ((((xerrors).xextend)).apply (((((xcls).x_check_column_name_clashes)).apply)))
                            (((unsupported)).apply ((xerrors)) ((((unsupported)).apply ((((unsupported)).apply (((((xcls).x_check_index_together)).apply)))) ((((unsupported)).apply (((((xcls).x_check_unique_together)).apply)))) ((((unsupported)).apply (((((xcls).x_check_indexes)).apply ((xdatabases)))))) ((((unsupported)).apply (((((xcls).x_check_ordering)).apply)))) ((((unsupported)).apply (((((xcls).x_check_constraints)).apply ((xdatabases)))))) ((((unsupported)).apply (((((xcls).x_check_default_pk)).apply)))))))
                        (((unsupported)).apply ((xerrors)))
                x_check_default_pk.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((((((((xcls).x_meta).xabstract).not).and ((((xcls).x_meta).xpk).xauto_created)).and (((((xisinstance)).apply ((((xcls).x_meta).xpk)) ((xOneToOneField))).and (((((xcls).x_meta).xpk).xremote_field).xparent_link)).not)).and (((((xsettings).xis_overridden)).apply ("DEFAULT_AUTO_FIELD")).not)).and (((xcls).x_meta).xapp_config)).and (((((xcls).x_meta).xapp_config).x_is_default_auto_field_overridden).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xWarning)) ("Auto-created primary key used when not defining a primary key type, by default '{settings.DEFAULT_AUTO_FIELD}'.") ("Configure the DEFAULT_AUTO_FIELD setting or the {cls._meta.app_config.__class__.__qualname__}.default_auto_field attribute to point to a subclass of AutoField, e.g. 'django.db.models.BigAutoField'.") ((xcls)) ("models.W042"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_swappable.write
                  [xcls]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xerrors.write (((unsupported)).apply)
                        (((xcls).x_meta).xswapped).if
                          (((unsupported)).apply ((xValueError)) ((xLookupError)))
                            bogusForceDataize.write ((((xapps).xget_model)).apply ((((xcls).x_meta).xswapped)))
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' is not of the form 'app_label.app_name'.".mod (((xcls).x_meta).xswappable))) ("models.E001"))))
                            seq
                              (((unsupported)).apply ((((unsupported)).apply ((xapp_label)) ((xmodel_name)))) (((((((xcls).x_meta).xswapped).xsplit)).apply ("."))))
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' references '%s.%s', which has not been installed, or is abstract.".mod (((unsupported)).apply ((((xcls).x_meta).xswappable)) ((xapp_label)) ((xmodel_name))))) ("models.E002"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_model.write
                  [xcls]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((xcls).x_meta).xproxy).if
                          ((((xcls).x_meta).xlocal_fields).or (((xcls).x_meta).xlocal_many_to_many)).if
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Proxy model '%s' contains model fields.".mod ((xcls).x__name__))) ("models.E017"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_managers.write
                  [xcls]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xmanager)) ((((xcls).x_meta).xmanagers)))
                          bogusForceDataize.write ((((xerrors).xextend)).apply (((((xmanager).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))
                        (((unsupported)).apply ((xerrors)))
                x_check_fields.write
                  [xcls]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xfield)) ((((xcls).x_meta).xlocal_fields)))
                          bogusForceDataize.write ((((xerrors).xextend)).apply (((((xfield).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))
                        (((unsupported)).apply ((xfield)) ((((xcls).x_meta).xlocal_many_to_many)))
                          bogusForceDataize.write ((((xerrors).xextend)).apply ((((unsupported)).apply (((xfield).xcheck)) ((xcls)) ((((unsupported)).apply ((xkwargs)))))))
                        (((unsupported)).apply ((xerrors)))
                x_check_m2m_through_same_relationship.write
                  [xcls]
                    memory > xerrors
                    memory > xsignature
                    memory > xseen_intermediary_signatures
                    memory > xfields
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xerrors.write (((unsupported)).apply)
                        xseen_intermediary_signatures.write (((unsupported)).apply)
                        xfields.write (((xcls).x_meta).xlocal_many_to_many)
                        xfields.write (((unsupported)).apply ((xf)) ((xf)) ((xfields)) ((((xisinstance)).apply ((((xf).xremote_field).xmodel)) ((xModelBase)))))
                        xfields.write (((unsupported)).apply ((xf)) ((xf)) ((xfields)) ((((xisinstance)).apply ((((xf).xremote_field).xthrough)) ((xModelBase)))))
                        (((unsupported)).apply ((xf)) ((xfields)))
                          seq
                            xsignature.write (((unsupported)).apply ((((xf).xremote_field).xmodel)) ((xcls)) ((((xf).xremote_field).xthrough)) ((((xf).xremote_field).xthrough_fields)))
                            (((unsupported)).apply ((xsignature)) ((xseen_intermediary_signatures))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The model has two identical many-to-many relations through the intermediate model '%s'.".mod (((((xf).xremote_field).xthrough).x_meta).xlabel))) ((xcls)) ("models.E003"))))
                              bogusForceDataize.write ((((xseen_intermediary_signatures).xappend)).apply ((xsignature)))
                        (((unsupported)).apply ((xerrors)))
                x_check_id_field.write
                  [xcls]
                    memory > xfields
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xfields.write (((unsupported)).apply ((xf)) ((xf)) ((((xcls).x_meta).xlocal_fields)) (((((xf).xname).eq "id").and ((xf).neq (((xcls).x_meta).xpk)))))
                        (((xfields).and (((((unsupported)).apply ((xfields)) (0)).xprimary_key).not)).and (((((xcls).x_meta).xpk).xname).eq "id")).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'id' can only be used as a field name if the field also sets 'primary_key=True'.") ((xcls)) ("models.E004"))))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_field_name_clashes.write
                  [xcls]
                    memory > xused_fields
                    memory > xerrors
                    memory > xid_conflict
                    memory > xclash
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xerrors.write (((unsupported)).apply)
                        xused_fields.write (((unsupported)).apply)
                        (((unsupported)).apply ((xparent)) ((((((xcls).x_meta).xget_parent_list)).apply)))
                          (((unsupported)).apply ((xf)) ((((xparent).x_meta).xlocal_fields)))
                            seq
                              xclash.write ((((((xused_fields).xget)).apply (((xf).xname))).or ((((xused_fields).xget)).apply (((xf).xattname)))).or "None: is there a None literal in the EO language?")
                              (xclash).if
                                bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The field '%s' from parent model '%s' clashes with the field '%s' from parent model '%s'.".mod (((unsupported)).apply (((xclash).xname)) ((((xclash).xmodel).x_meta)) (((xf).xname)) ((((xf).xmodel).x_meta))))) ((xcls)) ("models.E005"))))
                              (((unsupported)).apply ((((unsupported)).apply ((xused_fields)) (((xf).xname)))) ((xf)))
                              (((unsupported)).apply ((((unsupported)).apply ((xused_fields)) (((xf).xattname)))) ((xf)))
                        (((unsupported)).apply ((xparent)) ((((((xcls).x_meta).xget_parent_list)).apply)))
                          (((unsupported)).apply ((xf)) ((((((xparent).x_meta).xget_fields)).apply)))
                            (((unsupported)).apply ((xf)) ((xused_fields))).if
                              (((unsupported)).apply ((((unsupported)).apply ((xused_fields)) (((xf).xname)))) ((xf)))
                        (((unsupported)).apply ((xf)) ((((xcls).x_meta).xlocal_fields)))
                          seq
                            xclash.write ((((((xused_fields).xget)).apply (((xf).xname))).or ((((xused_fields).xget)).apply (((xf).xattname)))).or "None: is there a None literal in the EO language?")
                            xid_conflict.write ((((((xf).xname).eq "id").and (xclash)).and (((xclash).xname).eq "id")).and (((xclash).xmodel).eq (xcls)))
                            ((xclash).and ((xid_conflict).not)).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The field '%s' clashes with the field '%s' from model '%s'.".mod (((unsupported)).apply (((xf).xname)) (((xclash).xname)) ((((xclash).xmodel).x_meta))))) ((xf)) ("models.E006"))))
                            (((unsupported)).apply ((((unsupported)).apply ((xused_fields)) (((xf).xname)))) ((xf)))
                            (((unsupported)).apply ((((unsupported)).apply ((xused_fields)) (((xf).xattname)))) ((xf)))
                        (((unsupported)).apply ((xerrors)))
                x_check_column_name_clashes.write
                  [xcls]
                    memory > xerrors
                    memory > xused_column_names
                    seq > @
                      (((unsupported)).apply)
                        xused_column_names.write (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xf)) ((((xcls).x_meta).xlocal_fields)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xcolumn_name)))) (((((xf).xget_attname_column)).apply)))
                            ((xcolumn_name).and (((unsupported)).apply ((xcolumn_name)) ((xused_column_names)))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Field '%s' has column name '%s' that is used by another field.".mod (((unsupported)).apply (((xf).xname)) ((xcolumn_name))))) ("Specify a 'db_column' for the field.") ((xcls)) ("models.E007"))))
                              bogusForceDataize.write ((((xused_column_names).xappend)).apply ((xcolumn_name)))
                        (((unsupported)).apply ((xerrors)))
                x_check_model_name_db_lookup_clashes.write
                  [xcls]
                    memory > xerrors
                    memory > xmodel_name
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        xmodel_name.write ((xcls).x__name__)
                        (((((xmodel_name).xstartswith)).apply ("_")).or ((((xmodel_name).xendswith)).apply ("_"))).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The model name '%s' cannot start or end with an underscore as it collides with the query lookup syntax.".mod (xmodel_name))) ((xcls)) ("models.E023"))))
                          (((unsupported)).apply ((xLOOKUP_SEP)) ((xmodel_name))).if
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The model name '%s' cannot contain double underscores as it collides with the query lookup syntax.".mod (xmodel_name))) ((xcls)) ("models.E024"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_property_name_related_field_accessor_clashes.write
                  [xcls]
                    memory > xerrors
                    memory > xproperty_names
                    memory > xrelated_field_accessors
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        xproperty_names.write (((xcls).x_meta).x_property_names)
                        xrelated_field_accessors.write (((unsupported)).apply (((((xf).xget_attname)).apply)) ((xf)) ((((unsupported)).apply ((((xcls).x_meta).x_get_fields)) (FALSE))) ((((xf).xis_relation).and (((unsupported)).apply (((xf).xrelated_model)) ("None: is there a None literal in the EO language?")))))
                        (((unsupported)).apply ((xaccessor)) ((xrelated_field_accessors)))
                          (((unsupported)).apply ((xaccessor)) ((xproperty_names))).if
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The property '%s' clashes with a related field accessor.".mod (xaccessor))) ((xcls)) ("models.E025"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_single_primary_key.write
                  [xcls]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        ((((xsum)).apply ((((unsupported)).apply (1) ((xf)) ((((xcls).x_meta).xlocal_fields)) (((xf).xprimary_key))))).greater 1).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("The model cannot have more than one field with 'primary_key=True'.") ((xcls)) ("models.E026"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_index_together.write
                  [xcls]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        ((((xisinstance)).apply ((((xcls).x_meta).xindex_together)) ((((unsupported)).apply ((xtuple)) ((xlist))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'index_together' must be a list or tuple.") ((xcls)) ("models.E008"))))))
                          (((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xfields)) ((((unsupported)).apply ((xtuple)) ((xlist))))).not)) ((xfields)) ((((xcls).x_meta).xindex_together))))).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("All 'index_together' elements must be lists or tuples.") ((xcls)) ("models.E009"))))))
                            seq
                              xerrors.write (((unsupported)).apply)
                              (((unsupported)).apply ((xfields)) ((((xcls).x_meta).xindex_together)))
                                bogusForceDataize.write ((((xerrors).xextend)).apply (((((xcls).x_check_local_fields)).apply ((xfields)) ("index_together"))))
                              (((unsupported)).apply ((xerrors)))
                x_check_unique_together.write
                  [xcls]
                    memory > xerrors
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        ((((xisinstance)).apply ((((xcls).x_meta).xunique_together)) ((((unsupported)).apply ((xtuple)) ((xlist))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'unique_together' must be a list or tuple.") ((xcls)) ("models.E010"))))))
                          (((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xfields)) ((((unsupported)).apply ((xtuple)) ((xlist))))).not)) ((xfields)) ((((xcls).x_meta).xunique_together))))).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("All 'unique_together' elements must be lists or tuples.") ((xcls)) ("models.E011"))))))
                            seq
                              xerrors.write (((unsupported)).apply)
                              (((unsupported)).apply ((xfields)) ((((xcls).x_meta).xunique_together)))
                                bogusForceDataize.write ((((xerrors).xextend)).apply (((((xcls).x_check_local_fields)).apply ((xfields)) ("unique_together"))))
                              (((unsupported)).apply ((xerrors)))
                x_check_indexes.write
                  [xcls xdatabases]
                    memory > xerrors
                    memory > xreferences
                    memory > xconnection
                    memory > xfields
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xerrors.write (((unsupported)).apply)
                        xreferences.write (((xset)).apply)
                        (((unsupported)).apply ((xindex)) ((((xcls).x_meta).xindexes)))
                          seq
                            (((((unsupported)).apply (((xindex).xname)) (0)).eq "_").or ((((((unsupported)).apply (((xindex).xname)) (0)).xisdigit)).apply)).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The index name '%s' cannot start with an underscore or a number.".mod ((xindex).xname))) ((xcls)) ("models.E033"))))
                            ((((xlen)).apply (((xindex).xname))).greater ((xindex).xmax_name_length)).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The index name '%s' cannot be longer than %d characters.".mod (((unsupported)).apply (((xindex).xname)) (((xindex).xmax_name_length))))) ((xcls)) ("models.E034"))))
                            ((xindex).xcontains_expressions).if
                              (((unsupported)).apply ((xexpression)) (((xindex).xexpressions)))
                                bogusForceDataize.write ((((xreferences).xupdate)).apply ((((unsupported)).apply ((((unsupported)).apply ((xref)) (0))) ((xref)) (((((xcls).x_get_expr_references)).apply ((xexpression)))))))
                        (((unsupported)).apply ((xdb)) ((xdatabases)))
                          seq
                            (((((xrouter).xallow_migrate_model)).apply ((xdb)) ((xcls))).not).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xdb)))
                            ((((((xconnection).xfeatures).xsupports_partial_indexes).or (((unsupported)).apply ("supports_partial_indexes") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply ((((unsupported)).apply (((xindex).xcondition)) ("None: is there a None literal in the EO language?"))) ((xindex)) ((((xcls).x_meta).xindexes)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support indexes with conditions.".mod ((xconnection).xdisplay_name))) ("Conditions will be ignored. Silence this warning if you don't care about it.") ((xcls)) ("models.W037"))))
                            ((((((xconnection).xfeatures).xsupports_covering_indexes).or (((unsupported)).apply ("supports_covering_indexes") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply (((xindex).xinclude)) ((xindex)) ((((xcls).x_meta).xindexes)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support indexes with non-key columns.".mod ((xconnection).xdisplay_name))) ("Non-key columns will be ignored. Silence this warning if you don't care about it.") ((xcls)) ("models.W040"))))
                            ((((((xconnection).xfeatures).xsupports_expression_indexes).or (((unsupported)).apply ("supports_expression_indexes") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply (((xindex).xcontains_expressions)) ((xindex)) ((((xcls).x_meta).xindexes)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support indexes on expressions.".mod ((xconnection).xdisplay_name))) ("An index won't be created. Silence this warning if you don't care about it.") ((xcls)) ("models.W043"))))
                        xfields.write (((unsupported)).apply ((xfield)) ((xindex)) ((((xcls).x_meta).xindexes)) ((((unsupported)).apply ((xfield)) ((x_)))) (((xindex).xfields_orders)))
                        (((unsupported)).apply ((xfields)) ((((unsupported)).apply ((xinclude)) ((xindex)) ((((xcls).x_meta).xindexes)) ((xinclude)) (((xindex).xinclude)))))
                        (((unsupported)).apply ((xfields)) ((xreferences)))
                        bogusForceDataize.write ((((xerrors).xextend)).apply (((((xcls).x_check_local_fields)).apply ((xfields)) ("indexes"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_local_fields.write
                  [xcls xfields xoption]
                    memory > xfield
                    memory > xerrors
                    memory > xforward_fields_map
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xforward_fields_map.write (((unsupported)).apply)
                        (((unsupported)).apply ((xfield)) ((((unsupported)).apply ((((xcls).x_meta).x_get_fields)) (FALSE))))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xforward_fields_map)) (((xfield).xname)))) ((xfield)))
                            (((xhasattr)).apply ((xfield)) ("attname")).if
                              (((unsupported)).apply ((((unsupported)).apply ((xforward_fields_map)) (((xfield).xattname)))) ((xfield)))
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xfield_name)) ((xfields)))
                          (((unsupported)).apply ((xKeyError)))
                            xfield.write (((unsupported)).apply ((xforward_fields_map)) ((xfield_name)))
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' refers to the nonexistent field '%s'.".mod (((unsupported)).apply ((xoption)) ((xfield_name))))) ((xcls)) ("models.E012"))))
                            (((xisinstance)).apply (((xfield).xremote_field)) (((xmodels).xManyToManyRel))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' refers to a ManyToManyField '%s', but ManyToManyFields are not permitted in '%s'.".mod (((unsupported)).apply ((xoption)) ((xfield_name)) ((xoption))))) ((xcls)) ("models.E013"))))
                              (((unsupported)).apply ((xfield)) ((((xcls).x_meta).xlocal_fields))).if
                                bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' refers to field '%s' which is not local to model '%s'.".mod (((unsupported)).apply ((xoption)) ((xfield_name)) ((((xcls).x_meta).xobject_name))))) ("This issue may be caused by multi-table inheritance.") ((xcls)) ("models.E016"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_ordering.write
                  [xcls]
                    memory > xvalid_fields
                    memory > xinvalid_fields
                    memory > xfld
                    memory > x_fields
                    memory > x_cls
                    memory > xrelated_fields
                    memory > xopts
                    memory > xerrors
                    memory > xfields
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xcls).x_meta).x_ordering_clash).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'ordering' and 'order_with_respect_to' cannot be used together.") ((xcls)) ("models.E021"))))))
                        ((((xcls).x_meta).xorder_with_respect_to).or ((((xcls).x_meta).xordering).not)).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        ((((xisinstance)).apply ((((xcls).x_meta).xordering)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("'ordering' must be a tuple or list (even if you want to order by only one field).") ((xcls)) ("models.E014"))))))
                        xerrors.write (((unsupported)).apply)
                        xfields.write (((xcls).x_meta).xordering)
                        xfields.write (((unsupported)).apply ((xf)) ((xf)) ((xfields)) (((((xisinstance)).apply ((xf)) ((xstr))).and ((xf).neq "?"))))
                        xfields.write (((unsupported)).apply ((((((xf).xstartswith)).apply ("-")).if (((unsupported)).apply ((xf)) ((((unsupported)).apply (1)))) (xf))) ((xf)) ((xfields)))
                        x_fields.write (((unsupported)).apply)
                        xrelated_fields.write (((unsupported)).apply)
                        (((unsupported)).apply ((xf)) ((xfields)))
                          (((unsupported)).apply ((xLOOKUP_SEP)) ((xf))).if
                            bogusForceDataize.write ((((xrelated_fields).xappend)).apply ((xf)))
                            bogusForceDataize.write ((((x_fields).xappend)).apply ((xf)))
                        xfields.write (x_fields)
                        (((unsupported)).apply ((xfield)) ((xrelated_fields)))
                          seq
                            x_cls.write (xcls)
                            xfld.write "None: is there a None literal in the EO language?"
                            (((unsupported)).apply ((xpart)) (((((xfield).xsplit)).apply ((xLOOKUP_SEP)))))
                              (((unsupported)).apply ((((unsupported)).apply ((xFieldDoesNotExist)) ((xAttributeError)))))
                                seq
                                  ((xpart).eq "pk").if
                                    xfld.write (((x_cls).x_meta).xpk)
                                    xfld.write (((((x_cls).x_meta).xget_field)).apply ((xpart)))
                                  ((xfld).xis_relation).if
                                    x_cls.write (((((unsupported)).apply (((xfld).xpath_infos)) ((1.neg))).xto_opts).xmodel)
                                    x_cls.write "None: is there a None literal in the EO language?"
                                ((((unsupported)).apply ((xfld)) ("None: is there a None literal in the EO language?")).or ((((unsupported)).apply (((((xfld).xget_transform)).apply ((xpart)))) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply (((((xfld).xget_lookup)).apply ((xpart)))) ("None: is there a None literal in the EO language?")))).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'ordering' refers to the nonexistent field, related field, or lookup '%s'.".mod (xfield))) ((xcls)) ("models.E015"))))
                        xfields.write (((unsupported)).apply ((xf)) ((xf)) ((xfields)) (((xf).neq "pk")))
                        xinvalid_fields.write (((unsupported)).apply)
                        xopts.write ((xcls).x_meta)
                        xvalid_fields.write (((xset)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply ((((((xf).xauto_created).and (((xf).xconcrete).not)).not).if (((unsupported)).apply (((xf).xname)) (((xf).xattname))) (((unsupported)).apply ((((((xf).xfield).xrelated_query_name)).apply))))) ((xf)) ((((xchain)).apply (((xopts).xfields)) (((xopts).xrelated_objects)))))))))
                        bogusForceDataize.write ((((xinvalid_fields).xextend)).apply (((xfields).sub (xvalid_fields))))
                        (((unsupported)).apply ((xinvalid_field)) ((xinvalid_fields)))
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'ordering' refers to the nonexistent field, related field, or lookup '%s'.".mod (xinvalid_field))) ((xcls)) ("models.E015"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_long_column_names.write
                  [xcls xdatabases]
                    memory > xdb_alias
                    memory > xconnection
                    memory > xmax_name_length
                    memory > xerrors
                    memory > xallowed_len
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        ((xdatabases).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xerrors.write (((unsupported)).apply)
                        xallowed_len.write "None: is there a None literal in the EO language?"
                        xdb_alias.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply ((xdb)) ((xdatabases)))
                          seq
                            (((((xrouter).xallow_migrate_model)).apply ((xdb)) ((xcls))).not).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xdb)))
                            xmax_name_length.write (((((xconnection).xops).xmax_name_length)).apply)
                            ((((unsupported)).apply ((xmax_name_length)) ("None: is there a None literal in the EO language?")).or (((xconnection).xfeatures).xtruncates_names)).if
                              (((unsupported)).apply)
                              (((unsupported)).apply ((xallowed_len)) ("None: is there a None literal in the EO language?")).if
                                seq
                                  xallowed_len.write (xmax_name_length)
                                  xdb_alias.write (xdb)
                                ((xmax_name_length).less (xallowed_len)).if
                                  seq
                                    xallowed_len.write (xmax_name_length)
                                    xdb_alias.write (xdb)
                        (((unsupported)).apply ((xallowed_len)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xerrors)))
                        (((unsupported)).apply ((xf)) ((((xcls).x_meta).xlocal_fields)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xcolumn_name)))) (((((xf).xget_attname_column)).apply)))
                            (((((unsupported)).apply (((xf).xdb_column)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xcolumn_name)) ("None: is there a None literal in the EO language?"))).and ((((xlen)).apply ((xcolumn_name))).greater (xallowed_len))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Autogenerated column name too long for field \"%s\". Maximum length is \"%s\" for database \"%s\".".mod (((unsupported)).apply ((xcolumn_name)) ((xallowed_len)) ((xdb_alias))))) ("Set the column name manually using 'db_column'.") ((xcls)) ("models.E018"))))
                        (((unsupported)).apply ((xf)) ((((xcls).x_meta).xlocal_many_to_many)))
                          seq
                            (((xisinstance)).apply ((((xf).xremote_field).xthrough)) ((xstr))).if
                              (((unsupported)).apply)
                            (((unsupported)).apply ((xm2m)) ((((((xf).xremote_field).xthrough).x_meta).xlocal_fields)))
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xrel_name)))) (((((xm2m).xget_attname_column)).apply)))
                                (((((unsupported)).apply (((xm2m).xdb_column)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xrel_name)) ("None: is there a None literal in the EO language?"))).and ((((xlen)).apply ((xrel_name))).greater (xallowed_len))).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Autogenerated column name too long for M2M field \"%s\". Maximum length is \"%s\" for database \"%s\".".mod (((unsupported)).apply ((xrel_name)) ((xallowed_len)) ((xdb_alias))))) ("Use 'through' to create a separate model for M2M and then set column_name using 'db_column'.") ((xcls)) ("models.E019"))))
                        (((unsupported)).apply ((xerrors)))
                x_get_expr_references.write
                  [xcls xexpr]
                    seq > @
                      (((unsupported)).apply)
                        (((xisinstance)).apply ((xexpr)) ((xQ))).if
                          (((unsupported)).apply ((xchild)) (((xexpr).xchildren)))
                            (((xisinstance)).apply ((xchild)) ((xtuple))).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xlookup)) ((xvalue)))) ((xchild)))
                                (((unsupported)).apply ((((xtuple)).apply (((((xlookup).xsplit)).apply ((xLOOKUP_SEP)))))))
                                (((unsupported)).apply (((((xcls).x_get_expr_references)).apply ((xvalue)))))
                              (((unsupported)).apply (((((xcls).x_get_expr_references)).apply ((xchild)))))
                          (((xisinstance)).apply ((xexpr)) ((xF))).if
                            (((unsupported)).apply ((((xtuple)).apply ((((((xexpr).xname).xsplit)).apply ((xLOOKUP_SEP)))))))
                            (((xhasattr)).apply ((xexpr)) ("get_source_expressions")).if
                              (((unsupported)).apply ((xsrc_expr)) (((((xexpr).xget_source_expressions)).apply)))
                                (((unsupported)).apply (((((xcls).x_get_expr_references)).apply ((xsrc_expr)))))
                x_check_constraints.write
                  [xcls xdatabases]
                    memory > xfield
                    memory > xfirst_lookup
                    memory > xreferences
                    memory > xconnection
                    memory > xerrors
                    memory > xfields
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xdb)) ((xdatabases)))
                          seq
                            (((((xrouter).xallow_migrate_model)).apply ((xdb)) ((xcls))).not).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xdb)))
                            ((((((xconnection).xfeatures).xsupports_table_check_constraints).or (((unsupported)).apply ("supports_table_check_constraints") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply ((((xisinstance)).apply ((xconstraint)) ((xCheckConstraint)))) ((xconstraint)) ((((xcls).x_meta).xconstraints)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support check constraints.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xcls)) ("models.W027"))))
                            ((((((xconnection).xfeatures).xsupports_partial_indexes).or (((unsupported)).apply ("supports_partial_indexes") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xconstraint)) ((xUniqueConstraint))).and (((unsupported)).apply (((xconstraint).xcondition)) ("None: is there a None literal in the EO language?")))) ((xconstraint)) ((((xcls).x_meta).xconstraints)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support unique constraints with conditions.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xcls)) ("models.W036"))))
                            ((((((xconnection).xfeatures).xsupports_deferrable_unique_constraints).or (((unsupported)).apply ("supports_deferrable_unique_constraints") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xconstraint)) ((xUniqueConstraint))).and (((unsupported)).apply (((xconstraint).xdeferrable)) ("None: is there a None literal in the EO language?")))) ((xconstraint)) ((((xcls).x_meta).xconstraints)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support deferrable unique constraints.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xcls)) ("models.W038"))))
                            ((((((xconnection).xfeatures).xsupports_covering_indexes).or (((unsupported)).apply ("supports_covering_indexes") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xconstraint)) ((xUniqueConstraint))).and ((xconstraint).xinclude))) ((xconstraint)) ((((xcls).x_meta).xconstraints)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support unique constraints with non-key columns.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xcls)) ("models.W039"))))
                            ((((((xconnection).xfeatures).xsupports_expression_indexes).or (((unsupported)).apply ("supports_expression_indexes") ((((xcls).x_meta).xrequired_db_features)))).not).and (((xany)).apply ((((unsupported)).apply (((((xisinstance)).apply ((xconstraint)) ((xUniqueConstraint))).and ((xconstraint).xcontains_expressions))) ((xconstraint)) ((((xcls).x_meta).xconstraints)))))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) (("%s does not support unique constraints on expressions.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xcls)) ("models.W044"))))
                            xfields.write (((xset)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xconstraint).xfields)))) ((((unsupported)).apply (((xconstraint).xinclude)))))) ((xconstraint)) ((((xcls).x_meta).xconstraints)) ((((xisinstance)).apply ((xconstraint)) ((xUniqueConstraint)))))))))
                            xreferences.write (((xset)).apply)
                            (((unsupported)).apply ((xconstraint)) ((((xcls).x_meta).xconstraints)))
                              (((xisinstance)).apply ((xconstraint)) ((xUniqueConstraint))).if
                                seq
                                  (((((xconnection).xfeatures).xsupports_partial_indexes).or (((unsupported)).apply ("supports_partial_indexes") ((((xcls).x_meta).xrequired_db_features)))).and (((xisinstance)).apply (((xconstraint).xcondition)) ((xQ)))).if
                                    bogusForceDataize.write ((((xreferences).xupdate)).apply (((((xcls).x_get_expr_references)).apply (((xconstraint).xcondition)))))
                                  (((((xconnection).xfeatures).xsupports_expression_indexes).or (((unsupported)).apply ("supports_expression_indexes") ((((xcls).x_meta).xrequired_db_features)))).and ((xconstraint).xcontains_expressions)).if
                                    (((unsupported)).apply ((xexpression)) (((xconstraint).xexpressions)))
                                      bogusForceDataize.write ((((xreferences).xupdate)).apply (((((xcls).x_get_expr_references)).apply ((xexpression)))))
                                (((xisinstance)).apply ((xconstraint)) ((xCheckConstraint))).if
                                  (((((xconnection).xfeatures).xsupports_table_check_constraints).or (((unsupported)).apply ("supports_table_check_constraints") ((((xcls).x_meta).xrequired_db_features)))).and (((xisinstance)).apply (((xconstraint).xcheck)) ((xQ)))).if
                                    bogusForceDataize.write ((((xreferences).xupdate)).apply (((((xcls).x_get_expr_references)).apply (((xconstraint).xcheck)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xfield_name)) ((((unsupported)).apply ((xlookups)))))) ((xreferences)))
                              seq
                                ((xfield_name).neq "pk").if
                                  bogusForceDataize.write ((((xfields).xadd)).apply ((xfield_name)))
                                ((xlookups).not).if
                                  (((unsupported)).apply)
                                (((unsupported)).apply ((xFieldDoesNotExist)))
                                  seq
                                    ((xfield_name).eq "pk").if
                                      xfield.write (((xcls).x_meta).xpk)
                                      xfield.write (((((xcls).x_meta).xget_field)).apply ((xfield_name)))
                                    (((((xfield).xis_relation).not).or ((xfield).xmany_to_many)).or ((xfield).xone_to_many)).if
                                      (((unsupported)).apply)
                                  (((unsupported)).apply)
                                xfirst_lookup.write (((unsupported)).apply ((xlookups)) (0))
                                ((((((xhasattr)).apply ((xfield)) ("get_transform")).and (((xhasattr)).apply ((xfield)) ("get_lookup"))).and (((unsupported)).apply (((((xfield).xget_transform)).apply ((xfirst_lookup)))) ("None: is there a None literal in the EO language?"))).and (((unsupported)).apply (((((xfield).xget_lookup)).apply ((xfirst_lookup)))) ("None: is there a None literal in the EO language?"))).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'constraints' refers to the joined field '%s'.".mod ((((xLOOKUP_SEP).xjoin)).apply (((((unsupported)).apply ((xfield_name))).sub (xlookups)))))) ((xcls)) ("models.E041"))))
                            bogusForceDataize.write ((((xerrors).xextend)).apply (((((xcls).x_check_local_fields)).apply ((xfields)) ("constraints"))))
                        (((unsupported)).apply ((xerrors)))
            xmethod_set_order.write
              [xself xordered_obj xid_list xusing]
                memory > xfilter_args
                memory > xorder_wrt
                seq > @
                  (((unsupported)).apply)
                    xorder_wrt.write (((xordered_obj).x_meta).xorder_with_respect_to)
                    xfilter_args.write ((((xorder_wrt).xget_forward_related_filter)).apply ((xself)))
                    bogusForceDataize.write (((((((((((xordered_obj).xobjects).xdb_manager)).apply ((xusing))).xfilter)).apply ((((unsupported)).apply ((xfilter_args))))).xbulk_update)).apply ((((unsupported)).apply ((((unsupported)).apply ((xordered_obj)) ((xpk)) ((xorder)))) ((((unsupported)).apply ((xorder)) ((xpk)))) ((((xenumerate)).apply ((xid_list)))))) ((((unsupported)).apply ("_order"))))
            xmethod_get_order.write
              [xself xordered_obj]
                memory > xfilter_args
                memory > xpk_name
                memory > xorder_wrt
                seq > @
                  seq
                    xorder_wrt.write (((xordered_obj).x_meta).xorder_with_respect_to)
                    xfilter_args.write ((((xorder_wrt).xget_forward_related_filter)).apply ((xself)))
                    xpk_name.write ((((xordered_obj).x_meta).xpk).xname)
                    (((unsupported)).apply ((((unsupported)).apply (((((((xordered_obj).xobjects).xfilter)).apply ((((unsupported)).apply ((xfilter_args))))).xvalues_list)) ((xpk_name)) (TRUE))))
            xmake_foreign_order_accessors.write
              [xmodel xrelated_model]
                seq > @
                  seq
                    bogusForceDataize.write (((xsetattr)).apply ((xrelated_model)) (("get_%s_order".mod (((((xmodel).x__name__).xlower)).apply))) ((((xpartialmethod)).apply ((xmethod_get_order)) ((xmodel)))))
                    bogusForceDataize.write (((xsetattr)).apply ((xrelated_model)) (("set_%s_order".mod (((((xmodel).x__name__).xlower)).apply))) ((((xpartialmethod)).apply ((xmethod_set_order)) ((xmodel)))))
            xmodel_unpickle.write
              [xmodel_id]
                memory > xmodel
                seq > @
                  seq
                    unsupported
                    (((xisinstance)).apply ((xmodel_id)) ((xtuple))).if
                      xmodel.write ((((xapps).xget_model)).apply ((((unsupported)).apply ((xmodel_id)))))
                      xmodel.write (xmodel_id)
                    (((unsupported)).apply (((((xmodel).x__new__)).apply ((xmodel)))))
            (((unsupported)).apply (((xmodel_unpickle).x__safe_for_unpickle__)) (TRUE))