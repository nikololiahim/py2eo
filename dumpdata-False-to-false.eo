memory > xImportError
memory > xmodel_list
memory > xValueError
memory > xWarning
memory > xrouter
memory > xKeyError
memory > xRuntimeWarning
memory > xBaseCommand
memory > xint
memory > xException
memory > xe
memory > xexcluded_models
memory > xfile_root
memory > xfalse
memory > xDEFAULT_DB_ALIAS
memory > xProxyModelWarning
memory > xfile_path
memory > xfile_ext
memory > xstr
memory > xlabel
memory > xwarnings
memory > xapps
memory > xpk
memory > xopen
memory > xsum
memory > xexcluded_apps
memory > xgzip
memory > xserializers
memory > xopen_method
memory > xbz2
memory > xmodel_label
memory > xapp_labels
memory > xLookupError
memory > xos
memory > xoptions
memory > xkwargs
memory > xdict
memory > xCommandError
memory > xlen
memory > xparse_apps_and_model_labels
memory > xlzma
[] > dumpdata
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xhas_lzma
        memory > xhandle
        memory > xhas_bz2
        memory > xadd_arguments
        memory > xhelp
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply ((xImportError)))
              seq
                (((unsupported)).apply)
                xhas_bz2.write TRUE
              xhas_bz2.write (xfalse)
            (((unsupported)).apply ((xImportError)))
              seq
                (((unsupported)).apply)
                xhas_lzma.write TRUE
              xhas_lzma.write (xfalse)
            (((unsupported)).apply ((xWarning)))
            (((unsupported)).apply ((xBaseCommand)))
              seq
                xhelp.write "Output the contents of the database as a fixture of the given format (using each model's default manager unless --all is specified)."
                xadd_arguments.write
                  [xself xparser]
                    seq > @
                      seq
                        (((unsupported)).apply (((xparser).xadd_argument)) ("args") ("app_label[.ModelName]") ("*") ("Restricts dumped data to the specified app_label or app_label.ModelName."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--format") ("json") ("Specifies the output serialization format for fixtures."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--indent") ((xint)) ("Specifies the indent level to use when pretty-printing output."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--database") ((xDEFAULT_DB_ALIAS)) ("Nominates a specific database to dump fixtures from. Defaults to the \"default\" database."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("-e") ("--exclude") ("append") ((((unsupported)).apply)) ("An app_label or app_label.ModelName to exclude (use multiple --exclude to exclude multiple apps/models)."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--natural-foreign") ("store_true") ("use_natural_foreign_keys") ("Use natural foreign keys if they are available."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--natural-primary") ("store_true") ("use_natural_primary_keys") ("Use natural primary keys if they are available."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("-a") ("--all") ("store_true") ("use_base_manager") ("Use Django's base manager to dump all models stored in the database, including those that would otherwise be filtered or modified by a custom manager."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--pks") ("primary_keys") ("Only dump objects with given primary keys. Accepts a comma-separated list of keys. This option only works when you specify one model."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("-o") ("--output") ("Specifies file to which the output is written."))
                xhandle.write
                  [xself]
                    memory > xusing
                    memory > xshow_traceback
                    memory > xget_objects
                    memory > xoutput
                    memory > xfile_name
                    memory > xuse_natural_primary_keys
                    memory > xobject_count
                    memory > xexcludes
                    memory > xprogress_output
                    memory > xuse_natural_foreign_keys
                    memory > xapp_list_value
                    memory > xpks
                    memory > xstream
                    memory > xindent
                    memory > xapp_label
                    memory > xuse_base_manager
                    memory > xapp_list
                    memory > xprimary_keys
                    memory > xformat
                    memory > xapp_config
                    memory > xcompression_formats
                    memory > xmodel
                    seq > @
                      (((unsupported)).apply)
                        xformat.write (((unsupported)).apply ((xoptions)) ("format"))
                        xindent.write (((unsupported)).apply ((xoptions)) ("indent"))
                        xusing.write (((unsupported)).apply ((xoptions)) ("database"))
                        xexcludes.write (((unsupported)).apply ((xoptions)) ("exclude"))
                        xoutput.write (((unsupported)).apply ((xoptions)) ("output"))
                        xshow_traceback.write (((unsupported)).apply ((xoptions)) ("traceback"))
                        xuse_natural_foreign_keys.write (((unsupported)).apply ((xoptions)) ("use_natural_foreign_keys"))
                        xuse_natural_primary_keys.write (((unsupported)).apply ((xoptions)) ("use_natural_primary_keys"))
                        xuse_base_manager.write (((unsupported)).apply ((xoptions)) ("use_base_manager"))
                        xpks.write (((unsupported)).apply ((xoptions)) ("primary_keys"))
                        (xpks).if
                          xprimary_keys.write (((unsupported)).apply (((((xpk).xstrip)).apply)) ((xpk)) (((((xpks).xsplit)).apply (","))))
                          xprimary_keys.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xexcluded_models)) ((xexcluded_apps)))) ((((xparse_apps_and_model_labels)).apply ((xexcludes)))))
                        ((xapp_labels).not).if
                          seq
                            (xprimary_keys).if
                              (((unsupported)).apply ((((xCommandError)).apply ("You can only use --pks option with one model"))))
                            xapp_list.write ((((xdict).xfromkeys)).apply ((((unsupported)).apply ((xapp_config)) ((xapp_config)) (((((xapps).xget_app_configs)).apply)) (((((unsupported)).apply (((xapp_config).xmodels_module)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xapp_config)) ((xexcluded_apps))))))))
                          seq
                            (((((xlen)).apply ((xapp_labels))).greater 1).and (xprimary_keys)).if
                              (((unsupported)).apply ((((xCommandError)).apply ("You can only use --pks option with one model"))))
                            xapp_list.write (((unsupported)).apply)
                            (((unsupported)).apply ((xlabel)) ((xapp_labels)))
                              (((unsupported)).apply ((xValueError)))
                                seq
                                  (((unsupported)).apply ((((unsupported)).apply ((xapp_label)) ((xmodel_label)))) (((((xlabel).xsplit)).apply ("."))))
                                  (((unsupported)).apply ((xLookupError)))
                                    xapp_config.write ((((xapps).xget_app_config)).apply ((xapp_label)))
                                    (((unsupported)).apply ((((xCommandError)).apply ((((xstr)).apply ((xe)))))))
                                  ((((unsupported)).apply (((xapp_config).xmodels_module)) ("None: is there a None literal in the EO language?")).or (((unsupported)).apply ((xapp_config)) ((xexcluded_apps)))).if
                                    (((unsupported)).apply)
                                  (((unsupported)).apply ((xLookupError)))
                                    xmodel.write ((((xapp_config).xget_model)).apply ((xmodel_label)))
                                    (((unsupported)).apply ((((xCommandError)).apply (("Unknown model: %s.%s".mod (((unsupported)).apply ((xapp_label)) ((xmodel_label))))))))
                                  xapp_list_value.write ((((xapp_list).xsetdefault)).apply ((xapp_config)) ((((unsupported)).apply)))
                                  ((((unsupported)).apply ((xapp_list_value)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xmodel)) ((xapp_list_value)))).if
                                    bogusForceDataize.write ((((xapp_list_value).xappend)).apply ((xmodel)))
                                seq
                                  (xprimary_keys).if
                                    (((unsupported)).apply ((((xCommandError)).apply ("You can only use --pks option with one model"))))
                                  xapp_label.write (xlabel)
                                  (((unsupported)).apply ((xLookupError)))
                                    xapp_config.write ((((xapps).xget_app_config)).apply ((xapp_label)))
                                    (((unsupported)).apply ((((xCommandError)).apply ((((xstr)).apply ((xe)))))))
                                  ((((unsupported)).apply (((xapp_config).xmodels_module)) ("None: is there a None literal in the EO language?")).or (((unsupported)).apply ((xapp_config)) ((xexcluded_apps)))).if
                                    (((unsupported)).apply)
                                  (((unsupported)).apply ((((unsupported)).apply ((xapp_list)) ((xapp_config)))) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xformat)) (((((xserializers).xget_public_serializer_formats)).apply))).if
                          seq
                            (((unsupported)).apply (((xserializers).xSerializerDoesNotExist)))
                              bogusForceDataize.write ((((xserializers).xget_serializer)).apply ((xformat)))
                            (((unsupported)).apply ((((xCommandError)).apply (("Unknown serialization format: %s".mod (xformat))))))
                        xget_objects.write
                          [xcount_only]
                            memory > xmodels
                            memory > xobjects
                            memory > xqueryset
                            seq > @
                              (((unsupported)).apply)
                                (((unsupported)).apply)
                                (xuse_natural_foreign_keys).if
                                  xmodels.write (((unsupported)).apply (((xserializers).xsort_dependencies)) (((((xapp_list).xitems)).apply)) (TRUE))
                                  seq
                                    xmodels.write (((unsupported)).apply)
                                    (((unsupported)).apply ((((unsupported)).apply ((xapp_config)) ((xmodel_list)))) (((((xapp_list).xitems)).apply)))
                                      (((unsupported)).apply ((xmodel_list)) ("None: is there a None literal in the EO language?")).if
                                        bogusForceDataize.write ((((xmodels).xextend)).apply (((((xapp_config).xget_models)).apply)))
                                        bogusForceDataize.write ((((xmodels).xextend)).apply ((xmodel_list)))
                                (((unsupported)).apply ((xmodel)) ((xmodels)))
                                  seq
                                    (((unsupported)).apply ((xmodel)) ((xexcluded_models))).if
                                      (((unsupported)).apply)
                                    ((((xmodel).x_meta).xproxy).and (((unsupported)).apply ((((xmodel).x_meta).xproxy_for_model)) ((xmodels)))).if
                                      (((unsupported)).apply (((xwarnings).xwarn)) (("%s is a proxy model and won't be serialized.".mod (((xmodel).x_meta).xlabel))) ((xProxyModelWarning)))
                                    (((((xmodel).x_meta).xproxy).not).and ((((xrouter).xallow_migrate_model)).apply ((xusing)) ((xmodel)))).if
                                      seq
                                        (xuse_base_manager).if
                                          xobjects.write ((xmodel).x_base_manager)
                                          xobjects.write ((xmodel).x_default_manager)
                                        xqueryset.write (((((((xobjects).xusing)).apply ((xusing))).xorder_by)).apply (((((xmodel).x_meta).xpk).xname)))
                                        (xprimary_keys).if
                                          xqueryset.write (((unsupported)).apply (((xqueryset).xfilter)) ((xprimary_keys)))
                                        (xcount_only).if
                                          (((unsupported)).apply ((((((((xqueryset).xorder_by)).apply).xcount)).apply)))
                                          (((unsupported)).apply (((((xqueryset).xiterator)).apply)))
                        (((unsupported)).apply ((xException)))
                          seq
                            (((unsupported)).apply ((((xself).xstdout).xending)) ("None: is there a None literal in the EO language?"))
                            xprogress_output.write "None: is there a None literal in the EO language?"
                            xobject_count.write 0
                            (((xoutput).and (((((xself).xstdout).xisatty)).apply)).and ((((unsupported)).apply ((xoptions)) ("verbosity")).greater 0)).if
                              seq
                                xprogress_output.write ((xself).xstdout)
                                xobject_count.write (((xsum)).apply ((((unsupported)).apply ((xget_objects)) (TRUE))))
                            (xoutput).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xfile_root)) ((xfile_ext)))) ((((((xos).xpath).xsplitext)).apply ((xoutput)))))
                                xcompression_formats.write (((unsupported)).apply (".bz2") ((((unsupported)).apply ((xopen)) ((((unsupported)).apply)) ((xfile_root)))) (".gz") ((((unsupported)).apply (((xgzip).xopen)) ((((unsupported)).apply)) ((xoutput)))) (".lzma") ((((unsupported)).apply ((xopen)) ((((unsupported)).apply)) ((xfile_root)))) (".xz") ((((unsupported)).apply ((xopen)) ((((unsupported)).apply)) ((xfile_root)))) (".zip") ((((unsupported)).apply ((xopen)) ((((unsupported)).apply)) ((xfile_root)))))
                                (xhas_bz2).if
                                  (((unsupported)).apply ((((unsupported)).apply ((xcompression_formats)) (".bz2"))) ((((unsupported)).apply (((xbz2).xopen)) ((((unsupported)).apply)) ((xoutput)))))
                                (xhas_lzma).if
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply ((xcompression_formats)) (".lzma"))) ((((unsupported)).apply (((xlzma).xopen)) ((((unsupported)).apply ("format") (((xlzma).xFORMAT_ALONE)))) ((xoutput)))))
                                    (((unsupported)).apply ((((unsupported)).apply ((xcompression_formats)) (".xz"))) ((((unsupported)).apply (((xlzma).xopen)) ((((unsupported)).apply)) ((xoutput)))))
                                (((unsupported)).apply ((xKeyError)))
                                  (((unsupported)).apply ((((unsupported)).apply ((xopen_method)) ((xkwargs)) ((xfile_path)))) ((((unsupported)).apply ((xcompression_formats)) ((xfile_ext)))))
                                  (((unsupported)).apply ((((unsupported)).apply ((xopen_method)) ((xkwargs)) ((xfile_path)))) ((((unsupported)).apply ((xopen)) ((((unsupported)).apply)) ((xoutput)))))
                                ((xfile_path).neq (xoutput)).if
                                  seq
                                    xfile_name.write (((((xos).xpath).xbasename)).apply ((xfile_path)))
                                    bogusForceDataize.write ((((xwarnings).xwarn)).apply ("Unsupported file extension ({file_ext}). Fixtures saved in '{file_name}'.") ((xRuntimeWarning)))
                                xstream.write (((xopen_method)).apply ((xfile_path)) ("wt") ((((unsupported)).apply ((xkwargs)))))
                              xstream.write "None: is there a None literal in the EO language?"
                            (((unsupported)).apply)
                              (((unsupported)).apply (((xserializers).xserialize)) ((xformat)) ((((xget_objects)).apply)) ((xindent)) ((xuse_natural_foreign_keys)) ((xuse_natural_primary_keys)) (((xstream).or ((xself).xstdout))) ((xprogress_output)) ((xobject_count)))
                              (xstream).if
                                bogusForceDataize.write ((((xstream).xclose)).apply)
                          seq
                            (xshow_traceback).if
                              (((unsupported)).apply)
                            (((unsupported)).apply ((((xCommandError)).apply (("Unable to serialize database: %s".mod (xe))))))