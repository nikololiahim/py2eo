memory > xUnicodeDecodeError
memory > xBytesIO
memory > xKeyError
memory > xparser
memory > xsettings
memory > xbasetype
memory > xmessage_from_string
memory > xUnicodeEncodeError
memory > xAddress
memory > xMessage
memory > xformatdate
memory > xgenerator
memory > xtoken
memory > xSafeMIMEText
memory > xlist
memory > xMIMEBase
memory > xMIMEMessage
memory > xalternative
memory > xattachment
memory > xformataddr
memory > xValueError
memory > xBadHeaderError
memory > xstr
memory > xHeader
memory > xforce_str
memory > xmake_msgid
memory > xfile
memory > xSafeMIMEMessage
memory > xemail
memory > xgetaddresses
memory > xrest
memory > xHeaderParseError
memory > xpunycode
memory > xvalue
memory > xIndexError
memory > xEmailMessage
memory > xMIMEMultipart
memory > xPath
memory > xany
memory > xDNS_NAME
memory > x_params
memory > xsuper
memory > xsubtype
memory > xbytes
memory > xtuple
memory > xv
memory > xSafeMIMEMultipart
memory > xStringIO
memory > xname
memory > xaddr
memory > xMIMEMixin
memory > xisinstance
memory > xline
memory > xlen
memory > xMIMEText
memory > xTypeError
memory > xmimetypes
memory > xkey
[] > message
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xalternative_subtype
        memory > xRFC5322_EMAIL_LINE_LENGTH_LIMIT
        memory > x_create_message
        memory > xrecipients
        memory > xattach
        memory > x_create_attachments
        memory > xDEFAULT_ATTACHMENT_MIME_TYPE
        memory > x_create_alternatives
        memory > xsend
        memory > x__setitem__
        memory > x_create_attachment
        memory > xEncoders
        memory > x_create_mime_attachment
        memory > xget_connection
        memory > xas_bytes
        memory > xCharset
        memory > xmessage
        memory > xsanitize_address
        memory > xattach_file
        memory > xforbid_multi_line_headers
        memory > xmixed_subtype
        memory > xattach_alternative
        memory > xset_payload
        memory > xcontent_subtype
        memory > xas_string
        memory > xutf8_charset
        memory > xencoding
        memory > x_set_list_header_if_not_empty
        memory > x__init__
        memory > xADDRESS_HEADERS
        memory > xutf8_charset_qp
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            xutf8_charset.write ((((xCharset).xCharset)).apply ("utf-8"))
            (((unsupported)).apply (((xutf8_charset).xbody_encoding)) ("None: is there a None literal in the EO language?"))
            xutf8_charset_qp.write ((((xCharset).xCharset)).apply ("utf-8"))
            (((unsupported)).apply (((xutf8_charset_qp).xbody_encoding)) (((xCharset).xQP)))
            xDEFAULT_ATTACHMENT_MIME_TYPE.write "application/octet-stream"
            xRFC5322_EMAIL_LINE_LENGTH_LIMIT.write 998
            (((unsupported)).apply ((xValueError)))
            xADDRESS_HEADERS.write (((unsupported)).apply ("from") ("sender") ("reply-to") ("to") ("cc") ("bcc") ("resent-from") ("resent-sender") ("resent-to") ("resent-cc") ("resent-bcc"))
            xforbid_multi_line_headers.write
              [xname xval xencoding]
                seq > @
                  seq
                    unsupported
                    xencoding.write ((xencoding).or ((xsettings).xDEFAULT_CHARSET))
                    xval.write (((xstr)).apply ((xval)))
                    ((((unsupported)).apply ("n") ((xval))).or (((unsupported)).apply ("r") ((xval)))).if
                      (((unsupported)).apply ((((xBadHeaderError)).apply (("Header values can't contain newlines (got %r for header %r)".mod (((unsupported)).apply ((xval)) ((xname))))))))
                    (((unsupported)).apply ((xUnicodeEncodeError)))
                      bogusForceDataize.write ((((xval).xencode)).apply ("ascii"))
                      (((unsupported)).apply (((((xname).xlower)).apply)) ((xADDRESS_HEADERS))).if
                        xval.write (((", ".xjoin)).apply ((((unsupported)).apply ((((xsanitize_address)).apply ((xaddr)) ((xencoding)))) ((xaddr)) ((((xgetaddresses)).apply ((((unsupported)).apply ((xval)))))))))
                        xval.write ((((((xHeader)).apply ((xval)) ((xencoding))).xencode)).apply)
                      (((((xname).xlower)).apply).eq "subject").if
                        xval.write ((((((xHeader)).apply ((xval))).xencode)).apply)
                    (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xval)))))
            xsanitize_address.write
              [xaddr xencoding]
                memory > xlocalpart
                memory > xnm
                memory > xaddress_parts
                memory > xparsed_address
                memory > xdomain
                memory > xaddress
                seq > @
                  seq
                    (((unsupported)).apply)
                    xaddress.write "None: is there a None literal in the EO language?"
                    ((((xisinstance)).apply ((xaddr)) ((xtuple))).not).if
                      seq
                        xaddr.write (((xforce_str)).apply ((xaddr)))
                        (((unsupported)).apply ((((unsupported)).apply ((xHeaderParseError)) ((xValueError)) ((xIndexError)))))
                          (((unsupported)).apply ((((unsupported)).apply ((xtoken)) ((xrest)))) (((((xparser).xget_mailbox)).apply ((xaddr)))))
                          (((unsupported)).apply ((((xValueError)).apply (("Invalid address \"%s\"".mod (xaddr))))))
                          seq
                            (xrest).if
                              (((unsupported)).apply ((((xValueError)).apply (("Invalid address; only %s could be parsed from \"%s\"".mod (((unsupported)).apply ((xtoken)) ((xaddr))))))))
                            xnm.write (((xtoken).xdisplay_name).or "")
                            xlocalpart.write ((xtoken).xlocal_part)
                            xdomain.write (((xtoken).xdomain).or "")
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xnm)) ((xaddress)))) ((xaddr)))
                        (((unsupported)).apply ((((unsupported)).apply ((xlocalpart)) ((xdomain)))) (((((xaddress).xrsplit)).apply ("@") (1))))
                    xaddress_parts.write (((xnm).add (xlocalpart)).add (xdomain))
                    ((((unsupported)).apply ("n") ((xaddress_parts))).or (((unsupported)).apply ("r") ((xaddress_parts)))).if
                      (((unsupported)).apply ((((xValueError)).apply ("Invalid address; address parts cannot contain newlines."))))
                    (((unsupported)).apply ((xUnicodeEncodeError)))
                      seq
                        bogusForceDataize.write ((((xnm).xencode)).apply ("ascii"))
                        xnm.write ((((((xHeader)).apply ((xnm))).xencode)).apply)
                      xnm.write ((((((xHeader)).apply ((xnm)) ((xencoding))).xencode)).apply)
                    (((unsupported)).apply ((xUnicodeEncodeError)))
                      bogusForceDataize.write ((((xlocalpart).xencode)).apply ("ascii"))
                      xlocalpart.write ((((((xHeader)).apply ((xlocalpart)) ((xencoding))).xencode)).apply)
                    xdomain.write (((xpunycode)).apply ((xdomain)))
                    xparsed_address.write (((unsupported)).apply ((xAddress)) ((xlocalpart)) ((xdomain)))
                    (((unsupported)).apply ((((xformataddr)).apply ((((unsupported)).apply ((xnm)) (((xparsed_address).xaddr_spec)))))))
            (((unsupported)).apply)
              seq
                xas_string.write
                  [xself xunixfrom xlinesep]
                    memory > xfp
                    memory > xg
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xfp.write (((xStringIO)).apply)
                        xg.write (((unsupported)).apply (((xgenerator).xGenerator)) ((xfp)) (FALSE))
                        (((unsupported)).apply (((xg).xflatten)) ((xself)) ((xunixfrom)) ((xlinesep)))
                        (((unsupported)).apply (((((xfp).xgetvalue)).apply)))
                xas_bytes.write
                  [xself xunixfrom xlinesep]
                    memory > xfp
                    memory > xg
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xfp.write (((xBytesIO)).apply)
                        xg.write (((unsupported)).apply (((xgenerator).xBytesGenerator)) ((xfp)) (FALSE))
                        (((unsupported)).apply (((xg).xflatten)) ((xself)) ((xunixfrom)) ((xlinesep)))
                        (((unsupported)).apply (((((xfp).xgetvalue)).apply)))
            (((unsupported)).apply ((xMIMEMixin)) ((xMIMEMessage)))
              x__setitem__.write
                [xself xname xval]
                  seq > @
                    seq
                      (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xval)))) ((((xforbid_multi_line_headers)).apply ((xname)) ((xval)) ("ascii"))))
                      bogusForceDataize.write ((((xMIMEMessage).x__setitem__)).apply ((xself)) ((xname)) ((xval)))
            (((unsupported)).apply ((xMIMEMixin)) ((xMIMEText)))
              seq
                x__init__.write
                  [xself x_text x_subtype x_charset]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xencoding)) ((x_charset)))
                        (((unsupported)).apply (((xMIMEText).x__init__)) ((xself)) ((x_text)) ((x_subtype)) ((x_charset)))
                x__setitem__.write
                  [xself xname xval]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xval)))) ((((xforbid_multi_line_headers)).apply ((xname)) ((xval)) (((xself).xencoding)))))
                        bogusForceDataize.write ((((xMIMEText).x__setitem__)).apply ((xself)) ((xname)) ((xval)))
                xset_payload.write
                  [xself xpayload xcharset]
                    memory > xhas_long_lines
                    seq > @
                      (((unsupported)).apply)
                        (((xcharset).eq "utf-8").and ((((xisinstance)).apply ((xcharset)) (((xCharset).xCharset))).not)).if
                          seq
                            xhas_long_lines.write (((xany)).apply ((((unsupported)).apply (((((xlen)).apply (((((xline).xencode)).apply))).greater (xRFC5322_EMAIL_LINE_LENGTH_LIMIT))) ((xline)) (((((xpayload).xsplitlines)).apply)))))
                            xcharset.write ((xhas_long_lines).if (xutf8_charset_qp) (xutf8_charset))
                        (((unsupported)).apply (((xMIMEText).xset_payload)) ((xself)) ((xpayload)) ((xcharset)))
            (((unsupported)).apply ((xMIMEMixin)) ((xMIMEMultipart)))
              seq
                x__init__.write
                  [xself x_subtype xboundary x_subparts xencoding]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xencoding)) ((xencoding)))
                        bogusForceDataize.write ((((xMIMEMultipart).x__init__)).apply ((xself)) ((x_subtype)) ((xboundary)) ((x_subparts)) ((((unsupported)).apply ((x_params)))))
                x__setitem__.write
                  [xself xname xval]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xval)))) ((((xforbid_multi_line_headers)).apply ((xname)) ((xval)) (((xself).xencoding)))))
                        bogusForceDataize.write ((((xMIMEMultipart).x__setitem__)).apply ((xself)) ((xname)) ((xval)))
            (((unsupported)).apply)
              seq
                unsupported
                xcontent_subtype.write "plain"
                xmixed_subtype.write "mixed"
                xencoding.write "None: is there a None literal in the EO language?"
                x__init__.write
                  [xself xsubject xbody xfrom_email xto xbcc xconnection xattachments xheaders xcc xreply_to]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (xto).if
                          seq
                            (((xisinstance)).apply ((xto)) ((xstr))).if
                              (((unsupported)).apply ((((xTypeError)).apply ("\"to\" argument must be a list or tuple"))))
                            (((unsupported)).apply (((xself).xto)) ((((xlist)).apply ((xto)))))
                          (((unsupported)).apply (((xself).xto)) ((((unsupported)).apply)))
                        (xcc).if
                          seq
                            (((xisinstance)).apply ((xcc)) ((xstr))).if
                              (((unsupported)).apply ((((xTypeError)).apply ("\"cc\" argument must be a list or tuple"))))
                            (((unsupported)).apply (((xself).xcc)) ((((xlist)).apply ((xcc)))))
                          (((unsupported)).apply (((xself).xcc)) ((((unsupported)).apply)))
                        (xbcc).if
                          seq
                            (((xisinstance)).apply ((xbcc)) ((xstr))).if
                              (((unsupported)).apply ((((xTypeError)).apply ("\"bcc\" argument must be a list or tuple"))))
                            (((unsupported)).apply (((xself).xbcc)) ((((xlist)).apply ((xbcc)))))
                          (((unsupported)).apply (((xself).xbcc)) ((((unsupported)).apply)))
                        (xreply_to).if
                          seq
                            (((xisinstance)).apply ((xreply_to)) ((xstr))).if
                              (((unsupported)).apply ((((xTypeError)).apply ("\"reply_to\" argument must be a list or tuple"))))
                            (((unsupported)).apply (((xself).xreply_to)) ((((xlist)).apply ((xreply_to)))))
                          (((unsupported)).apply (((xself).xreply_to)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xfrom_email)) (((xfrom_email).or ((xsettings).xDEFAULT_FROM_EMAIL))))
                        (((unsupported)).apply (((xself).xsubject)) ((xsubject)))
                        (((unsupported)).apply (((xself).xbody)) (((xbody).or "")))
                        (((unsupported)).apply (((xself).xattachments)) ((((unsupported)).apply)))
                        (xattachments).if
                          (((unsupported)).apply ((xattachment)) ((xattachments)))
                            (((xisinstance)).apply ((xattachment)) ((xMIMEBase))).if
                              bogusForceDataize.write ((((xself).xattach)).apply ((xattachment)))
                              bogusForceDataize.write ((((xself).xattach)).apply ((((unsupported)).apply ((xattachment)))))
                        (((unsupported)).apply (((xself).xextra_headers)) (((xheaders).or (((unsupported)).apply))))
                        (((unsupported)).apply (((xself).xconnection)) ((xconnection)))
                xget_connection.write
                  [xself xfail_silently]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xself).xconnection).not).if
                          (((unsupported)).apply (((xself).xconnection)) ((((unsupported)).apply ((xget_connection)) ((xfail_silently)))))
                        (((unsupported)).apply (((xself).xconnection)))
                xmessage.write
                  [xself]
                    memory > xencoding
                    memory > xmsg
                    memory > xheader_names
                    seq > @
                      seq
                        xencoding.write (((xself).xencoding).or ((xsettings).xDEFAULT_CHARSET))
                        xmsg.write (((xSafeMIMEText)).apply (((xself).xbody)) (((xself).xcontent_subtype)) ((xencoding)))
                        xmsg.write ((((xself).x_create_message)).apply ((xmsg)))
                        (((unsupported)).apply ((((unsupported)).apply ((xmsg)) ("Subject"))) (((xself).xsubject)))
                        (((unsupported)).apply ((((unsupported)).apply ((xmsg)) ("From"))) ((((((xself).xextra_headers).xget)).apply ("From") (((xself).xfrom_email)))))
                        bogusForceDataize.write ((((xself).x_set_list_header_if_not_empty)).apply ((xmsg)) ("To") (((xself).xto)))
                        bogusForceDataize.write ((((xself).x_set_list_header_if_not_empty)).apply ((xmsg)) ("Cc") (((xself).xcc)))
                        bogusForceDataize.write ((((xself).x_set_list_header_if_not_empty)).apply ((xmsg)) ("Reply-To") (((xself).xreply_to)))
                        xheader_names.write (((unsupported)).apply (((((xkey).xlower)).apply)) ((xkey)) (((xself).xextra_headers)))
                        (((unsupported)).apply ("date") ((xheader_names))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmsg)) ("Date"))) ((((unsupported)).apply ((xformatdate)) (((xsettings).xEMAIL_USE_LOCALTIME)))))
                        (((unsupported)).apply ("message-id") ((xheader_names))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmsg)) ("Message-ID"))) ((((unsupported)).apply ((xmake_msgid)) ((xDNS_NAME)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xvalue)))) ((((((xself).xextra_headers).xitems)).apply)))
                          (((((xname).xlower)).apply).neq "from").if
                            (((unsupported)).apply ((((unsupported)).apply ((xmsg)) ((xname)))) ((xvalue)))
                        (((unsupported)).apply ((xmsg)))
                xrecipients.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xemail)) ((xemail)) (((((xself).xto).add ((xself).xcc)).add ((xself).xbcc))) ((xemail)))))
                xsend.write
                  [xself xfail_silently]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        (((((xself).xrecipients)).apply).not).if
                          (((unsupported)).apply (1))
                        (((unsupported)).apply ((((((((xself).xget_connection)).apply ((xfail_silently))).xsend_messages)).apply ((((unsupported)).apply ((xself)))))))
                xattach.write
                  [xself xfilename xcontent xmimetype]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xisinstance)).apply ((xfilename)) ((xMIMEBase))).if
                          seq
                            ((((unsupported)).apply ((xcontent)) ("None: is there a None literal in the EO language?")).or (((unsupported)).apply ((xmimetype)) ("None: is there a None literal in the EO language?"))).if
                              (((unsupported)).apply ((((xValueError)).apply ("content and mimetype must not be given when a MIMEBase instance is provided."))))
                            bogusForceDataize.write (((((xself).xattachments).xappend)).apply ((xfilename)))
                          (((unsupported)).apply ((xcontent)) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply ((((xValueError)).apply ("content must be provided."))))
                            seq
                              xmimetype.write (((xmimetype).or (((unsupported)).apply (((((xmimetypes).xguess_type)).apply ((xfilename)))) (0))).or (xDEFAULT_ATTACHMENT_MIME_TYPE))
                              (((unsupported)).apply ((((unsupported)).apply ((xbasetype)) ((xsubtype)))) (((((xmimetype).xsplit)).apply ("/") (1))))
                              ((xbasetype).eq "text").if
                                (((xisinstance)).apply ((xcontent)) ((xbytes))).if
                                  (((unsupported)).apply ((xUnicodeDecodeError)))
                                    xcontent.write ((((xcontent).xdecode)).apply)
                                    xmimetype.write (xDEFAULT_ATTACHMENT_MIME_TYPE)
                              bogusForceDataize.write (((((xself).xattachments).xappend)).apply ((((unsupported)).apply ((xfilename)) ((xcontent)) ((xmimetype)))))
                xattach_file.write
                  [xself xpath xmimetype]
                    memory > xcontent
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xpath.write (((xPath)).apply ((xpath)))
                        (((unsupported)).apply (((((xpath).xopen)).apply ("rb"))) ((xfile)))
                          seq
                            xcontent.write ((((xfile).xread)).apply)
                            bogusForceDataize.write ((((xself).xattach)).apply (((xpath).xname)) ((xcontent)) ((xmimetype)))
                x_create_message.write
                  [xself xmsg]
                    seq > @
                      (((unsupported)).apply (((((xself).x_create_attachments)).apply ((xmsg)))))
                x_create_attachments.write
                  [xself xmsg]
                    memory > xencoding
                    memory > xbody_msg
                    seq > @
                      seq
                        ((xself).xattachments).if
                          seq
                            xencoding.write (((xself).xencoding).or ((xsettings).xDEFAULT_CHARSET))
                            xbody_msg.write (xmsg)
                            xmsg.write (((unsupported)).apply ((xSafeMIMEMultipart)) (((xself).xmixed_subtype)) ((xencoding)))
                            (((xself).xbody).or ((((xbody_msg).xis_multipart)).apply)).if
                              bogusForceDataize.write ((((xmsg).xattach)).apply ((xbody_msg)))
                            (((unsupported)).apply ((xattachment)) (((xself).xattachments)))
                              (((xisinstance)).apply ((xattachment)) ((xMIMEBase))).if
                                bogusForceDataize.write ((((xmsg).xattach)).apply ((xattachment)))
                                bogusForceDataize.write ((((xmsg).xattach)).apply (((((xself).x_create_attachment)).apply ((((unsupported)).apply ((xattachment)))))))
                        (((unsupported)).apply ((xmsg)))
                x_create_mime_attachment.write
                  [xself xcontent xmimetype]
                    memory > xencoding
                    memory > xattachment
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xbasetype)) ((xsubtype)))) (((((xmimetype).xsplit)).apply ("/") (1))))
                        ((xbasetype).eq "text").if
                          seq
                            xencoding.write (((xself).xencoding).or ((xsettings).xDEFAULT_CHARSET))
                            xattachment.write (((xSafeMIMEText)).apply ((xcontent)) ((xsubtype)) ((xencoding)))
                          (((xbasetype).eq "message").and ((xsubtype).eq "rfc822")).if
                            seq
                              (((xisinstance)).apply ((xcontent)) ((xEmailMessage))).if
                                xcontent.write ((((xcontent).xmessage)).apply)
                                ((((xisinstance)).apply ((xcontent)) ((xMessage))).not).if
                                  xcontent.write (((xmessage_from_string)).apply ((((xforce_str)).apply ((xcontent)))))
                              xattachment.write (((xSafeMIMEMessage)).apply ((xcontent)) ((xsubtype)))
                            seq
                              xattachment.write (((xMIMEBase)).apply ((xbasetype)) ((xsubtype)))
                              bogusForceDataize.write ((((xattachment).xset_payload)).apply ((xcontent)))
                              bogusForceDataize.write ((((xEncoders).xencode_base64)).apply ((xattachment)))
                        (((unsupported)).apply ((xattachment)))
                x_create_attachment.write
                  [xself xfilename xcontent xmimetype]
                    memory > xattachment
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xattachment.write ((((xself).x_create_mime_attachment)).apply ((xcontent)) ((xmimetype)))
                        (xfilename).if
                          seq
                            (((unsupported)).apply ((xUnicodeEncodeError)))
                              bogusForceDataize.write ((((xfilename).xencode)).apply ("ascii"))
                              xfilename.write (((unsupported)).apply ("utf-8") ("") ((xfilename)))
                            (((unsupported)).apply (((xattachment).xadd_header)) ("Content-Disposition") ("attachment") ((xfilename)))
                        (((unsupported)).apply ((xattachment)))
                x_set_list_header_if_not_empty.write
                  [xself xmsg xheader xvalues]
                    memory > xvalue
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (xvalues).if
                          seq
                            (((unsupported)).apply ((xKeyError)))
                              xvalue.write (((unsupported)).apply (((xself).xextra_headers)) ((xheader)))
                              xvalue.write (((", ".xjoin)).apply ((((unsupported)).apply ((((xstr)).apply ((xv)))) ((xv)) ((xvalues)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xmsg)) ((xheader)))) ((xvalue)))
            (((unsupported)).apply ((xEmailMessage)))
              seq
                (((unsupported)).apply)
                xalternative_subtype.write "alternative"
                x__init__.write
                  [xself xsubject xbody xfrom_email xto xbcc xconnection xattachments xheaders xalternatives xcc xreply_to]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xsubject)) ((xbody)) ((xfrom_email)) ((xto)) ((xbcc)) ((xconnection)) ((xattachments)) ((xheaders)) ((xcc)) ((xreply_to)))
                        (((unsupported)).apply (((xself).xalternatives)) (((xalternatives).or (((unsupported)).apply))))
                xattach_alternative.write
                  [xself xcontent xmimetype]
                    seq > @
                      seq
                        unsupported
                        ((((unsupported)).apply ((xcontent)) ("None: is there a None literal in the EO language?")).or (((unsupported)).apply ((xmimetype)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Both content and mimetype must be provided."))))
                        bogusForceDataize.write (((((xself).xalternatives).xappend)).apply ((((unsupported)).apply ((xcontent)) ((xmimetype)))))
                x_create_message.write
                  [xself xmsg]
                    seq > @
                      (((unsupported)).apply (((((xself).x_create_attachments)).apply (((((xself).x_create_alternatives)).apply ((xmsg)))))))
                x_create_alternatives.write
                  [xself xmsg]
                    memory > xencoding
                    memory > xbody_msg
                    seq > @
                      seq
                        xencoding.write (((xself).xencoding).or ((xsettings).xDEFAULT_CHARSET))
                        ((xself).xalternatives).if
                          seq
                            xbody_msg.write (xmsg)
                            xmsg.write (((unsupported)).apply ((xSafeMIMEMultipart)) (((xself).xalternative_subtype)) ((xencoding)))
                            ((xself).xbody).if
                              bogusForceDataize.write ((((xmsg).xattach)).apply ((xbody_msg)))
                            (((unsupported)).apply ((xalternative)) (((xself).xalternatives)))
                              bogusForceDataize.write ((((xmsg).xattach)).apply (((((xself).x_create_mime_attachment)).apply ((((unsupported)).apply ((xalternative)))))))
                        (((unsupported)).apply ((xmsg)))