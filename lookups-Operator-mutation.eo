memory > xValueError
memory > xhash
memory > xStartsWith
memory > xEndsWith
memory > xlhs_params
memory > xrhs_params
memory > xsqls_params
memory > xIContains
memory > xGreaterThan
memory > xEmptyResultSet
memory > xWhen
memory > xlist
memory > xIExact
memory > xFunc
memory > xBooleanField
memory > xUUIDField
memory > xLessThanOrEqual
memory > xIntegerFieldFloatRounding
memory > xCase
memory > xBuiltinLookup
memory > xRegex
memory > xrange
memory > xmath
memory > xfinish
memory > xsqls
memory > xCharField
memory > xNotImplementedError
memory > x_
memory > xQuery
memory > xField
memory > xstart
memory > xparam
memory > xrhs
memory > xContains
memory > xIntegerField
memory > xp
memory > xExpression
memory > xRegisterLookupMixin
memory > xlhs_sql
memory > xExact
memory > xtype
memory > xValue
memory > xr
memory > xhasattr
memory > xFieldGetDbPrepValueMixin
memory > xReplace
memory > xparams
memory > xUUIDTextMixin
memory > xsuper
memory > xOrderedSet
memory > xbool
memory > xDateTimeField
memory > xtuple
memory > xNotImplemented
memory > xGreaterThanOrEqual
memory > xExtractIsoYear
memory > xtransform
memory > xfloat
memory > xitertools
memory > xPatternLookup
memory > xIEndsWith
memory > xmake_hashable
memory > xgetattr
memory > xv
memory > xIStartsWith
memory > xsql
memory > xLookup
memory > xLessThan
memory > xzip
memory > xsource
memory > xFieldGetDbPrepValueIterableMixin
memory > xYearLookup
memory > xoffset
memory > xisinstance
memory > xlen
memory > xTypeError
memory > xsql_params
[] > lookups
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xget_direct_rhs_sql
        memory > xcan_use_none_as_rhs
        memory > xresolve_expression_parameter
        memory > xprocess_lhs
        memory > xrhs_is_direct_value
        memory > xget_group_by_cols
        memory > xget_prep_lhs
        memory > xidentity
        memory > xyear_lookup_bounds
        memory > xget_db_prep_lookup_value_is_iterable
        memory > xprepare_rhs
        memory > xget_bound_params
        memory > xas_oracle
        memory > x__eq__
        memory > x__repr__
        memory > xapply_bilateral_transforms
        memory > xget_db_prep_lookup
        memory > xparam_pattern
        memory > xget_bilateral_transforms
        memory > xget_prep_lookup
        memory > xlhs
        memory > xbilateral
        memory > xas_postgresql
        memory > xget_source_expressions
        memory > xarity
        memory > xas_sql
        memory > xset_source_expressions
        memory > xget_rhs_op
        memory > xlookup_name
        memory > xselect_format
        memory > x__init__
        memory > xsplit_parameter_list_as_sql
        memory > xbatch_process_rhs
        memory > xprocess_rhs
        memory > xoutput_field
        memory > x__hash__
        memory > xresolve_expression
        memory > xpostgres_operator
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply ((xExpression)))
              seq
                xlookup_name.write "None: is there a None literal in the EO language?"
                xprepare_rhs.write TRUE
                xcan_use_none_as_rhs.write FALSE
                x__init__.write
                  [xself xlhs xrhs]
                    memory > xbilateral_transforms
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xlhs)) (((xself).xrhs)))) ((((unsupported)).apply ((xlhs)) ((xrhs)))))
                        (((unsupported)).apply (((xself).xrhs)) (((((xself).xget_prep_lookup)).apply)))
                        (((unsupported)).apply (((xself).xlhs)) (((((xself).xget_prep_lhs)).apply)))
                        (((xhasattr)).apply (((xself).xlhs)) ("get_bilateral_transforms")).if
                          xbilateral_transforms.write (((((xself).xlhs).xget_bilateral_transforms)).apply)
                          xbilateral_transforms.write (((unsupported)).apply)
                        (xbilateral_transforms).if
                          seq
                            (((unsupported)).apply)
                            (((xisinstance)).apply ((xrhs)) ((xQuery))).if
                              (((unsupported)).apply ((((xNotImplementedError)).apply ("Bilateral transformations on nested querysets are not implemented."))))
                        (((unsupported)).apply (((xself).xbilateral_transforms)) ((xbilateral_transforms)))
                xapply_bilateral_transforms.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xtransform)) (((xself).xbilateral_transforms)))
                          xvalue.write (((xtransform)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("{self.__class__.__name__}({self.lhs!r}, {self.rhs!r})"))
                xbatch_process_rhs.write
                  [xself xcompiler xconnection xrhs]
                    memory > xvalue
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xrhs)) ("None: is there a None literal in the EO language?")).if
                          xrhs.write ((xself).xrhs)
                        ((xself).xbilateral_transforms).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xsqls)) ((xsqls_params)))) ((((unsupported)).apply ((((unsupported)).apply)) ((((unsupported)).apply)))))
                            (((unsupported)).apply ((xp)) ((xrhs)))
                              seq
                                xvalue.write (((unsupported)).apply ((xValue)) ((xp)) ((((xself).xlhs).xoutput_field)))
                                xvalue.write ((((xself).xapply_bilateral_transforms)).apply ((xvalue)))
                                xvalue.write ((((xvalue).xresolve_expression)).apply (((xcompiler).xquery)))
                                (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xsql_params)))) (((((xcompiler).xcompile)).apply ((xvalue)))))
                                bogusForceDataize.write ((((xsqls).xappend)).apply ((xsql)))
                                bogusForceDataize.write ((((xsqls_params).xextend)).apply ((xsql_params)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xparams)))) (((((xself).xget_db_prep_lookup)).apply ((xrhs)) ((xconnection)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xsqls)) ((xsqls_params)))) ((((unsupported)).apply (((((unsupported)).apply ("%s")).mul (((xlen)).apply ((xparams))))) ((xparams)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xsqls)) ((xsqls_params)))))
                xget_source_expressions.write
                  [xself]
                    seq > @
                      seq
                        ((((xself).xrhs_is_direct_value)).apply).if
                          (((unsupported)).apply ((((unsupported)).apply (((xself).xlhs)))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xlhs)) (((xself).xrhs)))))
                xset_source_expressions.write
                  [xself xnew_exprs]
                    seq > @
                      ((((xlen)).apply ((xnew_exprs))).eq 1).if
                        (((unsupported)).apply (((xself).xlhs)) ((((unsupported)).apply ((xnew_exprs)) (0))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xlhs)) (((xself).xrhs)))) ((xnew_exprs)))
                xget_prep_lookup.write
                  [xself]
                    seq > @
                      seq
                        ((((xself).xprepare_rhs).not).or (((xhasattr)).apply (((xself).xrhs)) ("resolve_expression"))).if
                          (((unsupported)).apply (((xself).xrhs)))
                        (((xhasattr)).apply (((xself).xlhs)) ("output_field")).if
                          (((xhasattr)).apply ((((xself).xlhs).xoutput_field)) ("get_prep_value")).if
                            (((unsupported)).apply (((((((xself).xlhs).xoutput_field).xget_prep_value)).apply (((xself).xrhs)))))
                          ((((xself).xrhs_is_direct_value)).apply).if
                            (((unsupported)).apply ((((xValue)).apply (((xself).xrhs)))))
                        (((unsupported)).apply (((xself).xrhs)))
                xget_prep_lhs.write
                  [xself]
                    seq > @
                      seq
                        (((xhasattr)).apply (((xself).xlhs)) ("resolve_expression")).if
                          (((unsupported)).apply (((xself).xlhs)))
                        (((unsupported)).apply ((((xValue)).apply (((xself).xlhs)))))
                xget_db_prep_lookup.write
                  [xself xvalue xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ("%s") ((((unsupported)).apply ((xvalue)))))))
                xprocess_lhs.write
                  [xself xcompiler xconnection xlhs]
                    memory > xsql
                    seq > @
                      (((unsupported)).apply)
                        xlhs.write ((xlhs).or ((xself).xlhs))
                        (((xhasattr)).apply ((xlhs)) ("resolve_expression")).if
                          xlhs.write ((((xlhs).xresolve_expression)).apply (((xcompiler).xquery)))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xcompiler).xcompile)).apply ((xlhs)))))
                        (((xisinstance)).apply ((xlhs)) ((xLookup))).if
                          xsql.write "({sql})"
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                xprocess_rhs.write
                  [xself xcompiler xconnection]
                    memory > xsql
                    memory > xvalue
                    seq > @
                      seq
                        xvalue.write ((xself).xrhs)
                        ((xself).xbilateral_transforms).if
                          seq
                            ((((xself).xrhs_is_direct_value)).apply).if
                              xvalue.write (((unsupported)).apply ((xValue)) ((xvalue)) ((((xself).xlhs).xoutput_field)))
                            xvalue.write ((((xself).xapply_bilateral_transforms)).apply ((xvalue)))
                            xvalue.write ((((xvalue).xresolve_expression)).apply (((xcompiler).xquery)))
                        (((xhasattr)).apply ((xvalue)) ("as_sql")).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xcompiler).xcompile)).apply ((xvalue)))))
                            ((xsql).and ((((unsupported)).apply ((xsql)) (0)).neq "(")).if
                              xsql.write ("(%s)".mod (xsql))
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                          (((unsupported)).apply (((((xself).xget_db_prep_lookup)).apply ((xvalue)) ((xconnection)))))
                xrhs_is_direct_value.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((((xhasattr)).apply (((xself).xrhs)) ("as_sql")).not)))
                xget_group_by_cols.write
                  [xself xalias]
                    memory > xcols
                    seq > @
                      (((unsupported)).apply)
                        xcols.write (((unsupported)).apply)
                        (((unsupported)).apply ((xsource)) (((((xself).xget_source_expressions)).apply)))
                          bogusForceDataize.write ((((xcols).xextend)).apply (((((xsource).xget_group_by_cols)).apply)))
                        (((unsupported)).apply ((xcols)))
                xas_oracle.write
                  [xself xcompiler xconnection]
                    memory > xexprs
                    memory > xexpr
                    memory > xlookup
                    memory > xwrapped
                    seq > @
                      seq
                        xwrapped.write FALSE
                        xexprs.write (((unsupported)).apply)
                        (((unsupported)).apply ((xexpr)) ((((unsupported)).apply (((xself).xlhs)) (((xself).xrhs)))))
                          seq
                            (((((xconnection).xops).xconditional_expression_supported_in_where_clause)).apply ((xexpr))).if
                              seq
                                xexpr.write (((unsupported)).apply ((xCase)) ((((unsupported)).apply ((xWhen)) ((xexpr)) (TRUE))) (FALSE))
                                xwrapped.write TRUE
                            bogusForceDataize.write ((((xexprs).xappend)).apply ((xexpr)))
                        xlookup.write ((xwrapped).if (((((xtype)).apply ((xself)))).apply ((((unsupported)).apply ((xexprs))))) (xself))
                        (((unsupported)).apply (((((xlookup).xas_sql)).apply ((xcompiler)) ((xconnection)))))
                xoutput_field.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xBooleanField)).apply)))
                xidentity.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).x__class__)) (((xself).xlhs)) (((xself).xrhs)))))
                x__eq__.write
                  [xself xother]
                    seq > @
                      seq
                        ((((xisinstance)).apply ((xother)) ((xLookup))).not).if
                          (((unsupported)).apply ((xNotImplemented)))
                        (((unsupported)).apply ((((xself).xidentity).eq ((xother).xidentity))))
                x__hash__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xhash)).apply ((((xmake_hashable)).apply (((xself).xidentity)))))))
                xresolve_expression.write
                  [xself xquery xallow_joins xreuse xsummarize xfor_save]
                    memory > xc
                    seq > @
                      (((unsupported)).apply)
                        xc.write ((((xself).xcopy)).apply)
                        (((unsupported)).apply (((xc).xis_summary)) ((xsummarize)))
                        (((unsupported)).apply (((xc).xlhs)) ((((((xself).xlhs).xresolve_expression)).apply ((xquery)) ((xallow_joins)) ((xreuse)) ((xsummarize)) ((xfor_save)))))
                        (((unsupported)).apply (((xc).xrhs)) ((((((xself).xrhs).xresolve_expression)).apply ((xquery)) ((xallow_joins)) ((xreuse)) ((xsummarize)) ((xfor_save)))))
                        (((unsupported)).apply ((xc)))
                xselect_format.write
                  [xself xcompiler xsql xparams]
                    seq > @
                      seq
                        (((((xcompiler).xconnection).xfeatures).xsupports_boolean_expr_in_select_clause).not).if
                          xsql.write "CASE WHEN {sql} THEN 1 ELSE 0 END"
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
            (((unsupported)).apply ((xRegisterLookupMixin)) ((xFunc)))
              seq
                (((unsupported)).apply)
                xbilateral.write FALSE
                xarity.write 1
                xlhs.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((((xself).xget_source_expressions)).apply)) (0))))
                xget_bilateral_transforms.write
                  [xself]
                    memory > xbilateral_transforms
                    seq > @
                      seq
                        (((xhasattr)).apply (((xself).xlhs)) ("get_bilateral_transforms")).if
                          xbilateral_transforms.write (((((xself).xlhs).xget_bilateral_transforms)).apply)
                          xbilateral_transforms.write (((unsupported)).apply)
                        ((xself).xbilateral).if
                          bogusForceDataize.write ((((xbilateral_transforms).xappend)).apply (((xself).x__class__)))
                        (((unsupported)).apply ((xbilateral_transforms)))
            (((unsupported)).apply ((xLookup)))
              seq
                xprocess_lhs.write
                  [xself xcompiler xconnection xlhs]
                    memory > xfield_internal_type
                    memory > xlhs_sql
                    memory > xdb_type
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((xparams)))) (((((((xsuper)).apply).xprocess_lhs)).apply ((xcompiler)) ((xconnection)) ((xlhs)))))
                        xfield_internal_type.write ((((((xself).xlhs).xoutput_field).xget_internal_type)).apply)
                        xdb_type.write (((unsupported)).apply (((((xself).xlhs).xoutput_field).xdb_type)) ((xconnection)))
                        xlhs_sql.write ((((((xconnection).xops).xfield_cast_sql)).apply ((xdb_type)) ((xfield_internal_type))).mod (xlhs_sql))
                        xlhs_sql.write ((((((xconnection).xops).xlookup_cast)).apply (((xself).xlookup_name)) ((xfield_internal_type))).mod (xlhs_sql))
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((((xlist)).apply ((xparams)))))))
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xrhs_sql
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((xparams)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs_sql)) ((xrhs_params)))) (((((xself).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        bogusForceDataize.write ((((xparams).xextend)).apply ((xrhs_params)))
                        xrhs_sql.write ((((xself).xget_rhs_op)).apply ((xconnection)) ((xrhs_sql)))
                        (((unsupported)).apply ((((unsupported)).apply (("%s %s".mod (((unsupported)).apply ((xlhs_sql)) ((xrhs_sql))))) ((xparams)))))
                xget_rhs_op.write
                  [xself xconnection xrhs]
                    seq > @
                      (((unsupported)).apply (((((unsupported)).apply (((xconnection).xoperators)) (((xself).xlookup_name))).mod (xrhs))))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xget_db_prep_lookup_value_is_iterable.write FALSE
                xget_db_prep_lookup.write
                  [xself xvalue xconnection]
                    memory > xfield
                    memory > xget_db_prep_value
                    seq > @
                      seq
                        xfield.write (((xgetattr)).apply ((((xself).xlhs).xoutput_field)) ("target_field") ("None: is there a None literal in the EO language?"))
                        xget_db_prep_value.write ((((xgetattr)).apply ((xfield)) ("get_db_prep_value") ("None: is there a None literal in the EO language?")).or ((((xself).xlhs).xoutput_field).xget_db_prep_value))
                        (((unsupported)).apply ((((unsupported)).apply ("%s") ((((xself).xget_db_prep_lookup_value_is_iterable).if (((unsupported)).apply ((((unsupported)).apply ((xget_db_prep_value)) ((xv)) ((xconnection)) (TRUE))) ((xv)) ((xvalue))) (((unsupported)).apply ((((unsupported)).apply ((xget_db_prep_value)) ((xvalue)) ((xconnection)) (TRUE)))))))))
            (((unsupported)).apply ((xFieldGetDbPrepValueMixin)))
              seq
                (((unsupported)).apply)
                xget_db_prep_lookup_value_is_iterable.write TRUE
                xget_prep_lookup.write
                  [xself]
                    memory > xprepared_values
                    memory > xrhs_value
                    seq > @
                      seq
                        (((xhasattr)).apply (((xself).xrhs)) ("resolve_expression")).if
                          (((unsupported)).apply (((xself).xrhs)))
                        xprepared_values.write (((unsupported)).apply)
                        (((unsupported)).apply ((xrhs_value)) (((xself).xrhs)))
                          seq
                            (((xhasattr)).apply ((xrhs_value)) ("resolve_expression")).if
                              (((xself).xprepare_rhs).and (((xhasattr)).apply ((((xself).xlhs).xoutput_field)) ("get_prep_value"))).if
                                xrhs_value.write ((((((xself).xlhs).xoutput_field).xget_prep_value)).apply ((xrhs_value)))
                            bogusForceDataize.write ((((xprepared_values).xappend)).apply ((xrhs_value)))
                        (((unsupported)).apply ((xprepared_values)))
                xprocess_rhs.write
                  [xself xcompiler xconnection]
                    seq > @
                      ((((xself).xrhs_is_direct_value)).apply).if
                        (((unsupported)).apply (((((xself).xbatch_process_rhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                xresolve_expression_parameter.write
                  [xself xcompiler xconnection xsql xparam]
                    memory > xparams
                    seq > @
                      seq
                        xparams.write (((unsupported)).apply ((xparam)))
                        (((xhasattr)).apply ((xparam)) ("resolve_expression")).if
                          xparam.write ((((xparam).xresolve_expression)).apply (((xcompiler).xquery)))
                        (((xhasattr)).apply ((xparam)) ("as_sql")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xcompiler).xcompile)).apply ((xparam)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                xbatch_process_rhs.write
                  [xself xcompiler xconnection xrhs]
                    memory > xparams
                    memory > xpre_processed
                    seq > @
                      (((unsupported)).apply)
                        xpre_processed.write ((((((xsuper)).apply).xbatch_process_rhs)).apply ((xcompiler)) ((xconnection)) ((xrhs)))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((xzip)).apply ((((unsupported)).apply ((((unsupported)).apply (((((xself).xresolve_expression_parameter)).apply ((xcompiler)) ((xconnection)) ((xsql)) ((xparam)))) ((((unsupported)).apply ((xsql)) ((xparam)))) ((((xzip)).apply ((((unsupported)).apply ((xpre_processed)))))))))))))
                        xparams.write (((((xitertools).xchain).xfrom_iterable)).apply ((xparams)))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((((xtuple)).apply ((xparams)))))))
            (((unsupported)).apply ((xFieldGetDbPrepValueMixin)) ((xLookup)))
              seq
                unsupported
                xpostgres_operator.write "None: is there a None literal in the EO language?"
                xas_postgresql.write
                  [xself xcompiler xconnection]
                    memory > xparams
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((xself).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        xparams.write ((((xtuple)).apply ((xlhs_params))).sub (((xtuple)).apply ((xrhs_params))))
                        (((unsupported)).apply ((((unsupported)).apply (("%s %s %s".mod (((unsupported)).apply ((xlhs)) (((xself).xpostgres_operator)) ((xrhs))))) ((xparams)))))
            (((unsupported)).apply ((xFieldGetDbPrepValueMixin)) ((xBuiltinLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "exact"
                xget_prep_lookup.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xisinstance)).apply (((xself).xrhs)) ((xQuery))).if
                          (((((xself).xrhs).xhas_limit_one)).apply).if
                            ((((xself).xrhs).xhas_select_fields).not).if
                              seq
                                bogusForceDataize.write (((((xself).xrhs).xclear_select_clause)).apply)
                                bogusForceDataize.write (((((xself).xrhs).xadd_fields)).apply ((((unsupported)).apply ("pk"))))
                            (((unsupported)).apply ((((xValueError)).apply ("The QuerySet value for an exact lookup must be limited to one result using slicing."))))
                        (((unsupported)).apply (((((((xsuper)).apply).xget_prep_lookup)).apply)))
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xtemplate
                    seq > @
                      seq
                        (((((xisinstance)).apply (((xself).xrhs)) ((xbool))).and (((xgetattr)).apply (((xself).xlhs)) ("conditional") (FALSE))).and (((((xconnection).xops).xconditional_expression_supported_in_where_clause)).apply (((xself).xlhs)))).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((xparams)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                            xtemplate.write (((xself).xrhs).if "%s" "NOT %s")
                            (((unsupported)).apply ((((unsupported)).apply (((xtemplate).mod (xlhs_sql))) ((xparams)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xas_sql)).apply ((xcompiler)) ((xconnection)))))
            (((unsupported)).apply ((xBuiltinLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "iexact"
                xprepare_rhs.write FALSE
                xprocess_rhs.write
                  [xself xqn xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xparams)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xqn)) ((xconnection)))))
                        (xparams).if
                          (((unsupported)).apply ((((unsupported)).apply ((xparams)) (0))) ((((((xconnection).xops).xprep_for_iexact_query)).apply ((((unsupported)).apply ((xparams)) (0))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xparams)))))
            (((unsupported)).apply ((xFieldGetDbPrepValueMixin)) ((xBuiltinLookup)) (((xField).xregister_lookup)))
              xlookup_name.write "gt"
            (((unsupported)).apply ((xFieldGetDbPrepValueMixin)) ((xBuiltinLookup)) (((xField).xregister_lookup)))
              xlookup_name.write "gte"
            (((unsupported)).apply ((xFieldGetDbPrepValueMixin)) ((xBuiltinLookup)) (((xField).xregister_lookup)))
              xlookup_name.write "lt"
            (((unsupported)).apply ((xFieldGetDbPrepValueMixin)) ((xBuiltinLookup)) (((xField).xregister_lookup)))
              xlookup_name.write "lte"
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xget_prep_lookup.write
                  [xself]
                    seq > @
                      seq
                        (((xisinstance)).apply (((xself).xrhs)) ((xfloat))).if
                          (((unsupported)).apply (((xself).xrhs)) (((((xmath).xceil)).apply (((xself).xrhs)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xget_prep_lookup)).apply)))
            (((unsupported)).apply ((xIntegerFieldFloatRounding)) ((xGreaterThanOrEqual)) (((xIntegerField).xregister_lookup)))
            (((unsupported)).apply ((xIntegerFieldFloatRounding)) ((xLessThan)) (((xIntegerField).xregister_lookup)))
            (((unsupported)).apply ((xFieldGetDbPrepValueIterableMixin)) ((xBuiltinLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "in"
                xget_prep_lookup.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xisinstance)).apply (((xself).xrhs)) ((xQuery))).if
                          seq
                            (((unsupported)).apply ((((xself).xrhs).xclear_ordering)) (TRUE))
                            ((((xself).xrhs).xhas_select_fields).not).if
                              seq
                                bogusForceDataize.write (((((xself).xrhs).xclear_select_clause)).apply)
                                bogusForceDataize.write (((((xself).xrhs).xadd_fields)).apply ((((unsupported)).apply ("pk"))))
                        (((unsupported)).apply (((((((xsuper)).apply).xget_prep_lookup)).apply)))
                xprocess_rhs.write
                  [xself xcompiler xconnection]
                    memory > xdb_rhs
                    memory > xrhs
                    memory > xplaceholder
                    seq > @
                      seq
                        xdb_rhs.write (((xgetattr)).apply (((xself).xrhs)) ("_db") ("None: is there a None literal in the EO language?"))
                        ((((unsupported)).apply ((xdb_rhs)) ("None: is there a None literal in the EO language?")).and ((xdb_rhs).neq ((xconnection).xalias))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Subqueries aren't allowed across different databases. Force the inner query to be evaluated using `list(inner_query)`."))))
                        ((((xself).xrhs_is_direct_value)).apply).if
                          seq
                            (((unsupported)).apply ((xTypeError)))
                              seq
                                xrhs.write (((xOrderedSet)).apply (((xself).xrhs)))
                                bogusForceDataize.write ((((xrhs).xdiscard)).apply ("None: is there a None literal in the EO language?"))
                              xrhs.write (((unsupported)).apply ((xr)) ((xr)) (((xself).xrhs)) ((((unsupported)).apply ((xr)) ("None: is there a None literal in the EO language?"))))
                            ((xrhs).not).if
                              (((unsupported)).apply ((xEmptyResultSet)))
                            (((unsupported)).apply ((((unsupported)).apply ((xsqls)) ((xsqls_params)))) (((((xself).xbatch_process_rhs)).apply ((xcompiler)) ((xconnection)) ((xrhs)))))
                            xplaceholder.write (("(".sub (((", ".xjoin)).apply ((xsqls)))).sub ")")
                            (((unsupported)).apply ((((unsupported)).apply ((xplaceholder)) ((xsqls_params)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                xget_rhs_op.write
                  [xself xconnection xrhs]
                    seq > @
                      (((unsupported)).apply (("IN %s".mod (xrhs))))
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xmax_in_list_size
                    seq > @
                      seq
                        xmax_in_list_size.write (((((xconnection).xops).xmax_in_list_size)).apply)
                        ((((((xself).xrhs_is_direct_value)).apply).and (xmax_in_list_size)).and ((((xlen)).apply (((xself).xrhs))).greater (xmax_in_list_size))).if
                          (((unsupported)).apply (((((xself).xsplit_parameter_list_as_sql)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xas_sql)).apply ((xcompiler)) ((xconnection)))))
                xsplit_parameter_list_as_sql.write
                  [xself xcompiler xconnection]
                    memory > xsqls_params
                    memory > xmax_in_list_size
                    memory > xsqls
                    memory > xparam_group
                    memory > xparams
                    memory > xin_clause_elements
                    seq > @
                      seq
                        xmax_in_list_size.write (((((xconnection).xops).xmax_in_list_size)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((xself).xbatch_process_rhs)).apply ((xcompiler)) ((xconnection)))))
                        xin_clause_elements.write (((unsupported)).apply ("("))
                        xparams.write (((unsupported)).apply)
                        (((unsupported)).apply ((xoffset)) ((((xrange)).apply (0) ((((xlen)).apply ((xrhs_params)))) ((xmax_in_list_size)))))
                          seq
                            ((xoffset).greater 0).if
                              bogusForceDataize.write ((((xin_clause_elements).xappend)).apply (" OR "))
                            bogusForceDataize.write ((((xin_clause_elements).xappend)).apply (("%s IN (".mod (xlhs))))
                            bogusForceDataize.write ((((xparams).xextend)).apply ((xlhs_params)))
                            xsqls.write (((unsupported)).apply ((xrhs)) ((((unsupported)).apply ((xoffset)) (((xoffset).sub (xmax_in_list_size))))))
                            xsqls_params.write (((unsupported)).apply ((xrhs_params)) ((((unsupported)).apply ((xoffset)) (((xoffset).sub (xmax_in_list_size))))))
                            xparam_group.write (((", ".xjoin)).apply ((xsqls)))
                            bogusForceDataize.write ((((xin_clause_elements).xappend)).apply ((xparam_group)))
                            bogusForceDataize.write ((((xin_clause_elements).xappend)).apply (")"))
                            bogusForceDataize.write ((((xparams).xextend)).apply ((xsqls_params)))
                        bogusForceDataize.write ((((xin_clause_elements).xappend)).apply (")"))
                        (((unsupported)).apply ((((unsupported)).apply (((("".xjoin)).apply ((xin_clause_elements)))) ((xparams)))))
            (((unsupported)).apply ((xBuiltinLookup)))
              seq
                xparam_pattern.write "%%%s%%"
                xprepare_rhs.write FALSE
                xget_rhs_op.write
                  [xself xconnection xrhs]
                    memory > xpattern
                    seq > @
                      ((((xhasattr)).apply (((xself).xrhs)) ("as_sql")).or ((xself).xbilateral_transforms)).if
                        seq
                          xpattern.write ((((((unsupported)).apply (((xconnection).xpattern_ops)) (((xself).xlookup_name))).xformat)).apply (((xconnection).xpattern_esc)))
                          (((unsupported)).apply (((((xpattern).xformat)).apply ((xrhs)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xget_rhs_op)).apply ((xconnection)) ((xrhs)))))
                xprocess_rhs.write
                  [xself xqn xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xparams)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xqn)) ((xconnection)))))
                        ((((((xself).xrhs_is_direct_value)).apply).and (xparams)).and (((xself).xbilateral_transforms).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xparams)) (0))) ((((xself).xparam_pattern).mod (((((xconnection).xops).xprep_for_like_query)).apply ((((unsupported)).apply ((xparams)) (0)))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xparams)))))
            (((unsupported)).apply ((xPatternLookup)) (((xField).xregister_lookup)))
              xlookup_name.write "contains"
            (((unsupported)).apply ((xContains)) (((xField).xregister_lookup)))
              xlookup_name.write "icontains"
            (((unsupported)).apply ((xPatternLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "startswith"
                xparam_pattern.write "%s%%"
            (((unsupported)).apply ((xStartsWith)) (((xField).xregister_lookup)))
              xlookup_name.write "istartswith"
            (((unsupported)).apply ((xPatternLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "endswith"
                xparam_pattern.write "%%%s"
            (((unsupported)).apply ((xEndsWith)) (((xField).xregister_lookup)))
              xlookup_name.write "iendswith"
            (((unsupported)).apply ((xFieldGetDbPrepValueIterableMixin)) ((xBuiltinLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "range"
                xget_rhs_op.write
                  [xself xconnection xrhs]
                    seq > @
                      (((unsupported)).apply (("BETWEEN %s AND %s".mod (((unsupported)).apply ((((unsupported)).apply ((xrhs)) (0))) ((((unsupported)).apply ((xrhs)) (1)))))))
            (((unsupported)).apply ((xBuiltinLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "isnull"
                xprepare_rhs.write FALSE
                xas_sql.write
                  [xself xcompiler xconnection]
                    seq > @
                      seq
                        ((((xisinstance)).apply (((xself).xrhs)) ((xbool))).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("The QuerySet value for an isnull lookup must be True or False."))))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xcompiler).xcompile)).apply (((xself).xlhs)))))
                        ((xself).xrhs).if
                          (((unsupported)).apply ((((unsupported)).apply (("%s IS NULL".mod (xsql))) ((xparams)))))
                          (((unsupported)).apply ((((unsupported)).apply (("%s IS NOT NULL".mod (xsql))) ((xparams)))))
            (((unsupported)).apply ((xBuiltinLookup)) (((xField).xregister_lookup)))
              seq
                xlookup_name.write "regex"
                xprepare_rhs.write FALSE
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xsql_template
                    seq > @
                      (((unsupported)).apply (((xself).xlookup_name)) (((xconnection).xoperators))).if
                        (((unsupported)).apply (((((((xsuper)).apply).xas_sql)).apply ((xcompiler)) ((xconnection)))))
                        seq
                          (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                          (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((xself).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                          xsql_template.write (((((xconnection).xops).xregex_lookup)).apply (((xself).xlookup_name)))
                          (((unsupported)).apply ((((unsupported)).apply (((xsql_template).mod (((unsupported)).apply ((xlhs)) ((xrhs))))) (((xlhs_params).sub (xrhs_params))))))
            (((unsupported)).apply ((xRegex)) (((xField).xregister_lookup)))
              xlookup_name.write "iregex"
            (((unsupported)).apply ((xLookup)))
              seq
                xyear_lookup_bounds.write
                  [xself xconnection xyear]
                    memory > xoutput_field
                    memory > xbounds
                    memory > xiso_year
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xiso_year.write (((xisinstance)).apply (((xself).xlhs)) ((xExtractIsoYear)))
                        xoutput_field.write ((((xself).xlhs).xlhs).xoutput_field)
                        (((xisinstance)).apply ((xoutput_field)) ((xDateTimeField))).if
                          xbounds.write (((unsupported)).apply ((((xconnection).xops).xyear_lookup_bounds_for_datetime_field)) ((xyear)) ((xiso_year)))
                          xbounds.write (((unsupported)).apply ((((xconnection).xops).xyear_lookup_bounds_for_date_field)) ((xyear)) ((xiso_year)))
                        (((unsupported)).apply ((xbounds)))
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xrhs_sql
                    seq > @
                      seq
                        ((((xself).xrhs_is_direct_value)).apply).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((xparams)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)) ((((xself).xlhs).xlhs)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xrhs_sql)) ((x_)))) (((((xself).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                            xrhs_sql.write ((((xself).xget_direct_rhs_sql)).apply ((xconnection)) ((xrhs_sql)))
                            (((unsupported)).apply ((((unsupported)).apply ((xstart)) ((xfinish)))) (((((xself).xyear_lookup_bounds)).apply ((xconnection)) (((xself).xrhs)))))
                            bogusForceDataize.write ((((xparams).xextend)).apply (((((xself).xget_bound_params)).apply ((xstart)) ((xfinish)))))
                            (((unsupported)).apply ((((unsupported)).apply (("%s %s".mod (((unsupported)).apply ((xlhs_sql)) ((xrhs_sql))))) ((xparams)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xas_sql)).apply ((xcompiler)) ((xconnection)))))
                xget_direct_rhs_sql.write
                  [xself xconnection xrhs]
                    seq > @
                      (((unsupported)).apply (((((unsupported)).apply (((xconnection).xoperators)) (((xself).xlookup_name))).mod (xrhs))))
                xget_bound_params.write
                  [xself xstart xfinish]
                    seq > @
                      (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of YearLookup must provide a get_bound_params() method"))))
            (((unsupported)).apply ((xYearLookup)) ((xExact)))
              seq
                xget_direct_rhs_sql.write
                  [xself xconnection xrhs]
                    seq > @
                      (((unsupported)).apply ("BETWEEN %s AND %s"))
                xget_bound_params.write
                  [xself xstart xfinish]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ((xstart)) ((xfinish)))))
            (((unsupported)).apply ((xYearLookup)) ((xGreaterThan)))
              xget_bound_params.write
                [xself xstart xfinish]
                  seq > @
                    (((unsupported)).apply ((((unsupported)).apply ((xfinish)))))
            (((unsupported)).apply ((xYearLookup)) ((xGreaterThanOrEqual)))
              xget_bound_params.write
                [xself xstart xfinish]
                  seq > @
                    (((unsupported)).apply ((((unsupported)).apply ((xstart)))))
            (((unsupported)).apply ((xYearLookup)) ((xLessThan)))
              xget_bound_params.write
                [xself xstart xfinish]
                  seq > @
                    (((unsupported)).apply ((((unsupported)).apply ((xstart)))))
            (((unsupported)).apply ((xYearLookup)) ((xLessThanOrEqual)))
              xget_bound_params.write
                [xself xstart xfinish]
                  seq > @
                    (((unsupported)).apply ((((unsupported)).apply ((xfinish)))))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xprocess_rhs.write
                  [xself xqn xconnection]
                    seq > @
                      seq
                        ((((xconnection).xfeatures).xhas_native_uuid_field).not).if
                          seq
                            (((unsupported)).apply)
                            ((((xself).xrhs_is_direct_value)).apply).if
                              (((unsupported)).apply (((xself).xrhs)) ((((xValue)).apply (((xself).xrhs)))))
                            (((unsupported)).apply (((xself).xrhs)) ((((unsupported)).apply ((xReplace)) (((xself).xrhs)) ((((xValue)).apply ("-"))) ((((xValue)).apply (""))) ((((xCharField)).apply)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xparams)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xqn)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xparams)))))
            (((unsupported)).apply ((xUUIDTextMixin)) ((xIExact)) (((xUUIDField).xregister_lookup)))
            (((unsupported)).apply ((xUUIDTextMixin)) ((xContains)) (((xUUIDField).xregister_lookup)))
            (((unsupported)).apply ((xUUIDTextMixin)) ((xIContains)) (((xUUIDField).xregister_lookup)))
            (((unsupported)).apply ((xUUIDTextMixin)) ((xStartsWith)) (((xUUIDField).xregister_lookup)))
            (((unsupported)).apply ((xUUIDTextMixin)) ((xIStartsWith)) (((xUUIDField).xregister_lookup)))
            (((unsupported)).apply ((xUUIDTextMixin)) ((xEndsWith)) (((xUUIDField).xregister_lookup)))
            (((unsupported)).apply ((xUUIDTextMixin)) ((xIEndsWith)) (((xUUIDField).xregister_lookup)))