+package org.eolang
+alias goto org.eolang.gray.goto
+alias stdout org.eolang.io.stdout
+alias cage org.eolang.gray.cage
+junit

[unused] > my-list
  [raiseme] > apply
    [x] > mkCopy
      x' > copy
      copy.< > @
    [] > newUID
      memory > cur
      seq > apply
        cur.write (cur.is-empty.if 2 (cur.add 1))
        cur
    [] > raiseEmpty
      [] > xclass
        1 > xid
    [] > raiseNothing
      [] > xclass
        0 > xid
    cage > xcurrent-exception
    cage > result
    cage > tmp
    cage > xmyLi
    goto > @
      [returnLabel]
        seq > @
          stdout "my-list\n"
          write.
            xmyLi
            []
              [raiseme] > apply
                cage > result
                cage > tmp
                cage > e1
                cage > e5
                cage > lhs1
                cage > xc
                cage > e4
                cage > e3
                cage > xlst
                cage > e2
                cage > xco
                goto > @
                  [returnLabel]
                    seq > @
                      stdout "xmyLi\n"
                      write.
                        xc
                        []
                          newUID.apply 0 > xid
                          [unused] > apply
                            [] > result
                              cage > xhead
                              cage > xtail2
                              xc > xclass
                              seq > initFields
                                xhead.write "None: is there a None literal in the EO language?"
                                xtail2.write "None: is there a None literal in the EO language?"
                            result.initFields > @
                      write.
                        xco
                        []
                          [raiseme xheadNotCopied xtailNotCopied] > apply
                            cage > result
                            cage > tmp
                            xheadNotCopied' > xhead
                            xtailNotCopied' > xtail
                            cage > xo
                            cage > e0
                            goto > @
                              [returnLabel]
                                seq > @
                                  stdout "xco\n"
                                  xhead.<
                                  xtail.<
                                  tmp.write (((xc)).apply raiseme)
                                  (tmp.@)
                                  (e0).write (tmp.result)
                                  mkCopy (e0) > tmp1
                                  (xo).write (tmp1.copy)
                                  mkCopy (xhead) > tmp2
                                  ((xo).xhead).write (tmp2.copy)
                                  mkCopy (xtail) > tmp3
                                  ((xo).xtail).write (tmp3.copy)
                                  mkCopy (xo) > tmp4
                                  (result).write (tmp4.copy)
                                  returnLabel.forward 0
                                  123
                      (xlst).write ("None: is there a None literal in the EO language?")
                      tmp.write (((xco)).apply raiseme (1) ((xlst)))
                      (tmp.@)
                      (e1).write (tmp.result)
                      mkCopy (e1) > tmp5
                      (xlst).write (tmp5.copy)
                      tmp.write (((xco)).apply raiseme (2) ((xlst)))
                      (tmp.@)
                      (e2).write (tmp.result)
                      mkCopy (e2) > tmp6
                      (xlst).write (tmp6.copy)
                      mkCopy (xlst.xtail) > tmp7
                      (e3).write (tmp7.copy)
                      mkCopy (e3.xhead) > tmp8
                      (e4).write (tmp8.copy)
                      (lhs1).write (1)
                      [] > tmp9
                        memory > dddata
                        dddata.write (((e4).eq (lhs1))) > @
                      (e5).write (tmp9.dddata)
                      mkCopy (e5) > tmp10
                      (result).write (tmp10.copy)
                      returnLabel.forward 0
                      123
          tmp.write (((xmyLi)).apply raiseme)
          (tmp.@)
          (result).write (tmp.result)
          result
  apply 0 > @