memory > xLagLeadFunction
memory > xFunc
memory > xValueError
memory > xextra
memory > xIntegerField
memory > xFloatField
memory > xsuper
memory > xFunc2
[] > window
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xwindow_compatible
        memory > x_resolve_output_field
        memory > xarity
        memory > x__all__
        memory > x__init__
        memory > xoutput_field
        memory > xfunction
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x__all__.write (((unsupported)).apply ("CumeDist") ("DenseRank") ("FirstValue") ("Lag") ("LastValue") ("Lead") ("NthValue") ("Ntile") ("PercentRank") ("Rank") ("RowNumber"))
            (((unsupported)).apply ((xFunc2)))
              seq
                xfunction.write "CUME_DIST"
                xoutput_field.write (((xFloatField)).apply)
                xwindow_compatible.write TRUE
            (((unsupported)).apply ((xFunc)))
              seq
                xfunction.write "DENSE_RANK"
                xoutput_field.write (((xIntegerField)).apply)
                xwindow_compatible.write TRUE
            (((unsupported)).apply ((xFunc)))
              seq
                xarity.write 1
                xfunction.write "FIRST_VALUE"
                xwindow_compatible.write TRUE
            (((unsupported)).apply ((xFunc)))
              seq
                xwindow_compatible.write TRUE
                x__init__.write
                  [xself xexpression xoffset xdefault]
                    memory > xargs
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xexpression)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xValueError)).apply (("%s requires a non-null source expression.".mod (((xself).x__class__).x__name__))))))
                        ((((unsupported)).apply ((xoffset)) ("None: is there a None literal in the EO language?")).or ((xoffset).leq 0)).if
                          (((unsupported)).apply ((((xValueError)).apply (("%s requires a positive integer for the offset.".mod (((xself).x__class__).x__name__))))))
                        xargs.write (((unsupported)).apply ((xexpression)) ((xoffset)))
                        (((unsupported)).apply ((xdefault)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xargs)) ((((unsupported)).apply ((xdefault)))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xextra)))))
                x_resolve_output_field.write
                  [xself]
                    memory > xsources
                    seq > @
                      seq
                        xsources.write ((((xself).xget_source_expressions)).apply)
                        (((unsupported)).apply (((((unsupported)).apply ((xsources)) (0)).xoutput_field)))
            (((unsupported)).apply ((xLagLeadFunction)))
              xfunction.write "LAG"
            (((unsupported)).apply ((xFunc)))
              seq
                xarity.write 1
                xfunction.write "LAST_VALUE"
                xwindow_compatible.write TRUE
            (((unsupported)).apply ((xLagLeadFunction)))
              xfunction.write "LEAD"
            (((unsupported)).apply ((xFunc)))
              seq
                xfunction.write "NTH_VALUE"
                xwindow_compatible.write TRUE
                x__init__.write
                  [xself xexpression xnth]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xexpression)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xValueError)).apply (("%s requires a non-null source expression.".mod (((xself).x__class__).x__name__))))))
                        ((((unsupported)).apply ((xnth)) ("None: is there a None literal in the EO language?")).or ((xnth).leq 0)).if
                          (((unsupported)).apply ((((xValueError)).apply (("%s requires a positive integer as for nth.".mod (((xself).x__class__).x__name__))))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xexpression)) ((xnth)) ((((unsupported)).apply ((xextra)))))
                x_resolve_output_field.write
                  [xself]
                    memory > xsources
                    seq > @
                      seq
                        xsources.write ((((xself).xget_source_expressions)).apply)
                        (((unsupported)).apply (((((unsupported)).apply ((xsources)) (0)).xoutput_field)))
            (((unsupported)).apply ((xFunc)))
              seq
                xfunction.write "NTILE"
                xoutput_field.write (((xIntegerField)).apply)
                xwindow_compatible.write TRUE
                x__init__.write
                  [xself xnum_buckets]
                    seq > @
                      (((unsupported)).apply)
                        ((xnum_buckets).leq 0).if
                          (((unsupported)).apply ((((xValueError)).apply ("num_buckets must be greater than 0."))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xnum_buckets)) ((((unsupported)).apply ((xextra)))))
            (((unsupported)).apply ((xFunc)))
              seq
                xfunction.write "PERCENT_RANK"
                xoutput_field.write (((xFloatField)).apply)
                xwindow_compatible.write TRUE
            (((unsupported)).apply ((xFunc)))
              seq
                xfunction.write "RANK"
                xoutput_field.write (((xIntegerField)).apply)
                xwindow_compatible.write TRUE
            (((unsupported)).apply ((xFunc)))
              seq
                xfunction.write "ROW_NUMBER"
                xoutput_field.write (((xIntegerField)).apply)
                xwindow_compatible.write TRUE