memory > xAttributeError
memory > xtarfile
memory > xstr
memory > xrest
memory > xopen
memory > xException
memory > xx
memory > xSuspiciousOperation
memory > xshutil
memory > xkwargs
memory > xmember
memory > xarchive
memory > xstat
memory > xArchiveException
memory > xNotImplementedError
memory > xprefix
memory > xKeyError
memory > xbase
memory > xBaseArchive
memory > xUnrecognizedArchiveFormat
memory > xpath
memory > xArchive
memory > xprint
memory > xargs
memory > xos
memory > xtail_ext
memory > xZipArchive
memory > xexc
memory > xext
memory > xisinstance
memory > xoutfile
memory > xdict
memory > xzipfile
memory > xTarArchive
[] > archive
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > x_archive_cls
        memory > xlist
        memory > x__enter__
        memory > xtarget_filename
        memory > xextension_map
        memory > xextract
        memory > xclose
        memory > x__exit__
        memory > xsplit_leading_dir
        memory > x_copy_permissions
        memory > xhas_leading_dir
        memory > x__init__
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply ((xException)))
              (((unsupported)).apply)
            (((unsupported)).apply ((xArchiveException)))
              (((unsupported)).apply)
            xextract.write
              [xpath xto_path]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((xArchive)).apply ((xpath)))) ((xarchive)))
                      bogusForceDataize.write ((((xarchive).xextract)).apply ((xto_path)))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                x__init__.write
                  [xself xfile]
                    seq > @
                      (((unsupported)).apply (((xself).x_archive)) (((((((xself).x_archive_cls)).apply ((xfile)))).apply ((xfile)))))
                x_archive_cls.write
                  [xfile]
                    memory > xcls
                    memory > xfilename
                    seq > @
                      (((unsupported)).apply)
                        xcls.write "None: is there a None literal in the EO language?"
                        (((xisinstance)).apply ((xfile)) ((xstr))).if
                          xfilename.write (xfile)
                          (((unsupported)).apply ((xAttributeError)))
                            xfilename.write ((xfile).xname)
                            (((unsupported)).apply ((((xUnrecognizedArchiveFormat)).apply ("File object not a recognized archive format."))))
                        (((unsupported)).apply ((((unsupported)).apply ((xbase)) ((xtail_ext)))) ((((((xos).xpath).xsplitext)).apply (((xfilename).xlower)))))
                        xcls.write ((((xextension_map).xget)).apply ((xtail_ext)))
                        ((xcls).not).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xbase)) ((xext)))) ((((((xos).xpath).xsplitext)).apply ((xbase)))))
                            xcls.write ((((xextension_map).xget)).apply ((xext)))
                        ((xcls).not).if
                          (((unsupported)).apply ((((xUnrecognizedArchiveFormat)).apply (("Path not a recognized archive format: %s".mod (xfilename))))))
                        (((unsupported)).apply ((xcls)))
                x__enter__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((xself)))
                x__exit__.write
                  [xself xexc_type xexc_value xtraceback]
                    seq > @
                      unsupported
                xextract.write
                  [xself xto_path]
                    seq > @
                      bogusForceDataize.write (((((xself).x_archive).xextract)).apply ((xto_path)))
                xlist.write
                  [xself]
                    seq > @
                      unsupported
                xclose.write
                  [xself]
                    seq > @
                      unsupported
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                x_copy_permissions.write
                  [xmode xfilename]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        ((xmode).and ((xstat).xS_IROTH)).if
                          bogusForceDataize.write ((((xos).xchmod)).apply ((xfilename)) ((xmode)))
                xsplit_leading_dir.write
                  [xself xpath]
                    seq > @
                      seq
                        xpath.write (((xstr)).apply ((xpath)))
                        xpath.write (((((((xpath).xlstrip)).apply ("/")).xlstrip)).apply ("\\"))
                        ((((unsupported)).apply ("/") ((xpath))).and (((((unsupported)).apply ("\\") ((xpath))).and (((((xpath).xfind)).apply ("/")).less ((((xpath).xfind)).apply ("\\")))).or (((unsupported)).apply ("\\") ((xpath))))).if
                          (((unsupported)).apply (((((xpath).xsplit)).apply ("/") (1))))
                          (((unsupported)).apply ("\\") ((xpath))).if
                            (((unsupported)).apply (((((xpath).xsplit)).apply ("\\") (1))))
                            (((unsupported)).apply ((((unsupported)).apply ((xpath)) (""))))
                xhas_leading_dir.write
                  [xself xpaths]
                    memory > xcommon_prefix
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xcommon_prefix.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply ((xpath)) ((xpaths)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xprefix)) ((xrest)))) (((((xself).xsplit_leading_dir)).apply ((xpath)))))
                            ((xprefix).not).if
                              (((unsupported)).apply (FALSE))
                              (((unsupported)).apply ((xcommon_prefix)) ("None: is there a None literal in the EO language?")).if
                                xcommon_prefix.write (xprefix)
                                ((xprefix).neq (xcommon_prefix)).if
                                  (((unsupported)).apply (FALSE))
                        (((unsupported)).apply (TRUE))
                xtarget_filename.write
                  [xself xto_path xname]
                    memory > xtarget_path
                    memory > xfilename
                    seq > @
                      seq
                        xtarget_path.write (((((xos).xpath).xabspath)).apply ((xto_path)))
                        xfilename.write (((((xos).xpath).xabspath)).apply ((((((xos).xpath).xjoin)).apply ((xtarget_path)) ((xname)))))
                        (((((xfilename).xstartswith)).apply ((xtarget_path))).not).if
                          (((unsupported)).apply ((((xSuspiciousOperation)).apply (("Archive contains invalid path: '%s'".mod (xname))))))
                        (((unsupported)).apply ((xfilename)))
                xextract.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseArchive must provide an extract method"))))
                xlist.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of BaseArchive must provide a list method"))))
            (((unsupported)).apply ((xBaseArchive)))
              seq
                x__init__.write
                  [xself xfile]
                    seq > @
                      (((unsupported)).apply (((xself).x_archive)) (((((xtarfile).xopen)).apply ((xfile)))))
                xlist.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write (((((xself).x_archive).xlist)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xextract.write
                  [xself xto_path]
                    memory > xfilename
                    memory > xmembers
                    memory > xdirname
                    memory > xname
                    memory > xleading
                    memory > xextracted
                    seq > @
                      seq
                        xmembers.write (((xself).x_archive).xgetmembers)
                        xleading.write ((((xself).xhas_leading_dir)).apply ((((unsupported)).apply (((xx).xname)) ((xx)) ((xmembers)))))
                        (((unsupported)).apply ((xmember)) ((xmembers)))
                          seq
                            xname.write ((xmember).xname)
                            (xleading).if
                              xname.write (((unsupported)).apply (((((xself).xsplit_leading_dir)).apply ((xname)))) (1))
                            xfilename.write ((((xself).xtarget_filename)).apply ((xto_path)) ((xname)))
                            ((xmember).xisdir).if
                              (xfilename).if
                                (((unsupported)).apply (((xos).xmakedirs)) ((xfilename)) (TRUE))
                              (((unsupported)).apply ((((unsupported)).apply ((xKeyError)) ((xAttributeError)))))
                                xextracted.write (((((xself).x_archive).xextractfile)).apply ((xmember)))
                                bogusForceDataize.write (((xprint)).apply (("In the tar file %s the member %s is invalid: %s".mod (((unsupported)).apply ((xname)) (((xmember).xname)) ((xexc))))))
                                seq
                                  xdirname.write (((((xos).xpath).xdirname)).apply ((xfilename)))
                                  (xdirname).if
                                    (((unsupported)).apply (((xos).xmakedirs)) ((xdirname)) (TRUE))
                                  (((unsupported)).apply ((((xopen)).apply ((xfilename)) ("wb"))) ((xoutfile)))
                                    seq
                                      bogusForceDataize.write ((((xshutil).xcopyfileobj)).apply ((xextracted)) ((xoutfile)))
                                      bogusForceDataize.write ((((xself).x_copy_permissions)).apply (((xmember).xmode)) ((xfilename)))
                                (xextracted).if
                                  unsupported
                xclose.write
                  [xself]
                    seq > @
                      unsupported
            (((unsupported)).apply ((xBaseArchive)))
              seq
                x__init__.write
                  [xself xfile]
                    seq > @
                      (((unsupported)).apply (((xself).x_archive)) (((((xzipfile).xZipFile)).apply ((xfile)))))
                xlist.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write (((((xself).x_archive).xprintdir)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xextract.write
                  [xself xto_path]
                    memory > xdata
                    memory > xmode
                    memory > xinfo
                    memory > xleading
                    memory > xdirname
                    memory > xname
                    memory > xnamelist
                    memory > xfilename
                    seq > @
                      seq
                        xnamelist.write (((xself).x_archive).xnamelist)
                        xleading.write ((((xself).xhas_leading_dir)).apply ((xnamelist)))
                        (((unsupported)).apply ((xname)) ((xnamelist)))
                          seq
                            xdata.write (((((xself).x_archive).xread)).apply ((xname)))
                            xinfo.write (((((xself).x_archive).xgetinfo)).apply ((xname)))
                            (xleading).if
                              xname.write (((unsupported)).apply (((((xself).xsplit_leading_dir)).apply ((xname)))) (1))
                            ((xname).not).if
                              (((unsupported)).apply)
                            xfilename.write ((((xself).xtarget_filename)).apply ((xto_path)) ((xname)))
                            ((((xname).xendswith)).apply ((((unsupported)).apply ("/") ("\\")))).if
                              (((unsupported)).apply (((xos).xmakedirs)) ((xfilename)) (TRUE))
                              seq
                                xdirname.write (((((xos).xpath).xdirname)).apply ((xfilename)))
                                (xdirname).if
                                  (((unsupported)).apply (((xos).xmakedirs)) ((xdirname)) (TRUE))
                                (((unsupported)).apply ((((xopen)).apply ((xfilename)) ("wb"))) ((xoutfile)))
                                  bogusForceDataize.write ((((xoutfile).xwrite)).apply ((xdata)))
                                xmode.write (((unsupported)).apply (((xinfo).xexternal_attr)) (16))
                                bogusForceDataize.write ((((xself).x_copy_permissions)).apply ((xmode)) ((xfilename)))
                xclose.write
                  [xself]
                    seq > @
                      unsupported
            xextension_map.write ((((xdict).xfromkeys)).apply ((((unsupported)).apply (".tar") (".tar.bz2") (".tbz2") (".tbz") (".tz2") (".tar.gz") (".tgz") (".taz") (".tar.lzma") (".tlz") (".tar.xz") (".txz"))) ((xTarArchive)))
            (((unsupported)).apply ((((unsupported)).apply ((xextension_map)) (".zip"))) ((xZipArchive)))