memory > xtimezone
memory > xforce_str
memory > xBulkInsertMapper
memory > xfetch
memory > xsequence
memory > xlhs_sql
memory > xgetattr
memory > xoffset
memory > xmodel
memory > xfield
memory > xlhs_params
memory > xrhs_params
memory > xtable
memory > x_lazy_re_compile
memory > xdatetime
memory > xlist
memory > xRawSQL
memory > xenumerate
memory > xuuid
memory > xrhs_sql
memory > xValueError
memory > xsplit_tzname_delta
memory > xBaseDatabaseOperations
memory > xsign
memory > xstr
memory > xforeign_table
memory > xlhs
memory > xWhereNode
memory > xparam
memory > xrhs
memory > xf
memory > xstrip_quotes
memory > xset
memory > xsettings
memory > xlru_cache
memory > xDatabaseError
memory > xOracle_datetime
memory > xhasattr
memory > xcursor
memory > xNotSupportedError
memory > xExists
memory > xi
memory > xsuper
memory > xrow
memory > xbool
memory > xtuple
memory > xconstraint
memory > xsql
memory > xLookup
memory > xDatabase
memory > xInsertVar
memory > xAutoField
memory > xforce_bytes
memory > xExpressionWrapper
memory > xisinstance
memory > xlen
memory > xdict
memory > xtruncate_name
memory > xsequence_info
memory > xkey
[] > operations
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xdatetime_trunc_sql
        memory > x_sequence_reset_sql
        memory > xadapt_datefield_value
        memory > xcache_key_culling_sql
        memory > xconvert_datetimefield_value
        memory > xdatetime_cast_date_sql
        memory > xdate_extract_sql
        memory > xbulk_batch_size
        memory > xdatetime_cast_time_sql
        memory > xadapt_decimalfield_value
        memory > xconvert_booleanfield_value
        memory > xmax_in_list_size
        memory > xadapt_datetimefield_value
        memory > xreturn_insert_columns
        memory > xpk_default_value
        memory > xconditional_expression_supported_in_where_clause
        memory > xfetch_returned_insert_columns
        memory > xconvert_empty_string
        memory > x_tzname_re
        memory > xprocess_clob
        memory > xno_limit_value
        memory > xsubtract_temporals
        memory > xsequence_reset_by_name_sql
        memory > xconvert_empty_bytes
        memory > xdatetime_extract_sql
        memory > xconvert_textfield_value
        memory > xprep_for_iexact_query
        memory > xget_db_converters
        memory > xfield_cast_sql
        memory > xcast_data_types
        memory > xlookup_cast
        memory > xconvert_uuidfield_value
        memory > xcombine_expression
        memory > x_convert_field_to_tz
        memory > xbulk_insert_sql
        memory > xstart_transaction_sql
        memory > x_get_sequence_name
        memory > xconvert_datefield_value
        memory > xconvert_binaryfield_value
        memory > xdeferrable_sql
        memory > xsql_flush
        memory > xlimit_offset_sql
        memory > x__foreign_key_constraints
        memory > xset_operators
        memory > xtime_trunc_sql
        memory > x_get_no_autofield_sequence_name
        memory > xconvert_timefield_value
        memory > xcast_char_field_without_max_length
        memory > x_foreign_key_constraints
        memory > xdate_trunc_sql
        memory > xquote_name
        memory > xinteger_field_ranges
        memory > x_prepare_tzname_delta
        memory > xmax_name_length
        memory > xtablespace_sql
        memory > xregex_lookup
        memory > xlast_insert_id
        memory > xlast_executed_query
        memory > xsequence_reset_sql
        memory > xadapt_timefield_value
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply ((xBaseDatabaseOperations)))
              seq
                xinteger_field_ranges.write (((unsupported)).apply ("SmallIntegerField") ((((unsupported)).apply (((((unsupported)).apply).neg)) ((((unsupported)).apply)))) ("IntegerField") ((((unsupported)).apply (((((unsupported)).apply).neg)) ((((unsupported)).apply)))) ("BigIntegerField") ((((unsupported)).apply (((((unsupported)).apply).neg)) ((((unsupported)).apply)))) ("PositiveBigIntegerField") ((((unsupported)).apply (0) ((((unsupported)).apply)))) ("PositiveSmallIntegerField") ((((unsupported)).apply (0) ((((unsupported)).apply)))) ("PositiveIntegerField") ((((unsupported)).apply (0) ((((unsupported)).apply)))) ("SmallAutoField") ((((unsupported)).apply ((99999.neg)) (99999))) ("AutoField") ((((unsupported)).apply (((((unsupported)).apply).neg)) ((((unsupported)).apply)))) ("BigAutoField") ((((unsupported)).apply (((((unsupported)).apply).neg)) ((((unsupported)).apply)))))
                xset_operators.write (((unsupported)).apply (((xBaseDatabaseOperations).xset_operators)) ("difference") ("MINUS"))
                x_sequence_reset_sql.write (((unsupported)).apply)
                xcast_char_field_without_max_length.write "NVARCHAR2(2000)"
                xcast_data_types.write (((unsupported)).apply ("AutoField") ("NUMBER(11)") ("BigAutoField") ("NUMBER(19)") ("SmallAutoField") ("NUMBER(5)") ("TextField") ((xcast_char_field_without_max_length)))
                xcache_key_culling_sql.write
                  [xself]
                    memory > xcache_key
                    seq > @
                      seq
                        xcache_key.write ((((xself).xquote_name)).apply ("cache_key"))
                        (((unsupported)).apply ("SELECT {cache_key} FROM %s ORDER BY {cache_key} OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY"))
                xdate_extract_sql.write
                  [xself xlookup_type xfield_name]
                    seq > @
                      ((xlookup_type).eq "week_day").if
                        (((unsupported)).apply (("TO_CHAR(%s, 'D')".mod (xfield_name))))
                        ((xlookup_type).eq "iso_week_day").if
                          (((unsupported)).apply (("TO_CHAR(%s - 1, 'D')".mod (xfield_name))))
                          ((xlookup_type).eq "week").if
                            (((unsupported)).apply (("TO_CHAR(%s, 'IW')".mod (xfield_name))))
                            ((xlookup_type).eq "quarter").if
                              (((unsupported)).apply (("TO_CHAR(%s, 'Q')".mod (xfield_name))))
                              ((xlookup_type).eq "iso_year").if
                                (((unsupported)).apply (("TO_CHAR(%s, 'IYYY')".mod (xfield_name))))
                                (((unsupported)).apply (("EXTRACT(%s FROM %s)".mod (((unsupported)).apply (((((xlookup_type).xupper)).apply)) ((xfield_name))))))
                xdate_trunc_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    seq > @
                      (((unsupported)).apply)
                        xfield_name.write ((((xself).x_convert_field_to_tz)).apply ((xfield_name)) ((xtzname)))
                        (((unsupported)).apply ((xlookup_type)) ((((unsupported)).apply ("year") ("month")))).if
                          (((unsupported)).apply (("TRUNC(%s, '%s')".mod (((unsupported)).apply ((xfield_name)) (((((xlookup_type).xupper)).apply))))))
                          ((xlookup_type).eq "quarter").if
                            (((unsupported)).apply (("TRUNC(%s, 'Q')".mod (xfield_name))))
                            ((xlookup_type).eq "week").if
                              (((unsupported)).apply (("TRUNC(%s, 'IW')".mod (xfield_name))))
                              (((unsupported)).apply (("TRUNC(%s)".mod (xfield_name))))
                x_tzname_re.write (((x_lazy_re_compile)).apply ("^[w/:+-]+$"))
                x_prepare_tzname_delta.write
                  [xself xtzname]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xtzname)) ((xsign)) ((xoffset)))) ((((xsplit_tzname_delta)).apply ((xtzname)))))
                        (((unsupported)).apply (((xoffset).if "{sign}{offset}" (xtzname))))
                x_convert_field_to_tz.write
                  [xself xfield_name xtzname]
                    seq > @
                      seq
                        ((((xsettings).xUSE_TZ).and (xtzname)).not).if
                          (((unsupported)).apply ((xfield_name)))
                        ((((((xself).x_tzname_re).xmatch)).apply ((xtzname))).not).if
                          (((unsupported)).apply ((((xValueError)).apply (("Invalid time zone name: %s".mod (xtzname))))))
                        ((((xself).xconnection).xtimezone_name).neq (xtzname)).if
                          (((unsupported)).apply (("CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)".mod (((unsupported)).apply ((xfield_name)) ((((xself).xconnection).xtimezone_name)) (((((xself).x_prepare_tzname_delta)).apply ((xtzname))))))))
                        (((unsupported)).apply ((xfield_name)))
                xdatetime_cast_date_sql.write
                  [xself xfield_name xtzname]
                    seq > @
                      seq
                        xfield_name.write ((((xself).x_convert_field_to_tz)).apply ((xfield_name)) ((xtzname)))
                        (((unsupported)).apply (("TRUNC(%s)".mod (xfield_name))))
                xdatetime_cast_time_sql.write
                  [xself xfield_name xtzname]
                    memory > xconvert_datetime_sql
                    seq > @
                      seq
                        xconvert_datetime_sql.write ("TO_TIMESTAMP(CONCAT('1900-01-01 ', TO_CHAR(%s, 'HH24:MI:SS.FF')), 'YYYY-MM-DD HH24:MI:SS.FF')".mod ((((xself).x_convert_field_to_tz)).apply ((xfield_name)) ((xtzname))))
                        (((unsupported)).apply (("CASE WHEN %s IS NOT NULL THEN %s ELSE NULL END".mod (((unsupported)).apply ((xfield_name)) ((xconvert_datetime_sql))))))
                xdatetime_extract_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    seq > @
                      seq
                        xfield_name.write ((((xself).x_convert_field_to_tz)).apply ((xfield_name)) ((xtzname)))
                        (((unsupported)).apply (((((xself).xdate_extract_sql)).apply ((xlookup_type)) ((xfield_name)))))
                xdatetime_trunc_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    memory > xsql
                    seq > @
                      seq
                        xfield_name.write ((((xself).x_convert_field_to_tz)).apply ((xfield_name)) ((xtzname)))
                        (((unsupported)).apply ((xlookup_type)) ((((unsupported)).apply ("year") ("month")))).if
                          xsql.write ("TRUNC(%s, '%s')".mod (((unsupported)).apply ((xfield_name)) (((((xlookup_type).xupper)).apply))))
                          ((xlookup_type).eq "quarter").if
                            xsql.write ("TRUNC(%s, 'Q')".mod (xfield_name))
                            ((xlookup_type).eq "week").if
                              xsql.write ("TRUNC(%s, 'IW')".mod (xfield_name))
                              ((xlookup_type).eq "day").if
                                xsql.write ("TRUNC(%s)".mod (xfield_name))
                                ((xlookup_type).eq "hour").if
                                  xsql.write ("TRUNC(%s, 'HH24')".mod (xfield_name))
                                  ((xlookup_type).eq "minute").if
                                    xsql.write ("TRUNC(%s, 'MI')".mod (xfield_name))
                                    xsql.write ("CAST(%s AS DATE)".mod (xfield_name))
                        (((unsupported)).apply ((xsql)))
                xtime_trunc_sql.write
                  [xself xlookup_type xfield_name xtzname]
                    memory > xsql
                    seq > @
                      (((unsupported)).apply)
                        xfield_name.write ((((xself).x_convert_field_to_tz)).apply ((xfield_name)) ((xtzname)))
                        ((xlookup_type).eq "hour").if
                          xsql.write ("TRUNC(%s, 'HH24')".mod (xfield_name))
                          ((xlookup_type).eq "minute").if
                            xsql.write ("TRUNC(%s, 'MI')".mod (xfield_name))
                            ((xlookup_type).eq "second").if
                              xsql.write ("CAST(%s AS DATE)".mod (xfield_name))
                        (((unsupported)).apply ((xsql)))
                xget_db_converters.write
                  [xself xexpression]
                    memory > xconverters
                    memory > xinternal_type
                    seq > @
                      seq
                        xconverters.write ((((((xsuper)).apply).xget_db_converters)).apply ((xexpression)))
                        xinternal_type.write (((((xexpression).xoutput_field).xget_internal_type)).apply)
                        (((unsupported)).apply ((xinternal_type)) ((((unsupported)).apply ("JSONField") ("TextField")))).if
                          bogusForceDataize.write ((((xconverters).xappend)).apply (((xself).xconvert_textfield_value)))
                          ((xinternal_type).eq "BinaryField").if
                            bogusForceDataize.write ((((xconverters).xappend)).apply (((xself).xconvert_binaryfield_value)))
                            ((xinternal_type).eq "BooleanField").if
                              bogusForceDataize.write ((((xconverters).xappend)).apply (((xself).xconvert_booleanfield_value)))
                              ((xinternal_type).eq "DateTimeField").if
                                ((xsettings).xUSE_TZ).if
                                  bogusForceDataize.write ((((xconverters).xappend)).apply (((xself).xconvert_datetimefield_value)))
                                ((xinternal_type).eq "DateField").if
                                  bogusForceDataize.write ((((xconverters).xappend)).apply (((xself).xconvert_datefield_value)))
                                  ((xinternal_type).eq "TimeField").if
                                    bogusForceDataize.write ((((xconverters).xappend)).apply (((xself).xconvert_timefield_value)))
                                    ((xinternal_type).eq "UUIDField").if
                                      bogusForceDataize.write ((((xconverters).xappend)).apply (((xself).xconvert_uuidfield_value)))
                        (((xexpression).xoutput_field).xempty_strings_allowed).if
                          bogusForceDataize.write ((((xconverters).xappend)).apply ((((xinternal_type).eq "BinaryField").if ((xself).xconvert_empty_bytes) ((xself).xconvert_empty_string))))
                        (((unsupported)).apply ((xconverters)))
                xconvert_textfield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xvalue)) (((xDatabase).xLOB))).if
                          xvalue.write ((((xvalue).xread)).apply)
                        (((unsupported)).apply ((xvalue)))
                xconvert_binaryfield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xvalue)) (((xDatabase).xLOB))).if
                          xvalue.write (((xforce_bytes)).apply (((((xvalue).xread)).apply)))
                        (((unsupported)).apply ((xvalue)))
                xconvert_booleanfield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ((((unsupported)).apply (0) (1)))).if
                          xvalue.write (((xbool)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)))
                xconvert_datetimefield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          xvalue.write ((((xtimezone).xmake_aware)).apply ((xvalue)) ((((xself).xconnection).xtimezone)))
                        (((unsupported)).apply ((xvalue)))
                xconvert_datefield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xvalue)) (((xDatabase).xTimestamp))).if
                          xvalue.write ((((xvalue).xdate)).apply)
                        (((unsupported)).apply ((xvalue)))
                xconvert_timefield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((xisinstance)).apply ((xvalue)) (((xDatabase).xTimestamp))).if
                          xvalue.write ((((xvalue).xtime)).apply)
                        (((unsupported)).apply ((xvalue)))
                xconvert_uuidfield_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          xvalue.write ((((xuuid).xUUID)).apply ((xvalue)))
                        (((unsupported)).apply ((xvalue)))
                xconvert_empty_string.write
                  [xvalue xexpression xconnection]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if "" (xvalue))))
                xconvert_empty_bytes.write
                  [xvalue xexpression xconnection]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if "" (xvalue))))
                xdeferrable_sql.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (" DEFERRABLE INITIALLY DEFERRED"))
                xfetch_returned_insert_columns.write
                  [xself xcursor xreturning_params]
                    memory > xvalue
                    memory > xcolumns
                    seq > @
                      seq
                        xcolumns.write (((unsupported)).apply)
                        (((unsupported)).apply ((xparam)) ((xreturning_params)))
                          seq
                            xvalue.write ((((xparam).xget_value)).apply)
                            ((xvalue).eq (((unsupported)).apply)).if
                              (((unsupported)).apply ((((xDatabaseError)).apply ("The database did not return a new row id. Probably \"ORA-1403: no data found\" was raised internally but was hidden by the Oracle OCI library (see https://code.djangoproject.com/ticket/28859)."))))
                            bogusForceDataize.write ((((xcolumns).xappend)).apply ((((unsupported)).apply ((xvalue)) (0))))
                        (((unsupported)).apply ((((xtuple)).apply ((xcolumns)))))
                xfield_cast_sql.write
                  [xself xdb_type xinternal_type]
                    seq > @
                      (((xdb_type).and ((((xdb_type).xendswith)).apply ("LOB"))).and ((xinternal_type).neq "JSONField")).if
                        (((unsupported)).apply ("DBMS_LOB.SUBSTR(%s)"))
                        (((unsupported)).apply ("%s"))
                xno_limit_value.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xlimit_offset_sql.write
                  [xself xlow_mark xhigh_mark]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xfetch)) ((xoffset)))) (((((xself).x_get_limit_offset_params)).apply ((xlow_mark)) ((xhigh_mark)))))
                        (((unsupported)).apply ((((" ".xjoin)).apply ((((unsupported)).apply ((xsql)) ((xsql)) ((((unsupported)).apply (((xoffset).if ("OFFSET %d ROWS".mod (xoffset)) "None: is there a None literal in the EO language?")) (((xfetch).if ("FETCH FIRST %d ROWS ONLY".mod (xfetch)) "None: is there a None literal in the EO language?")))) ((xsql)))))))
                xlast_executed_query.write
                  [xself xcursor xsql xparams]
                    memory > xstatement
                    seq > @
                      seq
                        xstatement.write ((xcursor).xstatement)
                        (((xisinstance)).apply ((xparams)) ((((unsupported)).apply ((xtuple)) ((xlist))))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xi)) ((xparam)))) ((((xenumerate)).apply ((xparams)))))
                            xstatement.write ((((xstatement).xreplace)).apply ((":arg%d".mod (xi))) ((((unsupported)).apply ((xforce_str)) ((xparam)) ("replace"))))
                          (((xisinstance)).apply ((xparams)) ((xdict))).if
                            (((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xparam)))) (((((xparams).xitems)).apply)))
                              xstatement.write ((((xstatement).xreplace)).apply ((":%s".mod (xkey))) ((((unsupported)).apply ((xforce_str)) ((xparam)) ("replace"))))
                        (((unsupported)).apply ((xstatement)))
                xlast_insert_id.write
                  [xself xcursor xtable_name xpk_name]
                    memory > xsq_name
                    seq > @
                      seq
                        xsq_name.write ((((xself).x_get_sequence_name)).apply ((xcursor)) ((((xstrip_quotes)).apply ((xtable_name)))) ((xpk_name)))
                        bogusForceDataize.write ((((xcursor).xexecute)).apply (("\"%s\".currval".mod (xsq_name))))
                        (((unsupported)).apply ((((unsupported)).apply (((((xcursor).xfetchone)).apply)) (0))))
                xlookup_cast.write
                  [xself xlookup_type xinternal_type]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xlookup_type)) ((((unsupported)).apply ("iexact") ("icontains") ("istartswith") ("iendswith")))).if
                          (((unsupported)).apply ("UPPER(%s)"))
                        (((xinternal_type).eq "JSONField").and ((xlookup_type).eq "exact")).if
                          (((unsupported)).apply ("DBMS_LOB.SUBSTR(%s)"))
                        (((unsupported)).apply ("%s"))
                xmax_in_list_size.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (1000))
                xmax_name_length.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (30))
                xpk_default_value.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("NULL"))
                xprep_for_iexact_query.write
                  [xself xx]
                    seq > @
                      (((unsupported)).apply ((xx)))
                xprocess_clob.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (""))
                        (((unsupported)).apply (((((xvalue).xread)).apply)))
                xquote_name.write
                  [xself xname]
                    seq > @
                      seq
                        ((((((xname).xstartswith)).apply ("\"")).not).and (((((xname).xendswith)).apply ("\"")).not)).if
                          xname.write ("\"%s\"".mod (((xtruncate_name)).apply ((xname)) (((((xself).xmax_name_length)).apply))))
                        xname.write ((((xname).xreplace)).apply ("%") ("%%"))
                        (((unsupported)).apply (((((xname).xupper)).apply)))
                xregex_lookup.write
                  [xself xlookup_type]
                    memory > xmatch_option
                    seq > @
                      seq
                        ((xlookup_type).eq "regex").if
                          xmatch_option.write "'c'"
                          xmatch_option.write "'i'"
                        (((unsupported)).apply (("REGEXP_LIKE(%%s, %%s, %s)".mod (xmatch_option))))
                xreturn_insert_columns.write
                  [xself xfields]
                    memory > xparams
                    memory > xfield_names
                    seq > @
                      seq
                        ((xfields).not).if
                          (((unsupported)).apply ((((unsupported)).apply ("") ((((unsupported)).apply)))))
                        xfield_names.write (((unsupported)).apply)
                        xparams.write (((unsupported)).apply)
                        (((unsupported)).apply ((xfield)) ((xfields)))
                          seq
                            bogusForceDataize.write ((((xfield_names).xappend)).apply (("%s.%s".mod (((unsupported)).apply (((((xself).xquote_name)).apply (((((xfield).xmodel).x_meta).xdb_table)))) (((((xself).xquote_name)).apply (((xfield).xcolumn))))))))
                            bogusForceDataize.write ((((xparams).xappend)).apply ((((xInsertVar)).apply ((xfield)))))
                        (((unsupported)).apply ((((unsupported)).apply (("RETURNING %s INTO %s".mod (((unsupported)).apply ((((", ".xjoin)).apply ((xfield_names)))) ((((", ".xjoin)).apply (((((unsupported)).apply ("%s")).mul (((xlen)).apply ((xparams)))))))))) ((((xtuple)).apply ((xparams)))))))
                x__foreign_key_constraints.write
                  [xself xtable_name xrecursive]
                    seq > @
                      (((unsupported)).apply ((((((xself).xconnection).xcursor)).apply)) ((xcursor)))
                        seq
                          (xrecursive).if
                            bogusForceDataize.write ((((xcursor).xexecute)).apply ((((unsupported)).apply)) ((((unsupported)).apply ((xtable_name)) ((xtable_name)))))
                            bogusForceDataize.write ((((xcursor).xexecute)).apply ((((unsupported)).apply)) ((((unsupported)).apply ((xtable_name)))))
                          (((unsupported)).apply (((((xcursor).xfetchall)).apply)))
                x_foreign_key_constraints.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((((unsupported)).apply ((xlru_cache)) (512))).apply (((xself).x__foreign_key_constraints)))))
                xsql_flush.write
                  [xself xstyle xtables xreset_sequences xallow_cascade]
                    memory > xsql
                    memory > xtruncated_tables
                    memory > xsequences
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        ((xtables).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xtruncated_tables.write (((unsupported)).apply (((((xtable).xupper)).apply)) ((xtable)) ((xtables)))
                        xconstraints.write (((xset)).apply)
                        (((unsupported)).apply ((xtable)) ((xtables)))
                          (((unsupported)).apply ((((unsupported)).apply ((xforeign_table)) ((xconstraint)))) ((((unsupported)).apply (((xself).x_foreign_key_constraints)) ((xtable)) ((xallow_cascade)))))
                            seq
                              (xallow_cascade).if
                                bogusForceDataize.write ((((xtruncated_tables).xadd)).apply ((xforeign_table)))
                              bogusForceDataize.write ((((xconstraints).xadd)).apply ((((unsupported)).apply ((xforeign_table)) ((xconstraint)))))
                        xsql.write (((((unsupported)).apply (("%s %s %s %s %s %s %s %s;".mod (((unsupported)).apply (((((xstyle).xSQL_KEYWORD)).apply ("ALTER"))) (((((xstyle).xSQL_KEYWORD)).apply ("TABLE"))) (((((xstyle).xSQL_FIELD)).apply (((((xself).xquote_name)).apply ((xtable)))))) (((((xstyle).xSQL_KEYWORD)).apply ("DISABLE"))) (((((xstyle).xSQL_KEYWORD)).apply ("CONSTRAINT"))) (((((xstyle).xSQL_FIELD)).apply (((((xself).xquote_name)).apply ((xconstraint)))))) (((((xstyle).xSQL_KEYWORD)).apply ("KEEP"))) (((((xstyle).xSQL_KEYWORD)).apply ("INDEX")))))) ((((unsupported)).apply ((xtable)) ((xconstraint)))) ((xconstraints))).add (((unsupported)).apply (("%s %s %s;".mod (((unsupported)).apply (((((xstyle).xSQL_KEYWORD)).apply ("TRUNCATE"))) (((((xstyle).xSQL_KEYWORD)).apply ("TABLE"))) (((((xstyle).xSQL_FIELD)).apply (((((xself).xquote_name)).apply ((xtable))))))))) ((xtable)) ((xtruncated_tables)))).add (((unsupported)).apply (("%s %s %s %s %s %s;".mod (((unsupported)).apply (((((xstyle).xSQL_KEYWORD)).apply ("ALTER"))) (((((xstyle).xSQL_KEYWORD)).apply ("TABLE"))) (((((xstyle).xSQL_FIELD)).apply (((((xself).xquote_name)).apply ((xtable)))))) (((((xstyle).xSQL_KEYWORD)).apply ("ENABLE"))) (((((xstyle).xSQL_KEYWORD)).apply ("CONSTRAINT"))) (((((xstyle).xSQL_FIELD)).apply (((((xself).xquote_name)).apply ((xconstraint))))))))) ((((unsupported)).apply ((xtable)) ((xconstraint)))) ((xconstraints))))
                        (xreset_sequences).if
                          seq
                            xsequences.write (((unsupported)).apply ((xsequence)) ((xsequence)) (((((((xself).xconnection).xintrospection).xsequence_list)).apply)) ((((unsupported)).apply (((((((unsupported)).apply ((xsequence)) ("table")).xupper)).apply)) ((xtruncated_tables)))))
                            bogusForceDataize.write ((((xsql).xextend)).apply (((((xself).xsequence_reset_by_name_sql)).apply ((xstyle)) ((xsequences)))))
                        (((unsupported)).apply ((xsql)))
                xsequence_reset_by_name_sql.write
                  [xself xstyle xsequences]
                    memory > xtable
                    memory > xquery
                    memory > xcolumn
                    memory > xsql
                    memory > xno_autofield_sequence_name
                    seq > @
                      seq
                        xsql.write (((unsupported)).apply)
                        (((unsupported)).apply ((xsequence_info)) ((xsequences)))
                          seq
                            xno_autofield_sequence_name.write ((((xself).x_get_no_autofield_sequence_name)).apply ((((unsupported)).apply ((xsequence_info)) ("table"))))
                            xtable.write ((((xself).xquote_name)).apply ((((unsupported)).apply ((xsequence_info)) ("table"))))
                            xcolumn.write ((((xself).xquote_name)).apply (((((unsupported)).apply ((xsequence_info)) ("column")).or "id")))
                            xquery.write (((xself).x_sequence_reset_sql).mod (((unsupported)).apply ("no_autofield_sequence_name") ((xno_autofield_sequence_name)) ("table") ((xtable)) ("column") ((xcolumn)) ("table_name") ((((xstrip_quotes)).apply ((xtable)))) ("column_name") ((((xstrip_quotes)).apply ((xcolumn))))))
                            bogusForceDataize.write ((((xsql).xappend)).apply ((xquery)))
                        (((unsupported)).apply ((xsql)))
                xsequence_reset_sql.write
                  [xself xstyle xmodel_list]
                    memory > xtable
                    memory > xoutput
                    memory > xquery
                    memory > xcolumn
                    memory > xno_autofield_sequence_name
                    seq > @
                      seq
                        xoutput.write (((unsupported)).apply)
                        xquery.write ((xself).x_sequence_reset_sql)
                        (((unsupported)).apply ((xmodel)) ((xmodel_list)))
                          (((unsupported)).apply ((xf)) ((((xmodel).x_meta).xlocal_fields)))
                            (((xisinstance)).apply ((xf)) ((xAutoField))).if
                              seq
                                xno_autofield_sequence_name.write ((((xself).x_get_no_autofield_sequence_name)).apply ((((xmodel).x_meta).xdb_table)))
                                xtable.write ((((xself).xquote_name)).apply ((((xmodel).x_meta).xdb_table)))
                                xcolumn.write ((((xself).xquote_name)).apply (((xf).xcolumn)))
                                bogusForceDataize.write ((((xoutput).xappend)).apply (((xquery).mod (((unsupported)).apply ("no_autofield_sequence_name") ((xno_autofield_sequence_name)) ("table") ((xtable)) ("column") ((xcolumn)) ("table_name") ((((xstrip_quotes)).apply ((xtable)))) ("column_name") ((((xstrip_quotes)).apply ((xcolumn))))))))
                                (((unsupported)).apply)
                        (((unsupported)).apply ((xoutput)))
                xstart_transaction_sql.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (""))
                xtablespace_sql.write
                  [xself xtablespace xinline]
                    seq > @
                      (((unsupported)).apply)
                        (xinline).if
                          (((unsupported)).apply (("USING INDEX TABLESPACE %s".mod ((((xself).xquote_name)).apply ((xtablespace))))))
                          (((unsupported)).apply (("TABLESPACE %s".mod ((((xself).xquote_name)).apply ((xtablespace))))))
                xadapt_datefield_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)))
                xadapt_datetimefield_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((xhasattr)).apply ((xvalue)) ("resolve_expression")).if
                          (((unsupported)).apply ((xvalue)))
                        ((((xtimezone).xis_aware)).apply ((xvalue))).if
                          ((xsettings).xUSE_TZ).if
                            xvalue.write ((((xtimezone).xmake_naive)).apply ((xvalue)) ((((xself).xconnection).xtimezone)))
                            (((unsupported)).apply ((((xValueError)).apply ("Oracle backend does not support timezone-aware datetimes when USE_TZ is False."))))
                        (((unsupported)).apply (((((xOracle_datetime).xfrom_datetime)).apply ((xvalue)))))
                xadapt_timefield_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((xhasattr)).apply ((xvalue)) ("resolve_expression")).if
                          (((unsupported)).apply ((xvalue)))
                        (((xisinstance)).apply ((xvalue)) ((xstr))).if
                          (((unsupported)).apply ((((((xdatetime).xdatetime).xstrptime)).apply ((xvalue)) ("%H:%M:%S"))))
                        ((((xtimezone).xis_aware)).apply ((xvalue))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Oracle backend does not support timezone-aware times."))))
                        (((unsupported)).apply ((((xOracle_datetime)).apply (1900) (1) (1) (((xvalue).xhour)) (((xvalue).xminute)) (((xvalue).xsecond)) (((xvalue).xmicrosecond)))))
                xadapt_decimalfield_value.write
                  [xself xvalue xmax_digits xdecimal_places]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)))
                xcombine_expression.write
                  [xself xconnector xsub_expressions]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xrhs)))) ((xsub_expressions)))
                        ((xconnector).eq "%%").if
                          (((unsupported)).apply (("MOD(%s)".mod (((",".xjoin)).apply ((xsub_expressions))))))
                          ((xconnector).eq "&").if
                            (((unsupported)).apply (("BITAND(%s)".mod (((",".xjoin)).apply ((xsub_expressions))))))
                            ((xconnector).eq "|").if
                              (((unsupported)).apply (("BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s".mod (((unsupported)).apply ("lhs") ((xlhs)) ("rhs") ((xrhs))))))
                              ((xconnector).eq "<<").if
                                (((unsupported)).apply (("(%(lhs)s * POWER(2, %(rhs)s))".mod (((unsupported)).apply ("lhs") ((xlhs)) ("rhs") ((xrhs))))))
                                ((xconnector).eq ">>").if
                                  (((unsupported)).apply (("FLOOR(%(lhs)s / POWER(2, %(rhs)s))".mod (((unsupported)).apply ("lhs") ((xlhs)) ("rhs") ((xrhs))))))
                                  ((xconnector).eq "^").if
                                    (((unsupported)).apply (("POWER(%s)".mod (((",".xjoin)).apply ((xsub_expressions))))))
                                    ((xconnector).eq "#").if
                                      (((unsupported)).apply ((((xNotSupportedError)).apply ("Bitwise XOR is not supported in Oracle."))))
                        (((unsupported)).apply (((((((xsuper)).apply).xcombine_expression)).apply ((xconnector)) ((xsub_expressions)))))
                x_get_no_autofield_sequence_name.write
                  [xself xtable]
                    memory > xname_length
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xname_length.write (((((xself).xmax_name_length)).apply).sub 3)
                        (((unsupported)).apply (("%s_SQ".mod ((((((xtruncate_name)).apply ((((xstrip_quotes)).apply ((xtable)))) ((xname_length))).xupper)).apply))))
                x_get_sequence_name.write
                  [xself xcursor xtable xpk_name]
                    memory > xrow
                    seq > @
                      seq
                        bogusForceDataize.write ((((xcursor).xexecute)).apply ((((unsupported)).apply)) ((((unsupported)).apply ((xtable)) ((xpk_name)))))
                        xrow.write ((((xcursor).xfetchone)).apply)
                        (((unsupported)).apply (((((unsupported)).apply ((xrow)) ("None: is there a None literal in the EO language?")).if ((((xself).x_get_no_autofield_sequence_name)).apply ((xtable))) (((unsupported)).apply ((xrow)) (0)))))
                xbulk_insert_sql.write
                  [xself xfields xplaceholder_rows]
                    memory > xinternal_type
                    memory > xselect
                    memory > xplaceholder
                    memory > xquery
                    seq > @
                      seq
                        xquery.write (((unsupported)).apply)
                        (((unsupported)).apply ((xrow)) ((xplaceholder_rows)))
                          seq
                            xselect.write (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xi)) ((xplaceholder)))) ((((xenumerate)).apply ((xrow)))))
                              seq
                                (((unsupported)).apply ((xfields)) ((xi))).if
                                  seq
                                    xinternal_type.write ((((((xgetattr)).apply ((((unsupported)).apply ((xfields)) ((xi)))) ("target_field") ((((unsupported)).apply ((xfields)) ((xi))))).xget_internal_type)).apply)
                                    xplaceholder.write ((((((xBulkInsertMapper).xtypes).xget)).apply ((xinternal_type)) ("%s")).mod (xplaceholder))
                                ((xquery).not).if
                                  xplaceholder.write ("%s col_%s".mod (((unsupported)).apply ((xplaceholder)) ((xi))))
                                bogusForceDataize.write ((((xselect).xappend)).apply ((xplaceholder)))
                            bogusForceDataize.write ((((xquery).xappend)).apply (("SELECT %s FROM DUAL".mod (((", ".xjoin)).apply ((xselect))))))
                        (((unsupported)).apply (("SELECT * FROM (%s)".mod (((" UNION ALL ".xjoin)).apply ((xquery))))))
                xsubtract_temporals.write
                  [xself xinternal_type xlhs xrhs]
                    memory > xparams
                    seq > @
                      seq
                        ((xinternal_type).eq "DateField").if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((xlhs_params)))) ((xlhs)))
                            (((unsupported)).apply ((((unsupported)).apply ((xrhs_sql)) ((xrhs_params)))) ((xrhs)))
                            xparams.write (((unsupported)).apply ((((unsupported)).apply ((xlhs_params)))) ((((unsupported)).apply ((xrhs_params)))))
                            (((unsupported)).apply ((((unsupported)).apply (("NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')".mod (((unsupported)).apply ((xlhs_sql)) ((xrhs_sql))))) ((xparams)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xsubtract_temporals)).apply ((xinternal_type)) ((xlhs)) ((xrhs)))))
                xbulk_batch_size.write
                  [xself xfields xobjs]
                    seq > @
                      seq
                        unsupported
                        (xfields).if
                          (((unsupported)).apply ((((unsupported)).apply (((((xself).xconnection).xfeatures).xmax_query_params)) ((((xlen)).apply ((xfields)))))))
                        (((unsupported)).apply ((((xlen)).apply ((xobjs)))))
                xconditional_expression_supported_in_where_clause.write
                  [xself xexpression]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xisinstance)).apply ((xexpression)) ((((unsupported)).apply ((xExists)) ((xLookup)) ((xWhereNode))))).if
                          (((unsupported)).apply (TRUE))
                        ((((xisinstance)).apply ((xexpression)) ((xExpressionWrapper))).and ((xexpression).xconditional)).if
                          (((unsupported)).apply (((((xself).xconditional_expression_supported_in_where_clause)).apply (((xexpression).xexpression)))))
                        ((((xisinstance)).apply ((xexpression)) ((xRawSQL))).and ((xexpression).xconditional)).if
                          (((unsupported)).apply (TRUE))
                        (((unsupported)).apply (FALSE))