memory > xbad_row
memory > xtable_name
memory > x_lazy_re_compile
memory > xwarnings
memory > xparse_time
memory > xcursor
memory > xbool
memory > xDatabaseFeatures
memory > xforeign_key_index
memory > xIntegrityError
memory > xbad_value
memory > xImproperlyConfigured
memory > xreferenced_table_name
memory > xparse_datetime
memory > xDatabaseSchemaEditor
memory > xreferenced_column_name
memory > xdecimal
memory > xDatabaseCreation
memory > xstr
memory > xDatabaseOperations
memory > xcolumn_name
memory > xDatabaseClient
memory > xDatabaseIntrospection
memory > xprimary_key_value
memory > xSQLiteCursorWrapper
memory > xRuntimeWarning
memory > xrowid
memory > xBaseDatabaseWrapper
memory > xchain
memory > xs
[] > base
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xregister_functions
        memory > xcreation_class
        memory > xget_database_version
        memory > x_savepoint_allowed
        memory > xis_usable
        memory > xdisplay_name
        memory > xops_class
        memory > xdisable_constraint_checking
        memory > xvendor
        memory > xpattern_ops
        memory > xdecoder
        memory > xenable_constraint_checking
        memory > xget_new_connection
        memory > xDatabase
        memory > xpattern_esc
        memory > xoperators
        memory > xconvert_query
        memory > x_set_autocommit
        memory > xdata_type_check_constraints
        memory > xcreate_cursor
        memory > xclose
        memory > xcheck_constraints
        memory > xintrospection_class
        memory > xis_in_memory_db
        memory > xdata_types
        memory > xSchemaEditorClass
        memory > x_start_transaction_under_autocommit
        memory > xexecute
        memory > xFORMAT_QMARK_REGEX
        memory > xclient_class
        memory > xget_connection_params
        memory > xfeatures_class
        memory > xexecutemany
        memory > xdata_types_suffix
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            xdecoder.write
              [xconv_func]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((unsupported)).apply ((((xconv_func)).apply (((((xs).xdecode)).apply)))))))
            bogusForceDataize.write ((((xDatabase).xregister_converter)).apply ("bool") (("1".x__eq__)))
            bogusForceDataize.write ((((xDatabase).xregister_converter)).apply ("time") ((((xdecoder)).apply ((xparse_time)))))
            bogusForceDataize.write ((((xDatabase).xregister_converter)).apply ("datetime") ((((xdecoder)).apply ((xparse_datetime)))))
            bogusForceDataize.write ((((xDatabase).xregister_converter)).apply ("timestamp") ((((xdecoder)).apply ((xparse_datetime)))))
            bogusForceDataize.write ((((xDatabase).xregister_adapter)).apply (((xdecimal).xDecimal)) ((xstr)))
            (((unsupported)).apply ((xBaseDatabaseWrapper)))
              seq
                xvendor.write "sqlite"
                xdisplay_name.write "SQLite"
                xdata_types.write (((unsupported)).apply ("AutoField") ("integer") ("BigAutoField") ("integer") ("BinaryField") ("BLOB") ("BooleanField") ("bool") ("CharField") ("varchar(%(max_length)s)") ("DateField") ("date") ("DateTimeField") ("datetime") ("DecimalField") ("decimal") ("DurationField") ("bigint") ("FileField") ("varchar(%(max_length)s)") ("FilePathField") ("varchar(%(max_length)s)") ("FloatField") ("real") ("IntegerField") ("integer") ("BigIntegerField") ("bigint") ("IPAddressField") ("char(15)") ("GenericIPAddressField") ("char(39)") ("JSONField") ("text") ("OneToOneField") ("integer") ("PositiveBigIntegerField") ("bigint unsigned") ("PositiveIntegerField") ("integer unsigned") ("PositiveSmallIntegerField") ("smallint unsigned") ("SlugField") ("varchar(%(max_length)s)") ("SmallAutoField") ("integer") ("SmallIntegerField") ("smallint") ("TextField") ("text") ("TimeField") ("time") ("UUIDField") ("char(32)"))
                xdata_type_check_constraints.write (((unsupported)).apply ("PositiveBigIntegerField") ("\"%(column)s\" >= 0") ("JSONField") ("(JSON_VALID(\"%(column)s\") OR \"%(column)s\" IS NULL)") ("PositiveIntegerField") ("\"%(column)s\" >= 0") ("PositiveSmallIntegerField") ("\"%(column)s\" >= 0"))
                xdata_types_suffix.write (((unsupported)).apply ("AutoField") ("AUTOINCREMENT") ("BigAutoField") ("AUTOINCREMENT") ("SmallAutoField") ("AUTOINCREMENT"))
                xoperators.write (((unsupported)).apply ("exact") ("= %s") ("iexact") ("LIKE %s ESCAPE '\\'") ("contains") ("LIKE %s ESCAPE '\\'") ("icontains") ("LIKE %s ESCAPE '\\'") ("regex") ("REGEXP %s") ("iregex") ("REGEXP '(?i)' || %s") ("gt") ("> %s") ("gte") (">= %s") ("lt") ("< %s") ("lte") ("<= %s") ("startswith") ("LIKE %s ESCAPE '\\'") ("endswith") ("LIKE %s ESCAPE '\\'") ("istartswith") ("LIKE %s ESCAPE '\\'") ("iendswith") ("LIKE %s ESCAPE '\\'"))
                xpattern_esc.write "REPLACE(REPLACE(REPLACE({}, '', '\\'), '%%', '%%'), '_', '_')"
                xpattern_ops.write (((unsupported)).apply ("contains") ("LIKE '%%' || {} || '%%' ESCAPE ''") ("icontains") ("LIKE '%%' || UPPER({}) || '%%' ESCAPE ''") ("startswith") ("LIKE {} || '%%' ESCAPE ''") ("istartswith") ("LIKE UPPER({}) || '%%' ESCAPE ''") ("endswith") ("LIKE '%%' || {} ESCAPE ''") ("iendswith") ("LIKE '%%' || UPPER({}) ESCAPE ''"))
                xDatabase.write (xDatabase)
                xSchemaEditorClass.write (xDatabaseSchemaEditor)
                xclient_class.write (xDatabaseClient)
                xcreation_class.write (xDatabaseCreation)
                xfeatures_class.write (xDatabaseFeatures)
                xintrospection_class.write (xDatabaseIntrospection)
                xops_class.write (xDatabaseOperations)
                xget_connection_params.write
                  [xself]
                    memory > xsettings_dict
                    memory > xkwargs
                    seq > @
                      seq
                        xsettings_dict.write ((xself).xsettings_dict)
                        ((((unsupported)).apply ((xsettings_dict)) ("NAME")).not).if
                          (((unsupported)).apply ((((xImproperlyConfigured)).apply ("settings.DATABASES is improperly configured. Please supply the NAME value."))))
                        xkwargs.write (((unsupported)).apply ("database") ((((unsupported)).apply ((xsettings_dict)) ("NAME"))) ("detect_types") ((((xDatabase).xPARSE_DECLTYPES).or ((xDatabase).xPARSE_COLNAMES))) ((((unsupported)).apply ((xsettings_dict)) ("OPTIONS"))))
                        ((((unsupported)).apply ("check_same_thread") ((xkwargs))).and (((unsupported)).apply ((xkwargs)) ("check_same_thread"))).if
                          bogusForceDataize.write ((((xwarnings).xwarn)).apply ("The `check_same_thread` option was provided and set to True. It will be overridden with False. Use the `DatabaseWrapper.allow_thread_sharing` property instead for controlling thread shareability.") ((xRuntimeWarning)))
                        bogusForceDataize.write ((((xkwargs).xupdate)).apply ((((unsupported)).apply ("check_same_thread") (FALSE) ("uri") (TRUE))))
                        (((unsupported)).apply ((xkwargs)))
                xget_database_version.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xself).xDatabase).xsqlite_version_info)))
                xget_new_connection.write
                  [xself xconn_params]
                    memory > xconn
                    seq > @
                      (((unsupported)).apply)
                        xconn.write ((((xDatabase).xconnect)).apply ((((unsupported)).apply ((xconn_params)))))
                        bogusForceDataize.write (((xregister_functions)).apply ((xconn)))
                        bogusForceDataize.write ((((xconn).xexecute)).apply ("PRAGMA foreign_keys = ON"))
                        bogusForceDataize.write ((((xconn).xexecute)).apply ("PRAGMA legacy_alter_table = OFF"))
                        (((unsupported)).apply ((xconn)))
                xcreate_cursor.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((xself).xconnection).xcursor)) ((xSQLiteCursorWrapper)))))
                xclose.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xvalidate_thread_sharing)).apply)
                        (((((xself).xis_in_memory_db)).apply).not).if
                          bogusForceDataize.write ((((xBaseDatabaseWrapper).xclose)).apply ((xself)))
                x_savepoint_allowed.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xself).xin_atomic_block)))
                x_set_autocommit.write
                  [xself xautocommit]
                    memory > xlevel
                    seq > @
                      seq
                        (xautocommit).if
                          xlevel.write "None: is there a None literal in the EO language?"
                          xlevel.write ""
                        (((unsupported)).apply (((xself).xwrap_database_errors)))
                          (((unsupported)).apply ((((xself).xconnection).xisolation_level)) ((xlevel)))
                xdisable_constraint_checking.write
                  [xself]
                    memory > xenabled
                    seq > @
                      seq
                        (((unsupported)).apply (((((xself).xcursor)).apply)) ((xcursor)))
                          seq
                            bogusForceDataize.write ((((xcursor).xexecute)).apply ("PRAGMA foreign_keys = OFF"))
                            xenabled.write (((unsupported)).apply ((((((((xcursor).xexecute)).apply ("PRAGMA foreign_keys")).xfetchone)).apply)) (0))
                        (((unsupported)).apply (((((xbool)).apply ((xenabled))).not)))
                xenable_constraint_checking.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((((xself).xcursor)).apply)) ((xcursor)))
                        bogusForceDataize.write ((((xcursor).xexecute)).apply ("PRAGMA foreign_keys = ON"))
                xcheck_constraints.write
                  [xself xtable_names]
                    memory > xprimary_key_column_name
                    memory > xforeign_key
                    memory > xrelations
                    memory > xviolations
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xself).xfeatures).xsupports_pragma_foreign_key_check).if
                          (((unsupported)).apply (((((xself).xcursor)).apply)) ((xcursor)))
                            seq
                              (((unsupported)).apply ((xtable_names)) ("None: is there a None literal in the EO language?")).if
                                xviolations.write (((((((xcursor).xexecute)).apply ("PRAGMA foreign_key_check")).xfetchall)).apply)
                                xviolations.write ((((xchain).xfrom_iterable)).apply ((((unsupported)).apply ((((((((xcursor).xexecute)).apply (("PRAGMA foreign_key_check(%s)".mod (((((xself).xops).xquote_name)).apply ((xtable_name)))))).xfetchall)).apply)) ((xtable_name)) ((xtable_names)))))
                              (((unsupported)).apply ((((unsupported)).apply ((xtable_name)) ((xrowid)) ((xreferenced_table_name)) ((xforeign_key_index)))) ((xviolations)))
                                seq
                                  xforeign_key.write (((unsupported)).apply ((((((((xcursor).xexecute)).apply (("PRAGMA foreign_key_list(%s)".mod (((((xself).xops).xquote_name)).apply ((xtable_name)))))).xfetchall)).apply)) ((xforeign_key_index)))
                                  (((unsupported)).apply ((((unsupported)).apply ((xcolumn_name)) ((xreferenced_column_name)))) ((((unsupported)).apply ((xforeign_key)) ((((unsupported)).apply (3) (5))))))
                                  xprimary_key_column_name.write (((((xself).xintrospection).xget_primary_key_column)).apply ((xcursor)) ((xtable_name)))
                                  (((unsupported)).apply ((((unsupported)).apply ((xprimary_key_value)) ((xbad_value)))) ((((((((xcursor).xexecute)).apply (("SELECT %s, %s FROM %s WHERE rowid = %%s".mod (((unsupported)).apply ((((((xself).xops).xquote_name)).apply ((xprimary_key_column_name)))) ((((((xself).xops).xquote_name)).apply ((xcolumn_name)))) ((((((xself).xops).xquote_name)).apply ((xtable_name))))))) ((((unsupported)).apply ((xrowid))))).xfetchone)).apply)))
                                  (((unsupported)).apply ((((xIntegrityError)).apply (("The row in table '%s' with primary key '%s' has an invalid foreign key: %s.%s contains a value '%s' that does not have a corresponding value in %s.%s.".mod (((unsupported)).apply ((xtable_name)) ((xprimary_key_value)) ((xtable_name)) ((xcolumn_name)) ((xbad_value)) ((xreferenced_table_name)) ((xreferenced_column_name))))))))
                          (((unsupported)).apply (((((xself).xcursor)).apply)) ((xcursor)))
                            seq
                              (((unsupported)).apply ((xtable_names)) ("None: is there a None literal in the EO language?")).if
                                xtable_names.write (((((xself).xintrospection).xtable_names)).apply ((xcursor)))
                              (((unsupported)).apply ((xtable_name)) ((xtable_names)))
                                seq
                                  xprimary_key_column_name.write (((((xself).xintrospection).xget_primary_key_column)).apply ((xcursor)) ((xtable_name)))
                                  ((xprimary_key_column_name).not).if
                                    (((unsupported)).apply)
                                  xrelations.write (((((xself).xintrospection).xget_relations)).apply ((xcursor)) ((xtable_name)))
                                  (((unsupported)).apply ((((unsupported)).apply ((xcolumn_name)) ((((unsupported)).apply ((xreferenced_column_name)) ((xreferenced_table_name)))))) ((xrelations)))
                                    seq
                                      bogusForceDataize.write ((((xcursor).xexecute)).apply (((((unsupported)).apply).mod (((unsupported)).apply ((xprimary_key_column_name)) ((xcolumn_name)) ((xtable_name)) ((xreferenced_table_name)) ((xcolumn_name)) ((xreferenced_column_name)) ((xcolumn_name)) ((xreferenced_column_name))))))
                                      (((unsupported)).apply ((xbad_row)) (((((xcursor).xfetchall)).apply)))
                                        (((unsupported)).apply ((((xIntegrityError)).apply (("The row in table '%s' with primary key '%s' has an invalid foreign key: %s.%s contains a value '%s' that does not have a corresponding value in %s.%s.".mod (((unsupported)).apply ((xtable_name)) ((((unsupported)).apply ((xbad_row)) (0))) ((xtable_name)) ((xcolumn_name)) ((((unsupported)).apply ((xbad_row)) (1))) ((xreferenced_table_name)) ((xreferenced_column_name))))))))
                xis_usable.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (TRUE))
                x_start_transaction_under_autocommit.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        bogusForceDataize.write (((((((xself).xcursor)).apply).xexecute)).apply ("BEGIN"))
                xis_in_memory_db.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((((xself).xcreation).xis_in_memory_db)).apply ((((unsupported)).apply (((xself).xsettings_dict)) ("NAME"))))))
            xFORMAT_QMARK_REGEX.write (((x_lazy_re_compile)).apply ("(?<!%)%s"))
            (((unsupported)).apply (((xDatabase).xCursor)))
              seq
                (((unsupported)).apply)
                xexecute.write
                  [xself xquery xparams]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xparams)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((((xDatabase).xCursor).xexecute)).apply ((xself)) ((xquery)))))
                        xquery.write ((((xself).xconvert_query)).apply ((xquery)))
                        (((unsupported)).apply ((((((xDatabase).xCursor).xexecute)).apply ((xself)) ((xquery)) ((xparams)))))
                xexecutemany.write
                  [xself xquery xparam_list]
                    seq > @
                      seq
                        xquery.write ((((xself).xconvert_query)).apply ((xquery)))
                        (((unsupported)).apply ((((((xDatabase).xCursor).xexecutemany)).apply ((xself)) ((xquery)) ((xparam_list)))))
                xconvert_query.write
                  [xself xquery]
                    seq > @
                      (((unsupported)).apply ((((((((xFORMAT_QMARK_REGEX).xsub)).apply ("?") ((xquery))).xreplace)).apply ("%%") ("%"))))