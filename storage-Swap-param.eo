memory > xsafe_join
memory > xdatetime
memory > xfile_ext
memory > xValueError
memory > xFileNotFoundError
memory > xNotImplementedError
memory > xentry
memory > xpathlib
memory > xfile_name
memory > xbytes
memory > xfiles
memory > xgetattr
memory > xfile_move_safe
memory > xvalidate_file_name
memory > xFileExistsError
memory > xentries
memory > xdirectories
memory > xLazyObject
memory > xtimezone
memory > ximport_string
memory > xstr
memory > xdeconstructible
memory > xfilepath_to_uri
memory > xget_random_string
memory > xsettings
memory > xSuspiciousFileOperation
memory > xget_valid_filename
memory > xhasattr
memory > xDefaultStorage
memory > xFile
memory > xos
memory > xdir_name
memory > xdirname
memory > xchunk
memory > xsetting_changed
memory > xStorage
memory > xisinstance
memory > xurljoin
memory > xlocks
memory > xlen
[] > storage
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xget_storage_class
        memory > xbase_location
        memory > xsize
        memory > xbase_url
        memory > xopen
        memory > xpath
        memory > x_open
        memory > xlistdir
        memory > xexists
        memory > x__init__
        memory > x_datetime_from_timestamp
        memory > xlocation
        memory > x_setup
        memory > xdelete
        memory > xget_alternative_name
        memory > xsave
        memory > xfile_permissions_mode
        memory > xdirectory_permissions_mode
        memory > xurl
        memory > x__all__
        memory > xOS_OPEN_FLAGS
        memory > xdefault_storage
        memory > x_clear_cached_properties
        memory > xget_modified_time
        memory > xget_created_time
        memory > xgenerate_filename
        memory > x_save
        memory > xget_available_name
        memory > x_value_or_setting
        memory > xget_valid_name
        memory > xget_accessed_time
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x__all__.write (((unsupported)).apply ("Storage") ("FileSystemStorage") ("DefaultStorage") ("default_storage") ("get_storage_class"))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xopen.write
                  [xself xname xmode]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        (((unsupported)).apply (((((xself).x_open)).apply ((xname)) ((xmode)))))
                xsave.write
                  [xself xname xcontent xmax_length]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xname)) ("None: is there a None literal in the EO language?")).if
                          xname.write ((xcontent).xname)
                        ((((xhasattr)).apply ((xcontent)) ("chunks")).not).if
                          xcontent.write (((xFile)).apply ((xname)) ((xcontent)))
                        xname.write (((unsupported)).apply (((xself).xget_available_name)) ((xname)) ((xmax_length)))
                        xname.write ((((xself).x_save)).apply ((xname)) ((xcontent)))
                        (((unsupported)).apply ((xvalidate_file_name)) ((xname)) (TRUE))
                        (((unsupported)).apply ((xname)))
                xget_valid_name.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xget_valid_filename)).apply ((xname)))))
                xget_alternative_name.write
                  [xself xfile_root xfile_ext]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (("%s_%s%s".mod (((unsupported)).apply ((xfile_root)) ((((xget_random_string)).apply (7))) ((xfile_ext))))))
                xget_available_name.write
                  [xself xname xmax_length]
                    memory > xtruncation
                    memory > xfile_root
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xname.write ((((((xstr)).apply ((xname))).xreplace)).apply ("\\") ("/"))
                        (((unsupported)).apply ((((unsupported)).apply ((xdir_name)) ((xfile_name)))) ((((((xos).xpath).xsplit)).apply ((xname)))))
                        (((unsupported)).apply ("..") ((((((xpathlib).xPurePath)).apply ((xdir_name))).xparts))).if
                          (((unsupported)).apply ((((xSuspiciousFileOperation)).apply (("Detected path traversal attempt in '%s'".mod (xdir_name))))))
                        bogusForceDataize.write (((xvalidate_file_name)).apply ((xfile_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xfile_root)) ((xfile_ext)))) ((((((xos).xpath).xsplitext)).apply ((xfile_name)))))
                        while.
                          (((((xself).xexists)).apply ((xname))).or ((xmax_length).and ((((xlen)).apply ((xname))).greater (xmax_length))))
                          [unused]
                            seq > @
                              seq
                                xname.write (((((xos).xpath).xjoin)).apply ((xdir_name)) (((((xself).xget_alternative_name)).apply ((xfile_root)) ((xfile_ext)))))
                                (((unsupported)).apply ((xmax_length)) ("None: is there a None literal in the EO language?")).if
                                  (((unsupported)).apply)
                                xtruncation.write ((((xlen)).apply ((xname))).sub (xmax_length))
                                ((xtruncation).greater 0).if
                                  seq
                                    xfile_root.write (((unsupported)).apply ((xfile_root)) ((((unsupported)).apply (((xtruncation).neg)))))
                                    ((xfile_root).not).if
                                      (((unsupported)).apply ((((xSuspiciousFileOperation)).apply (("Storage can not find an available filename for \"%s\". Please make sure that the corresponding file field allows sufficient \"max_length\".".mod (xname))))))
                                    xname.write (((((xos).xpath).xjoin)).apply ((xdir_name)) (((((xself).xget_alternative_name)).apply ((xfile_root)) ((xfile_ext)))))
                        (((unsupported)).apply ((xname)))
                xgenerate_filename.write
                  [xself xfilename]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xfilename.write ((((((xstr)).apply ((xfilename))).xreplace)).apply ("\\") ("/"))
                        (((unsupported)).apply ((((unsupported)).apply ((xdirname)) ((xfilename)))) ((((((xos).xpath).xsplit)).apply ((xfilename)))))
                        (((unsupported)).apply ("..") ((((((xpathlib).xPurePath)).apply ((xdirname))).xparts))).if
                          (((unsupported)).apply ((((xSuspiciousFileOperation)).apply (("Detected path traversal attempt in '%s'".mod (xdirname))))))
                        (((unsupported)).apply ((((((xos).xpath).xnormpath)).apply ((((((xos).xpath).xjoin)).apply ((xdirname)) (((((xself).xget_valid_name)).apply ((xfilename)))))))))
                xpath.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("This backend doesn't support absolute paths."))))
                xdelete.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide a delete() method"))))
                xexists.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide an exists() method"))))
                xlistdir.write
                  [xself xpath]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide a listdir() method"))))
                xsize.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide a size() method"))))
                xurl.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide a url() method"))))
                xget_accessed_time.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide a get_accessed_time() method"))))
                xget_created_time.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide a get_created_time() method"))))
                xget_modified_time.write
                  [xself xname]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("subclasses of Storage must provide a get_modified_time() method"))))
            (((unsupported)).apply ((xStorage)) ((xdeconstructible)))
              seq
                (((unsupported)).apply)
                xOS_OPEN_FLAGS.write (((((xos).xO_WRONLY).or ((xos).xO_CREAT)).or ((xos).xO_EXCL)).or (((xgetattr)).apply ((xos)) ("O_BINARY") (0)))
                x__init__.write
                  [xself xlocation xbase_url xfile_permissions_mode xdirectory_permissions_mode]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_location)) ((xlocation)))
                        (((unsupported)).apply (((xself).x_base_url)) ((xbase_url)))
                        (((unsupported)).apply (((xself).x_file_permissions_mode)) ((xfile_permissions_mode)))
                        (((unsupported)).apply (((xself).x_directory_permissions_mode)) ((xdirectory_permissions_mode)))
                        bogusForceDataize.write ((((xsetting_changed).xconnect)).apply (((xself).x_clear_cached_properties)))
                x_clear_cached_properties.write
                  [xself xsetting]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        ((xsetting).eq "MEDIA_ROOT").if
                          seq
                            bogusForceDataize.write (((((xself).x__dict__).xpop)).apply ("base_location") ("None: is there a None literal in the EO language?"))
                            bogusForceDataize.write (((((xself).x__dict__).xpop)).apply ("location") ("None: is there a None literal in the EO language?"))
                          ((xsetting).eq "MEDIA_URL").if
                            bogusForceDataize.write (((((xself).x__dict__).xpop)).apply ("base_url") ("None: is there a None literal in the EO language?"))
                            ((xsetting).eq "FILE_UPLOAD_PERMISSIONS").if
                              bogusForceDataize.write (((((xself).x__dict__).xpop)).apply ("file_permissions_mode") ("None: is there a None literal in the EO language?"))
                              ((xsetting).eq "FILE_UPLOAD_DIRECTORY_PERMISSIONS").if
                                bogusForceDataize.write (((((xself).x__dict__).xpop)).apply ("directory_permissions_mode") ("None: is there a None literal in the EO language?"))
                x_value_or_setting.write
                  [xself xvalue xsetting]
                    seq > @
                      (((unsupported)).apply (((((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if (xsetting) (xvalue))))
                xbase_location.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_value_or_setting)).apply (((xself).x_location)) (((xsettings).xMEDIA_ROOT)))))
                xlocation.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((((xos).xpath).xabspath)).apply (((xself).xbase_location)))))
                xbase_url.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        ((((unsupported)).apply (((xself).x_base_url)) ("None: is there a None literal in the EO language?")).and ((((((xself).x_base_url).xendswith)).apply ("/")).not)).if
                          (((unsupported)).apply (((xself).x_base_url)) ("/"))
                        (((unsupported)).apply (((((xself).x_value_or_setting)).apply (((xself).x_base_url)) (((xsettings).xMEDIA_URL)))))
                xfile_permissions_mode.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_value_or_setting)).apply (((xself).x_file_permissions_mode)) (((xsettings).xFILE_UPLOAD_PERMISSIONS)))))
                xdirectory_permissions_mode.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_value_or_setting)).apply (((xself).x_directory_permissions_mode)) (((xsettings).xFILE_UPLOAD_DIRECTORY_PERMISSIONS)))))
                x_open.write
                  [xself xname xmode]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xFile)).apply ((((xopen)).apply (((((xself).xpath)).apply ((xname)))) ((xmode)))))))
                x_save.write
                  [xself xname xcontent]
                    memory > xfd
                    memory > xmode
                    memory > xold_umask
                    memory > x_file
                    memory > xfull_path
                    memory > xdirectory
                    seq > @
                      seq
                        xfull_path.write ((((xself).xpath)).apply ((xname)))
                        xdirectory.write (((((xos).xpath).xdirname)).apply ((xfull_path)))
                        (((unsupported)).apply ((xFileExistsError)))
                          (((unsupported)).apply (((xself).xdirectory_permissions_mode)) ("None: is there a None literal in the EO language?")).if
                            seq
                              xold_umask.write ((((xos).xumask)).apply ((511.and (((xself).xdirectory_permissions_mode).neg))))
                              (((unsupported)).apply)
                                (((unsupported)).apply (((xos).xmakedirs)) ((xdirectory)) (((xself).xdirectory_permissions_mode)) (TRUE))
                                bogusForceDataize.write ((((xos).xumask)).apply ((xold_umask)))
                            (((unsupported)).apply (((xos).xmakedirs)) ((xdirectory)) (TRUE))
                          (((unsupported)).apply ((((xFileExistsError)).apply (("%s exists and is not a directory.".mod (xdirectory))))))
                        while.
                          TRUE
                          [unused]
                            seq > @
                              (((unsupported)).apply ((xFileExistsError)))
                                (((xhasattr)).apply ((xcontent)) ("temporary_file_path")).if
                                  bogusForceDataize.write (((xfile_move_safe)).apply (((((xcontent).xtemporary_file_path)).apply)) ((xfull_path)))
                                  seq
                                    xfd.write ((((xos).xopen)).apply ((xfull_path)) (((xself).xOS_OPEN_FLAGS)) (438))
                                    x_file.write "None: is there a None literal in the EO language?"
                                    (((unsupported)).apply)
                                      seq
                                        bogusForceDataize.write ((((xlocks).xlock)).apply ((xfd)) (((xlocks).xLOCK_EX)))
                                        (((unsupported)).apply ((xchunk)) (((((xcontent).xchunks)).apply)))
                                          seq
                                            (((unsupported)).apply ((x_file)) ("None: is there a None literal in the EO language?")).if
                                              seq
                                                xmode.write ((((xisinstance)).apply ((xchunk)) ((xbytes))).if "wb" "wt")
                                                x_file.write ((((xos).xfdopen)).apply ((xfd)) ((xmode)))
                                            bogusForceDataize.write ((((x_file).xwrite)).apply ((xchunk)))
                                      seq
                                        bogusForceDataize.write ((((xlocks).xunlock)).apply ((xfd)))
                                        (((unsupported)).apply ((x_file)) ("None: is there a None literal in the EO language?")).if
                                          bogusForceDataize.write ((((x_file).xclose)).apply)
                                          bogusForceDataize.write ((((xos).xclose)).apply ((xfd)))
                                seq
                                  xname.write ((((xself).xget_available_name)).apply ((xname)))
                                  xfull_path.write ((((xself).xpath)).apply ((xname)))
                                (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xfile_permissions_mode)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xos).xchmod)).apply ((xfull_path)) (((xself).xfile_permissions_mode)))
                        xname.write (((((xos).xpath).xrelpath)).apply ((xfull_path)) (((xself).xlocation)))
                        (((unsupported)).apply (((((((xstr)).apply ((xname))).xreplace)).apply ("\\") ("/"))))
                xdelete.write
                  [xself xname]
                    seq > @
                      seq
                        ((xname).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("The name must be given to delete()."))))
                        xname.write ((((xself).xpath)).apply ((xname)))
                        (((unsupported)).apply ((xFileNotFoundError)))
                          (((((xos).xpath).xisdir)).apply ((xname))).if
                            bogusForceDataize.write ((((xos).xrmdir)).apply ((xname)))
                            bogusForceDataize.write ((((xos).xremove)).apply ((xname)))
                xexists.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply ((((((xos).xpath).xlexists)).apply (((((xself).xpath)).apply ((xname)))))))
                xlistdir.write
                  [xself xpath]
                    seq > @
                      seq
                        xpath.write ((((xself).xpath)).apply ((xpath)))
                        (((unsupported)).apply ((((unsupported)).apply ((xdirectories)) ((xfiles)))) ((((unsupported)).apply ((((unsupported)).apply)) ((((unsupported)).apply)))))
                        (((unsupported)).apply (((((xos).xscandir)).apply ((xpath)))) ((xentries)))
                          (((unsupported)).apply ((xentry)) ((xentries)))
                            ((((xentry).xis_dir)).apply).if
                              bogusForceDataize.write ((((xdirectories).xappend)).apply (((xentry).xname)))
                              bogusForceDataize.write ((((xfiles).xappend)).apply (((xentry).xname)))
                        (((unsupported)).apply ((((unsupported)).apply ((xdirectories)) ((xfiles)))))
                xpath.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply ((((xsafe_join)).apply (((xself).xlocation)) ((xname)))))
                xsize.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply ((((((xos).xpath).xgetsize)).apply (((((xself).xpath)).apply ((xname)))))))
                xurl.write
                  [xself xname]
                    memory > xurl
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xbase_url)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xValueError)).apply ("This file is not accessible via a URL."))))
                        xurl.write (((xfilepath_to_uri)).apply ((xname)))
                        (((unsupported)).apply ((xurl)) ("None: is there a None literal in the EO language?")).if
                          xurl.write ((((xurl).xlstrip)).apply ("/"))
                        (((unsupported)).apply ((((xurljoin)).apply (((xself).xbase_url)) ((xurl)))))
                x_datetime_from_timestamp.write
                  [xself xts]
                    memory > xtz
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xtz.write (((xsettings).xUSE_TZ).if ((xtimezone).xutc) "None: is there a None literal in the EO language?")
                        (((unsupported)).apply ((((unsupported)).apply (((xdatetime).xfromtimestamp)) ((xts)) ((xtz)))))
                xget_accessed_time.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply (((((xself).x_datetime_from_timestamp)).apply ((((((xos).xpath).xgetatime)).apply (((((xself).xpath)).apply ((xname)))))))))
                xget_created_time.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply (((((xself).x_datetime_from_timestamp)).apply ((((((xos).xpath).xgetctime)).apply (((((xself).xpath)).apply ((xname)))))))))
                xget_modified_time.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply (((((xself).x_datetime_from_timestamp)).apply ((((((xos).xpath).xgetmtime)).apply (((((xself).xpath)).apply ((xname)))))))))
            xget_storage_class.write
              [ximport_path]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply ((((ximport_string)).apply (((ximport_path).or ((xsettings).xDEFAULT_FILE_STORAGE))))))
            (((unsupported)).apply ((xLazyObject)))
              x_setup.write
                [xself]
                  seq > @
                    (((unsupported)).apply (((xself).x_wrapped)) ((((((xget_storage_class)).apply)).apply)))
            xdefault_storage.write (((xDefaultStorage)).apply)