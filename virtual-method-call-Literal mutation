+package org.eolang
+alias goto org.eolang.gray.goto
+alias stdout org.eolang.io.stdout
+alias cage org.eolang.gray.cage
+junit

[unused] > virtual-method-call
  [raiseme] > apply
    [x] > mkCopy
      x' > copy
      copy.< > @
    [] > newUID
      memory > cur
      seq > apply
        cur.write (cur.is-empty.if 2 (cur.add 1))
        cur
    [] > raiseEmpty
      [] > xclass
        1 > xid
    [] > raiseNothing
      [] > xclass
        0 > xid
    cage > xcurrent-exception
    cage > result
    cage > tmp
    cage > xmyC
    goto > @
      [returnLabel]
        seq > @
          stdout "virtual-method-call\n"
          write.
            xmyC
            []
              [raiseme] > apply
                cage > result
                cage > tmp
                cage > e6
                cage > xd
                cage > e7
                cage > xo
                cage > xc
                cage > e4
                cage > lhs6
                cage > lhs4
                cage > e5
                goto > @
                  [returnLabel]
                    seq > @
                      stdout "xmyC\n"
                      write.
                        xc
                        []
                          newUID.apply 0 > xid
                          [unused] > apply
                            [] > result
                              cage > xh
                              cage > xg
                              xc > xclass
                              seq > initFields
                                write.
                                  xh
                                  []
                                    [raiseme xselfNotCopied] > apply
                                      cage > result
                                      cage > tmp
                                      xselfNotCopied' > xself
                                      goto > @
                                        [returnLabel]
                                          seq > @
                                            stdout "xh\n"
                                            xself.<
                                            (result).write (1)
                                            returnLabel.forward 0
                                            123
                                write.
                                  xg
                                  []
                                    [raiseme xselfNotCopied] > apply
                                      cage > result
                                      cage > tmp
                                      xselfNotCopied' > xself
                                      cage > lhs0
                                      cage > e1
                                      cage > e0
                                      goto > @
                                        [returnLabel]
                                          seq > @
                                            stdout "xg\n"
                                            xself.<
                                            mkCopy (xself.xh) > tmp1
                                            (e0).write (tmp1.copy)
                                            mkCopy (xself) > tmp2
                                            (lhs0).write (tmp2.copy)
                                            tmp.write (((e0)).apply raiseme ((lhs0)))
                                            (tmp.@)
                                            (e1).write (tmp.result)
                                            mkCopy (e1) > tmp3
                                            (result).write (tmp3.copy)
                                            returnLabel.forward 0
                                            123
                            result.initFields > @
                      write.
                        xd
                        []
                          newUID.apply 0 > xid
                          [unused] > apply
                            [] > result
                              cage > xh
                              cage > xf
                              (xc).apply 0 > base
                              xd > xclass
                              seq > initFields
                                write.
                                  xh
                                  []
                                    [raiseme xselfNotCopied] > apply
                                      cage > result
                                      cage > tmp
                                      xselfNotCopied' > xself
                                      goto > @
                                        [returnLabel]
                                          seq > @
                                            stdout "xh\n"
                                            xself.<
                                            (result).write (3)
                                            returnLabel.forward 0
                                            123
                                write.
                                  xf
                                  []
                                    [raiseme xselfNotCopied] > apply
                                      cage > result
                                      cage > tmp
                                      xselfNotCopied' > xself
                                      cage > lhs2
                                      cage > e3
                                      cage > e2
                                      goto > @
                                        [returnLabel]
                                          seq > @
                                            stdout "xf\n"
                                            xself.<
                                            mkCopy (xself.xg) > tmp4
                                            (e2).write (tmp4.copy)
                                            mkCopy (xself) > tmp5
                                            (lhs2).write (tmp5.copy)
                                            tmp.write (((e2)).apply raiseme ((lhs2)))
                                            (tmp.@)
                                            (e3).write (tmp.result)
                                            mkCopy (e3) > tmp6
                                            (result).write (tmp6.copy)
                                            returnLabel.forward 0
                                            123
                                base
                              base.result > @
                            result.initFields > @
                      tmp.write (((xd)).apply raiseme)
                      (tmp.@)
                      (e4).write (tmp.result)
                      mkCopy (e4) > tmp7
                      (xo).write (tmp7.copy)
                      mkCopy (xo.xf) > tmp8
                      (e5).write (tmp8.copy)
                      mkCopy (xo) > tmp9
                      (lhs4).write (tmp9.copy)
                      tmp.write (((e5)).apply raiseme ((lhs4)))
                      (tmp.@)
                      (e6).write (tmp.result)
                      (lhs6).write (2)
                      [] > tmp10
                        memory > dddata
                        dddata.write (((e6).eq (lhs6))) > @
                      (e7).write (tmp10.dddata)
                      mkCopy (e7) > tmp11
                      (result).write (tmp11.copy)
                      returnLabel.forward 0
                      123
          tmp.write (((xmyC)).apply raiseme)
          (tmp.@)
          (result).write (tmp.result)
          result
  apply 0 > @