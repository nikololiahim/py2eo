memory > xapp
memory > xurl_has_allowed_host_and_scheme
memory > xValueError
memory > xstr
memory > xapps
memory > xp
memory > xi
memory > xHttpResponseRedirect
memory > xv
memory > xkwargs
memory > xContext
memory > xk
memory > xDjangoTranslation
memory > xtranslate_url
memory > xel
memory > xget_format
memory > xrange
memory > xEngine
memory > xvalue
memory > xmsgid
memory > xcheck_for_language
memory > xJsonResponse
memory > xView
memory > xHttpResponse
memory > xset
memory > xsettings
memory > xint
memory > xre
memory > xcnt
memory > xtuple
memory > xitertools
memory > xos
memory > xJavaScriptCatalog
memory > xapp_config
memory > xattr
memory > xjson
memory > xget_language
memory > xisinstance
memory > xline
memory > xlen
memory > xTypeError
memory > xkey
[] > i18n
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xrender_to_response
        memory > xget_catalog
        memory > xget
        memory > xget_formats
        memory > xpackages
        memory > xget_plural
        memory > x_plural_string
        memory > xjs_catalog_template
        memory > xdomain
        memory > xget_context_data
        memory > xset_language
        memory > xLANGUAGE_QUERY_PARAMETER
        memory > xget_paths
        memory > x_num_plurals
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            xLANGUAGE_QUERY_PARAMETER.write "language"
            xset_language.write
              [xrequest]
                memory > xnext_url
                memory > xresponse
                memory > xnext_trans
                memory > xlang_code
                seq > @
                  seq
                    (((unsupported)).apply)
                    xnext_url.write (((((xrequest).xPOST).xget)).apply ("next") ((((((xrequest).xGET).xget)).apply ("next"))))
                    (((xnext_url).or ((((xrequest).xaccepts)).apply ("text/html"))).and ((((unsupported)).apply ((xurl_has_allowed_host_and_scheme)) ((xnext_url)) ((((unsupported)).apply (((((xrequest).xget_host)).apply)))) (((((xrequest).xis_secure)).apply))).not)).if
                      seq
                        xnext_url.write (((((xrequest).xMETA).xget)).apply ("HTTP_REFERER"))
                        ((((unsupported)).apply ((xurl_has_allowed_host_and_scheme)) ((xnext_url)) ((((unsupported)).apply (((((xrequest).xget_host)).apply)))) (((((xrequest).xis_secure)).apply))).not).if
                          xnext_url.write "/"
                    xresponse.write ((xnext_url).if (((xHttpResponseRedirect)).apply ((xnext_url))) (((unsupported)).apply ((xHttpResponse)) (204)))
                    (((xrequest).xmethod).eq "POST").if
                      seq
                        xlang_code.write (((((xrequest).xPOST).xget)).apply ((xLANGUAGE_QUERY_PARAMETER)))
                        ((xlang_code).and (((xcheck_for_language)).apply ((xlang_code)))).if
                          seq
                            (xnext_url).if
                              seq
                                xnext_trans.write (((xtranslate_url)).apply ((xnext_url)) ((xlang_code)))
                                ((xnext_trans).neq (xnext_url)).if
                                  xresponse.write (((xHttpResponseRedirect)).apply ((xnext_trans)))
                            (((unsupported)).apply (((xresponse).xset_cookie)) (((xsettings).xLANGUAGE_COOKIE_NAME)) ((xlang_code)) (((xsettings).xLANGUAGE_COOKIE_AGE)) (((xsettings).xLANGUAGE_COOKIE_PATH)) (((xsettings).xLANGUAGE_COOKIE_DOMAIN)) (((xsettings).xLANGUAGE_COOKIE_SECURE)) (((xsettings).xLANGUAGE_COOKIE_HTTPONLY)) (((xsettings).xLANGUAGE_COOKIE_SAMESITE)))
                    (((unsupported)).apply ((xresponse)))
            xget_formats.write
              []
                memory > xFORMAT_SETTINGS
                seq > @
                  seq
                    unsupported
                    xFORMAT_SETTINGS.write (((unsupported)).apply ("DATE_FORMAT") ("DATETIME_FORMAT") ("TIME_FORMAT") ("YEAR_MONTH_FORMAT") ("MONTH_DAY_FORMAT") ("SHORT_DATE_FORMAT") ("SHORT_DATETIME_FORMAT") ("FIRST_DAY_OF_WEEK") ("DECIMAL_SEPARATOR") ("THOUSAND_SEPARATOR") ("NUMBER_GROUPING") ("DATE_INPUT_FORMATS") ("TIME_INPUT_FORMATS") ("DATETIME_INPUT_FORMATS"))
                    (((unsupported)).apply ((((unsupported)).apply ((xattr)) ((((xget_format)).apply ((xattr)))) ((xattr)) ((xFORMAT_SETTINGS)))))
            xjs_catalog_template.write (((unsupported)).apply)
            (((unsupported)).apply ((xView)))
              seq
                (((unsupported)).apply)
                xdomain.write "djangojs"
                xpackages.write "None: is there a None literal in the EO language?"
                xget.write
                  [xself xrequest]
                    memory > xcontext
                    memory > xpaths
                    memory > xpackages
                    memory > xlocale
                    memory > xdomain
                    seq > @
                      (((unsupported)).apply)
                        xlocale.write (((xget_language)).apply)
                        xdomain.write ((((xkwargs).xget)).apply ("domain") (((xself).xdomain)))
                        xpackages.write ((((xkwargs).xget)).apply ("packages") (""))
                        xpackages.write ((xpackages).if ((((xpackages).xsplit)).apply ("+")) ((xself).xpackages))
                        xpaths.write ((xpackages).if ((((xself).xget_paths)).apply ((xpackages))) "None: is there a None literal in the EO language?")
                        (((unsupported)).apply (((xself).xtranslation)) ((((unsupported)).apply ((xDjangoTranslation)) ((xlocale)) ((xdomain)) ((xpaths)))))
                        xcontext.write ((((xself).xget_context_data)).apply ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((((xself).xrender_to_response)).apply ((xcontext)))))
                xget_paths.write
                  [xself xpackages]
                    memory > xapp_configs
                    memory > xallowable_packages
                    memory > xexcluded
                    seq > @
                      seq
                        xallowable_packages.write (((unsupported)).apply (((xapp_config).xname)) ((xapp_config)) ((xapp_config)) (((((xapps).xget_app_configs)).apply)))
                        xapp_configs.write (((unsupported)).apply ((((unsupported)).apply ((xallowable_packages)) ((xp)))) ((xp)) ((xpackages)) ((((unsupported)).apply ((xp)) ((xallowable_packages)))))
                        ((((xlen)).apply ((xapp_configs))).less (((xlen)).apply ((xpackages)))).if
                          seq
                            xexcluded.write (((unsupported)).apply ((xp)) ((xp)) ((xpackages)) ((((unsupported)).apply ((xp)) ((xallowable_packages)))))
                            (((unsupported)).apply ((((xValueError)).apply (("Invalid package(s) provided to JavaScriptCatalog: %s".mod (((",".xjoin)).apply ((xexcluded))))))))
                        (((unsupported)).apply ((((unsupported)).apply ((((((xos).xpath).xjoin)).apply (((xapp).xpath)) ("locale"))) ((xapp)) ((xapp_configs)))))
                x_num_plurals.write
                  [xself]
                    memory > xmatch
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xmatch.write ((((xre).xsearch)).apply ("nplurals=s*(d+)") ((((xself).x_plural_string).or "")))
                        (xmatch).if
                          (((unsupported)).apply ((((xint)).apply ((((unsupported)).apply ((xmatch)) (1))))))
                        (((unsupported)).apply (2))
                x_plural_string.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ("") ((((xself).xtranslation).x_catalog))).if
                          (((unsupported)).apply ((xline)) (((((((unsupported)).apply ((((xself).xtranslation).x_catalog)) ("")).xsplit)).apply ("n"))))
                            ((((xline).xstartswith)).apply ("Plural-Forms:")).if
                              (((unsupported)).apply (((((((unsupported)).apply (((((xline).xsplit)).apply (":") (1))) (1)).xstrip)).apply)))
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xget_plural.write
                  [xself]
                    memory > xplural
                    seq > @
                      seq
                        xplural.write ((xself).x_plural_string)
                        (((unsupported)).apply ((xplural)) ("None: is there a None literal in the EO language?")).if
                          xplural.write (((unsupported)).apply (((((((unsupported)).apply ((((unsupported)).apply (((((xel).xstrip)).apply)) ((xel)) (((((xplural).xsplit)).apply (";"))) ((((((((xel).xstrip)).apply).xstartswith)).apply ("plural="))))) (0)).xsplit)).apply ("=") (1))) (1))
                        (((unsupported)).apply ((xplural)))
                xget_catalog.write
                  [xself]
                    memory > xseen_keys
                    memory > xcatalog
                    memory > xtrans_fallback_cat
                    memory > xtrans_cat
                    memory > xpdict
                    memory > xnum_plurals
                    seq > @
                      seq
                        xpdict.write (((unsupported)).apply)
                        xnum_plurals.write ((xself).x_num_plurals)
                        xcatalog.write (((unsupported)).apply)
                        xtrans_cat.write (((xself).xtranslation).x_catalog)
                        xtrans_fallback_cat.write ((((xself).xtranslation).x_fallback).if ((((xself).xtranslation).x_fallback).x_catalog) (((unsupported)).apply))
                        xseen_keys.write (((xset)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xvalue)))) (((((xitertools).xchain)).apply (((((xtrans_cat).xitems)).apply)) (((((xtrans_fallback_cat).xitems)).apply)))))
                          seq
                            (((xkey).eq "").or (((unsupported)).apply ((xkey)) ((xseen_keys)))).if
                              (((unsupported)).apply)
                            (((xisinstance)).apply ((xkey)) ((xstr))).if
                              (((unsupported)).apply ((((unsupported)).apply ((xcatalog)) ((xkey)))) ((xvalue)))
                              (((xisinstance)).apply ((xkey)) ((xtuple))).if
                                seq
                                  (((unsupported)).apply ((((unsupported)).apply ((xmsgid)) ((xcnt)))) ((xkey)))
                                  (((unsupported)).apply ((((unsupported)).apply (((((xpdict).xsetdefault)).apply ((xmsgid)) ((((unsupported)).apply)))) ((xcnt)))) ((xvalue)))
                                (((unsupported)).apply ((((xTypeError)).apply ((xkey)))))
                            bogusForceDataize.write ((((xseen_keys).xadd)).apply ((xkey)))
                        (((unsupported)).apply ((((unsupported)).apply ((xk)) ((xv)))) (((((xpdict).xitems)).apply)))
                          (((unsupported)).apply ((((unsupported)).apply ((xcatalog)) ((xk)))) ((((unsupported)).apply (((((xv).xget)).apply ((xi)) (""))) ((xi)) ((((xrange)).apply ((xnum_plurals)))))))
                        (((unsupported)).apply ((xcatalog)))
                xget_context_data.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ("catalog") (((((xself).xget_catalog)).apply)) ("formats") ((((xget_formats)).apply)) ("plural") (((((xself).xget_plural)).apply)))))
                xrender_to_response.write
                  [xself xcontext]
                    memory > xtemplate
                    memory > xindent
                    seq > @
                      (((unsupported)).apply)
                        xindent.write
                          [xs]
                            seq > @
                              (((unsupported)).apply (((((xs).xreplace)).apply ("n") ("n  "))))
                        xtemplate.write ((((((xEngine)).apply).xfrom_string)).apply ((xjs_catalog_template)))
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext)) ("catalog_str"))) (((((unsupported)).apply ((xcontext)) ("catalog")).if (((xindent)).apply ((((unsupported)).apply (((xjson).xdumps)) ((((unsupported)).apply ((xcontext)) ("catalog"))) (TRUE) (2)))) "None: is there a None literal in the EO language?")))
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext)) ("formats_str"))) ((((xindent)).apply ((((unsupported)).apply (((xjson).xdumps)) ((((unsupported)).apply ((xcontext)) ("formats"))) (TRUE) (2))))))
                        (((unsupported)).apply ((((xHttpResponse)).apply (((((xtemplate).xrender)).apply ((((xContext)).apply ((xcontext)))))) ("text/javascript; charset=\"utf-8\""))))
            (((unsupported)).apply ((xJavaScriptCatalog)))
              seq
                (((unsupported)).apply)
                xrender_to_response.write
                  [xself xcontext]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xJsonResponse)).apply ((xcontext)))))