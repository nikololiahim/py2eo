memory > xVeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
memory > xA2
memory > xValueError
memory > xGrandParent
memory > xWarning
memory > xError
memory > xQuestion
memory > xParent
memory > xC2
memory > xC
memory > xdb
memory > xmodel_cls
memory > xm2mcomplex
memory > xcolumn_limit_db_alias
memory > xDummyClass
memory > xGrandChild
memory > xPerson
memory > xDummyModel
memory > xTestCase
memory > x_check_lazy_references
memory > xBar
memory > xprefix
memory > xAnswer
memory > xModel_
memory > xconnection
memory > xmax_column_name_length
memory > xRound
memory > xModelWithLongField
memory > xLower
memory > xm2msimple
memory > xFoo
memory > xBaz
memory > x_Model
memory > xpost_init
memory > xconnections
memory > xclashing_model
memory > xParkingLot
memory > xParent1
memory > xproperty
memory > xMother
memory > xTest__Model
memory > xParent2
memory > xAbs
memory > xThrough
memory > xFather
memory > xC1
memory > xShippingMethod
memory > xregister_lookup
memory > xGroup
memory > xRelationModel
memory > xModel
memory > xCountry
memory > xChild
memory > xTarget
memory > xmodels
memory > xA
memory > xA1
memory > xfield_name
memory > xlen
memory > xisolate_apps
memory > xSimpleTestCase
memory > xPlace
memory > xThroughProxy
[] > test_models
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xtest_multiple_autofields
        memory > xtest_check_constraint_pointing_to_reverse_fk
        memory > xtest_check_constraint_pointing_to_reverse_o2o
        memory > xtest_id_clash
        memory > xtest_check_constraint_pointing_to_missing_field
        memory > xtest_ending_with_underscore
        memory > xtest_m2m_field_table_name_clash
        memory > xtest_unique_constraint_with_include_required_db_features
        memory > xtest_ordering_pointing_to_related_model_pk
        memory > xtest_index_with_include_required_db_features
        memory > xdatabases
        memory > xtest_name_beginning_with_underscore
        memory > xtest_pointing_to_missing_field
        memory > xtest_ordering_with_order_with_respect_to
        memory > xtest_deferrable_unique_constraint
        memory > xtest_func_unique_constraint_required_db_features
        memory > xtest_M2M_long_column_name
        memory > xtest_multigeneration_inheritance
        memory > xtest_unique_constraint_include_pointing_to_m2m_field
        memory > xtest_func_index_pointing_to_m2m_field
        memory > xtest_inheritance_clash
        memory > xtest_ordering_pointing_to_non_related_field
        memory > xtest_lazy_reference_checks
        memory > xtest_func_unique_constraint_expression_custom_lookup
        memory > xtest_index_include_pointing_to_m2m_field
        memory > xtest_check_constraints_required_db_features
        memory > xtest_func_unique_constraint_pointing_to_fk
        memory > xtest_func_index_pointing_to_non_local_field
        memory > xtest_property_and_related_field_accessor_clash
        memory > xtest_pointing_to_m2m
        memory > xtest_field_name_clash_with_child_accessor
        memory > xtest_ordering_pointing_to_missing_related_field
        memory > xtest_func_index_complex_expression_custom_lookup
        memory > xtest_func_unique_constraint_pointing_to_missing_field
        memory > xtest_onetoone_with_explicit_parent_link_parent_model
        memory > xtest_ordering_non_iterable
        memory > xtest_check_constraint_pointing_to_non_local_field
        memory > xtest_two_m2m_through_same_model_with_different_through_fields
        memory > xtest_unique_constraint_pointing_to_fk
        memory > xtest_ordering_pointing_multiple_times_to_model_fields
        memory > xtest_check_jsonfield_required_db_features
        memory > xtest_unique_constraint_pointing_to_non_local_field
        memory > xtest_func_index_required_db_features
        memory > xget_max_column_name_length
        memory > xtest_db_column_clash
        memory > xtest_unique_constraint_pointing_to_missing_field
        memory > xtest_non_list
        memory > xtest_ordering_allows_registered_lookups
        memory > xtest_pointing_to_m2m_field
        memory > xtest_check_constraint_pointing_to_fk
        memory > xtest_pointing_to_non_local_field
        memory > xtest_check_constraint_pointing_to_m2m_field
        memory > xtest_single_primary_key
        memory > xtest_just_ordering_no_errors
        memory > xtest_unique_constraint_pointing_to_m2m_field
        memory > xtest_m2m_autogenerated_table_name_clash_database_routers_installed
        memory > xtest_ordering_pointing_to_json_field_value
        memory > xtest_name_ending_with_underscore
        memory > xtest_pointing_to_fk
        memory > xtest_ordering_pointing_to_missing_related_model_field
        memory > xtest_m2m_autogenerated_table_name_clash
        memory > xtest_unique_constraint_include_pointing_to_missing_field
        memory > xtest_unique_constraint_include_pointing_to_fk
        memory > xtest_func_unique_constraint
        memory > xtest_unique_constraint_with_condition
        memory > xtest_swappable_missing_app
        memory > xtest_index_with_condition_required_db_features
        memory > xtest_m2m_to_concrete_and_proxy_allowed
        memory > xtest_ordering_pointing_to_two_related_model_field
        memory > xtest_m2m_unmanaged_shadow_models_not_checked
        memory > xtest_ordering_pointing_to_lookup_not_transform
        memory > xtest_list_containing_non_iterable
        memory > xtest_max_name_length
        memory > xtest_ordering_pointing_to_missing_foreignkey_field
        memory > xtest_ordering_pointing_to_foreignkey_field
        memory > xtest_func_index_pointing_to_missing_field
        memory > xtest_two_m2m_through_same_relationship
        memory > xtest_unique_constraint_with_include
        memory > xtest_check_constraints
        memory > xtest_including_separator
        memory > xtest_func_index
        memory > xtest_m2m_field_table_name_clash_database_routers_installed
        memory > xtest_unique_primary_key
        memory > xtest_m2m_table_name_clash_database_routers_installed
        memory > xtest_index_include_pointing_to_non_local_field
        memory > xtest_swappable_missing_app_name
        memory > xtest_field_name_clash_with_m2m_through
        memory > xtest_local_field_long_column_name
        memory > xtest_check_jsonfield
        memory > xtest_func_unique_constraint_pointing_to_missing_field_nested
        memory > xtest_name_contains_double_underscores
        memory > xtest_name_constraints
        memory > xtest_deferrable_unique_constraint_required_db_features
        memory > xtest_non_iterable
        memory > xtest_m2m_table_name_clash
        memory > xtest_ordering_pointing_to_missing_field
        memory > xtest_unique_constraint_condition_pointing_to_joined_fields
        memory > xtest_unique_constraint_include_pointing_to_non_local_field
        memory > xtest_func_unique_constraint_pointing_to_m2m_field
        memory > xtest_index_with_condition
        memory > xtest_onetoone_with_parent_model
        memory > xtest_check_constraint_pointing_to_pk
        memory > xtest_non_valid
        memory > xtest_unique_constraint_condition_pointing_to_missing_field
        memory > xtest_index_include_pointing_to_missing_field
        memory > xtest_valid_model
        memory > xtest_unique_constraint_with_condition_required_db_features
        memory > xtest_index_with_include
        memory > xtest_multiinheritance_clash
        memory > xtest_check_constraint_pointing_to_joined_fields_complex_check
        memory > xtest_unique_constraint_pointing_to_reverse_o2o
        memory > xtest_just_order_with_respect_to_no_errors
        memory > xtest_func_index_pointing_to_fk
        memory > xtest_pk
        memory > xtest_func_index_pointing_to_missing_field_nested
        memory > xtest_index_include_pointing_to_fk
        memory > xtest_func_unique_constraint_pointing_to_non_local_field
        memory > xtest_check_constraint_pointing_to_joined_fields
        seq > @
          seq
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            xget_max_column_name_length.write
              []
                memory > xdb_alias
                memory > xmax_name_length
                memory > xallowed_len
                memory > xconnection
                seq > @
                  seq
                    xallowed_len.write "None: is there a None literal in the EO language?"
                    xdb_alias.write "None: is there a None literal in the EO language?"
                    (((unsupported)).apply ((xdb)) ((((unsupported)).apply ("default") ("other"))))
                      seq
                        xconnection.write (((unsupported)).apply ((xconnections)) ((xdb)))
                        xmax_name_length.write (((((xconnection).xops).xmax_name_length)).apply)
                        ((((unsupported)).apply ((xmax_name_length)) ("None: is there a None literal in the EO language?")).and ((((xconnection).xfeatures).xtruncates_names).not)).if
                          ((((unsupported)).apply ((xallowed_len)) ("None: is there a None literal in the EO language?")).or ((xmax_name_length).less (xallowed_len))).if
                            seq
                              xallowed_len.write (xmax_name_length)
                              xdb_alias.write (xdb)
                    (((unsupported)).apply ((((unsupported)).apply ((xallowed_len)) ((xdb_alias)))))
            (((unsupported)).apply ((xSimpleTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xtest_non_iterable.write
                  [xself]
                    memory > xindex_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindex_together.write 42
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'index_together' must be a list or tuple.") ((xModel)) ("models.E008"))))))
                xtest_non_list.write
                  [xself]
                    memory > xindex_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindex_together.write "not-a-list"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'index_together' must be a list or tuple.") ((xModel)) ("models.E008"))))))
                xtest_list_containing_non_iterable.write
                  [xself]
                    memory > xindex_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindex_together.write (((unsupported)).apply ((((unsupported)).apply ("a") ("b"))) (42))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("All 'index_together' elements must be lists or tuples.") ((xModel)) ("models.E009"))))))
                xtest_pointing_to_missing_field.write
                  [xself]
                    memory > xindex_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindex_together.write (((unsupported)).apply ((((unsupported)).apply ("missing_field"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'index_together' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xindex_together
                    memory > xfield2
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xFoo)))
                          seq
                            xfield2.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xindex_together.write (((unsupported)).apply ((((unsupported)).apply ("field2") ("field1"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'index_together' refers to field 'field1' which is not local to model 'Bar'.") ("This issue may be caused by multi-table inheritance.") ((xBar)) ("models.E016"))))))
                xtest_pointing_to_m2m_field.write
                  [xself]
                    memory > xindex_together
                    memory > xm2m
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xindex_together.write (((unsupported)).apply ((((unsupported)).apply ("m2m"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'index_together' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'index_together'.") ((xModel)) ("models.E013"))))))
                xtest_pointing_to_fk.write
                  [xself]
                    memory > xindex_together
                    memory > xfoo_2
                    memory > xfoo_1
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoo_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_1"))
                            xfoo_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_2"))
                            (((unsupported)).apply)
                              xindex_together.write (((unsupported)).apply ((((unsupported)).apply ("foo_1_id") ("foo_2"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply)))
            (((unsupported)).apply ((xSimpleTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xtest_non_iterable.write
                  [xself]
                    memory > xunique_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xunique_together.write 42
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'unique_together' must be a list or tuple.") ((xModel)) ("models.E010"))))))
                xtest_list_containing_non_iterable.write
                  [xself]
                    memory > xtwo
                    memory > xone
                    memory > xunique_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xone.write ((((xmodels).xIntegerField)).apply)
                            xtwo.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xunique_together.write (((unsupported)).apply ((((unsupported)).apply ("a") ("b"))) (42))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("All 'unique_together' elements must be lists or tuples.") ((xModel)) ("models.E011"))))))
                xtest_non_list.write
                  [xself]
                    memory > xunique_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xunique_together.write "not-a-list"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'unique_together' must be a list or tuple.") ((xModel)) ("models.E010"))))))
                xtest_valid_model.write
                  [xself]
                    memory > xtwo
                    memory > xone
                    memory > xunique_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xone.write ((((xmodels).xIntegerField)).apply)
                            xtwo.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xunique_together.write (((unsupported)).apply ("one") ("two"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_pointing_to_missing_field.write
                  [xself]
                    memory > xunique_together
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xunique_together.write (((unsupported)).apply ((((unsupported)).apply ("missing_field"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'unique_together' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_pointing_to_m2m.write
                  [xself]
                    memory > xunique_together
                    memory > xm2m
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xunique_together.write (((unsupported)).apply ((((unsupported)).apply ("m2m"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'unique_together' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'unique_together'.") ((xModel)) ("models.E013"))))))
                xtest_pointing_to_fk.write
                  [xself]
                    memory > xunique_together
                    memory > xfoo_2
                    memory > xfoo_1
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoo_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_1"))
                            xfoo_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_2"))
                            (((unsupported)).apply)
                              xunique_together.write (((unsupported)).apply ((((unsupported)).apply ("foo_1_id") ("foo_2"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply)))
            (((unsupported)).apply ((xTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xtest_pointing_to_missing_field.write
                  [xself]
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("missing_field"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_pointing_to_m2m_field.write
                  [xself]
                    memory > xm2m
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("m2m"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'indexes'.") ((xModel)) ("models.E013"))))))
                xtest_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xfield2
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xFoo)))
                          seq
                            xfield2.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("field2") ("field1"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to field 'field1' which is not local to model 'Bar'.") ("This issue may be caused by multi-table inheritance.") ((xBar)) ("models.E016"))))))
                xtest_pointing_to_fk.write
                  [xself]
                    memory > xindexes
                    memory > xfoo_2
                    memory > xfoo_1
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoo_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_1"))
                            xfoo_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_2"))
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("foo_1_id") ("foo_2"))) ("index_name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_name_constraints.write
                  [xself]
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("id"))) ("_index_name"))) ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("id"))) ("5index_name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) (("The index name '%sindex_name' cannot start with an underscore or a number.".mod (xprefix))) ((xModel)) ("models.E033"))) ((xprefix)) ((((unsupported)).apply ("_") ("5"))))))
                xtest_max_name_length.write
                  [xself]
                    memory > xindex_name
                    memory > xindexes
                    seq > @
                      seq
                        xindex_name.write ("x".mul 31)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("id"))) ((xindex_name)))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) (("The index name '%s' cannot be longer than 30 characters.".mod (xindex_name))) ((xModel)) ("models.E034"))))))
                xtest_index_with_condition.write
                  [xself]
                    memory > xerrors
                    memory > xexpected
                    memory > xage
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("age"))) ("index_age_gte_10") ((((unsupported)).apply (((xmodels).xQ)) (10))))))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xexpected.write ((((xconnection).xfeatures).xsupports_partial_indexes).if (((unsupported)).apply) (((unsupported)).apply ((((unsupported)).apply ((xWarning)) (("%s does not support indexes with conditions.".mod ((xconnection).xdisplay_name))) ("Conditions will be ignored. Silence this warning if you don't care about it.") ((xModel)) ("models.W037")))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerrors)) ((xexpected)))
                xtest_index_with_condition_required_db_features.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_partial_indexes"))
                                xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("age"))) ("index_age_gte_10") ((((unsupported)).apply (((xmodels).xQ)) (10))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_index_with_include.write
                  [xself]
                    memory > xerrors
                    memory > xexpected
                    memory > xage
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("age"))) ("index_age_include_id") ((((unsupported)).apply ("id"))))))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xexpected.write ((((xconnection).xfeatures).xsupports_covering_indexes).if (((unsupported)).apply) (((unsupported)).apply ((((unsupported)).apply ((xWarning)) (("%s does not support indexes with non-key columns.".mod ((xconnection).xdisplay_name))) ("Non-key columns will be ignored. Silence this warning if you don't care about it.") ((xModel)) ("models.W040")))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerrors)) ((xexpected)))
                xtest_index_with_include_required_db_features.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_covering_indexes"))
                                xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("age"))) ("index_age_include_id") ((((unsupported)).apply ("id"))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_index_include_pointing_to_missing_field.write
                  [xself]
                    memory > xindexes
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("id"))) ((((unsupported)).apply ("missing_field"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_index_include_pointing_to_m2m_field.write
                  [xself]
                    memory > xm2m
                    memory > xindexes
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("id"))) ((((unsupported)).apply ("m2m"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'indexes'.") ((xModel)) ("models.E013"))))))
                xtest_index_include_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xfield2
                    memory > xindexes
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xParent)))
                          seq
                            xfield2.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("field2"))) ((((unsupported)).apply ("field1"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xChild).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to field 'field1' which is not local to model 'Child'.") ("This issue may be caused by multi-table inheritance.") ((xChild)) ("models.E016"))))))
                xtest_index_include_pointing_to_fk.write
                  [xself]
                    memory > xfk_1
                    memory > xfk_2
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfk_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_1"))
                            xfk_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_2"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((unsupported)).apply ("id"))) ((((unsupported)).apply ("fk_1_id") ("fk_2"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_func_index.write
                  [xself]
                    memory > xname
                    memory > xindexes
                    memory > xexpected
                    memory > xwarn
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xname.write (((unsupported)).apply (((xmodels).xCharField)) (10))
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((xLower)).apply ("name"))) ("index_lower_name"))))
                        xwarn.write (((unsupported)).apply ((xWarning)) (("%s does not support indexes on expressions.".mod ((xconnection).xdisplay_name))) ("An index won't be created. Silence this warning if you don't care about it.") ((xModel)) ("models.W043"))
                        xexpected.write ((((xconnection).xfeatures).xsupports_expression_indexes).if (((unsupported)).apply) (((unsupported)).apply ((xwarn))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((xexpected)))
                xtest_func_index_required_db_features.write
                  [xself]
                    memory > xindexes
                    memory > xrequired_db_features
                    memory > xname
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xname.write (((unsupported)).apply (((xmodels).xCharField)) (10))
                            (((unsupported)).apply)
                              seq
                                xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((xLower)).apply ("name"))) ("index_lower_name"))))
                                xrequired_db_features.write (((unsupported)).apply ("supports_expression_indexes"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_func_index_complex_expression_custom_lookup.write
                  [xself]
                    memory > xweight
                    memory > xheight
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xheight.write ((((xmodels).xIntegerField)).apply)
                            xweight.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((((xmodels).xF)).apply ("height")).div (((((xmodels).xF)).apply ("weight__abs")).sub ((((xmodels).xValue)).apply (5))))) ("name"))))
                        (((unsupported)).apply ((((xregister_lookup)).apply (((xmodels).xIntegerField)) ((xAbs)))))
                          bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_func_index_pointing_to_missing_field.write
                  [xself]
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) (((((((xLower)).apply ("missing_field")).xdesc)).apply)) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_func_index_pointing_to_missing_field_nested.write
                  [xself]
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((xAbs)).apply ((((xRound)).apply ("missing_field"))))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_func_index_pointing_to_m2m_field.write
                  [xself]
                    memory > xm2m
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((xLower)).apply ("m2m"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'indexes'.") ((xModel)) ("models.E013"))))))
                xtest_func_index_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xindexes
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write (((unsupported)).apply (((xmodels).xCharField)) (15))
                        (((unsupported)).apply ((xFoo)))
                          (((unsupported)).apply)
                            xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((xLower)).apply ("field1"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'indexes' refers to field 'field1' which is not local to model 'Bar'.") ("This issue may be caused by multi-table inheritance.") ((xBar)) ("models.E016"))))))
                xtest_func_index_pointing_to_fk.write
                  [xself]
                    memory > xindexes
                    memory > xfoo_2
                    memory > xfoo_1
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoo_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_1"))
                            xfoo_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_2"))
                            (((unsupported)).apply)
                              xindexes.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xIndex)) ((((xLower)).apply ("foo_1_id"))) ((((xLower)).apply ("foo_2"))) ("index_name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply)))
            (((unsupported)).apply ((xTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xdatabases.write (((unsupported)).apply ("default") ("other"))
                xtest_ending_with_underscore.write
                  [xself]
                    memory > xfield_
                    memory > xm2m_
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfield_.write (((unsupported)).apply (((xmodels).xCharField)) (10))
                            xm2m_.write ((((xmodels).xManyToManyField)).apply ("self"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("Field names must not end with an underscore.") ((((((xModel).x_meta).xget_field)).apply ("field_"))) ("fields.E001"))) ((((unsupported)).apply ((xError)) ("Field names must not end with an underscore.") ((((((xModel).x_meta).xget_field)).apply ("m2m_"))) ("fields.E001"))))))
                (((unsupported)).apply ((((unsupported)).apply ((xmax_column_name_length)) ((xcolumn_limit_db_alias)))) ((((xget_max_column_name_length)).apply)))
                xtest_M2M_long_column_name.write
                  [xself]
                    memory > xexpected
                    memory > xfk
                    memory > xerrors
                    memory > xm2m_field2
                    memory > xid2
                    memory > xm2m_field3
                    memory > xm2m_field
                    memory > xlong_field_name
                    memory > xtitle
                    memory > xm2m_long_name
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xtitle.write (((unsupported)).apply (((xmodels).xCharField)) (11))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m_field.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xVeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz)) ("rn1"))
                            xm2m_field2.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xVeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz)) ("rn2") ("m2msimple"))
                            xm2m_field3.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xVeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz)) ("rn3") ("m2mcomplex"))
                            xfk.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xVeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz)) (((xmodels).xCASCADE)) ("rn4"))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xid2.write ((((xmodels).xForeignKey)).apply ((xModelWithLongField)) (((xmodels).xCASCADE)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xid2.write ((((xmodels).xForeignKey)).apply ((xModelWithLongField)) (((xmodels).xCASCADE)))
                        xlong_field_name.write ("a".mul (((xself).xmax_column_name_length).sub 1))
                        bogusForceDataize.write (((((((xmodels).xForeignKey)).apply ((xVeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz)) (((xmodels).xCASCADE))).xcontribute_to_class)).apply ((xm2msimple)) ((xlong_field_name)))
                        bogusForceDataize.write ((((((unsupported)).apply (((xmodels).xForeignKey)) ((xVeryLongModelNamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz)) (((xmodels).xCASCADE)) ((xlong_field_name))).xcontribute_to_class)).apply ((xm2mcomplex)) ((xlong_field_name)))
                        xerrors.write (((unsupported)).apply (((xModelWithLongField).xcheck)) ((((unsupported)).apply ("default") ("other"))))
                        xm2m_long_name.write "verylongmodelnamezzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz_id"
                        (((xself).xmax_column_name_length).greater (((xlen)).apply ((xm2m_long_name)))).if
                          xexpected.write (((unsupported)).apply)
                          xexpected.write (((unsupported)).apply ((((unsupported)).apply ((xError)) (("Autogenerated column name too long for M2M field \"%s\". Maximum length is \"%s\" for database \"%s\".".mod (((unsupported)).apply ((xm2m_long_name)) (((xself).xmax_column_name_length)) (((xself).xcolumn_limit_db_alias))))) ("Use 'through' to create a separate model for M2M and then set column_name using 'db_column'.") ((xModelWithLongField)) ("models.E019"))))
                        bogusForceDataize.write ((((xexpected).xappend)).apply ((((unsupported)).apply ((xError)) (("Autogenerated column name too long for M2M field \"%s_id\". Maximum length is \"%s\" for database \"%s\".".mod (((unsupported)).apply ((xlong_field_name)) (((xself).xmax_column_name_length)) (((xself).xcolumn_limit_db_alias))))) ("Use 'through' to create a separate model for M2M and then set column_name using 'db_column'.") ((xModelWithLongField)) ("models.E019"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerrors)) ((xexpected)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModelWithLongField).xcheck)) ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply)))
                xtest_local_field_long_column_name.write
                  [xself]
                    memory > xlong_field_name2
                    memory > xtitle
                    memory > xlong_field_name
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xtitle.write (((unsupported)).apply (((xmodels).xCharField)) (11))
                        xlong_field_name.write ("a".mul (((xself).xmax_column_name_length).sub 1))
                        xlong_field_name2.write ("b".mul (((xself).xmax_column_name_length).sub 1))
                        bogusForceDataize.write ((((((unsupported)).apply (((xmodels).xCharField)) (11)).xcontribute_to_class)).apply ((xModelWithLongField)) ((xlong_field_name)))
                        bogusForceDataize.write ((((((unsupported)).apply (((xmodels).xCharField)) (11) ("vlmn")).xcontribute_to_class)).apply ((xModelWithLongField)) ((xlong_field_name2)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModelWithLongField).xcheck)) ((((unsupported)).apply ("default") ("other"))))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) (("Autogenerated column name too long for field \"%s\". Maximum length is \"%s\" for database \"%s\".".mod (((unsupported)).apply ((xlong_field_name)) (((xself).xmax_column_name_length)) (((xself).xcolumn_limit_db_alias))))) ("Set the column name manually using 'db_column'.") ((xModelWithLongField)) ("models.E018"))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModelWithLongField).xcheck)) ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply)))
                xtest_including_separator.write
                  [xself]
                    memory > xsome__field
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xsome__field.write ((((xmodels).xIntegerField)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("Field names must not contain \"__\".") ((((((xModel).x_meta).xget_field)).apply ("some__field"))) ("fields.E002"))))))
                xtest_pk.write
                  [xself]
                    memory > xpk
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xpk.write ((((xmodels).xIntegerField)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'pk' is a reserved word that cannot be used as a field name.") ((((((xModel).x_meta).xget_field)).apply ("pk"))) ("fields.E003"))))))
                xtest_db_column_clash.write
                  [xself]
                    memory > xfoo
                    memory > xbar
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoo.write ((((xmodels).xIntegerField)).apply)
                            xbar.write (((unsupported)).apply (((xmodels).xIntegerField)) ("foo"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("Field 'bar' has column name 'foo' that is used by another field.") ("Specify a 'db_column' for the field.") ((xModel)) ("models.E007"))))))
            (((unsupported)).apply ((xSimpleTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xtest_field_name_clash_with_child_accessor.write
                  [xself]
                    memory > xchild
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply ((xParent)))
                          xchild.write (((unsupported)).apply (((xmodels).xCharField)) (100))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field 'child' clashes with the field 'child' from model 'invalid_models_tests.parent'.") ((((((xChild).x_meta).xget_field)).apply ("child"))) ("models.E006"))))))
                xtest_field_name_clash_with_m2m_through.write
                  [xself]
                    memory > xparents
                    memory > xparent
                    memory > xclash
                    memory > xclash_id
                    memory > xmodel
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xclash_id.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xParent)))
                          xclash.write ((((xmodels).xForeignKey)).apply ("Child") (((xmodels).xCASCADE)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xparents.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xParent)) ("Through") ((((unsupported)).apply ("parent") ("model"))))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xForeignKey)).apply ((xParent)) (((xmodels).xCASCADE)))
                            xmodel.write ((((xmodels).xForeignKey)).apply ((xModel)) (((xmodels).xCASCADE)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field 'clash' clashes with the field 'clash_id' from model 'invalid_models_tests.parent'.") ((((((xChild).x_meta).xget_field)).apply ("clash"))) ("models.E006"))))))
                xtest_multiinheritance_clash.write
                  [xself]
                    memory > xclash
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xclash.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xclash.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xMother)) ((xFather)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field 'id' from parent model 'invalid_models_tests.mother' clashes with the field 'id' from parent model 'invalid_models_tests.father'.") ((xChild)) ("models.E005"))) ((((unsupported)).apply ((xError)) ("The field 'clash' from parent model 'invalid_models_tests.mother' clashes with the field 'clash' from parent model 'invalid_models_tests.father'.") ((xChild)) ("models.E005"))))))
                xtest_inheritance_clash.write
                  [xself]
                    memory > xf_id
                    memory > xf
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xf_id.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xf_id.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xParent)))
                          xf.write ((((xmodels).xForeignKey)).apply ((xTarget)) (((xmodels).xCASCADE)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field 'f' clashes with the field 'f_id' from model 'invalid_models_tests.parent'.") ((((((xChild).x_meta).xget_field)).apply ("f"))) ("models.E006"))))))
                xtest_multigeneration_inheritance.write
                  [xself]
                    memory > xclash
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xclash.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xGrandParent)))
                        (((unsupported)).apply ((xParent)))
                        (((unsupported)).apply ((xChild)))
                          xclash.write ((((xmodels).xIntegerField)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xGrandChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field 'clash' clashes with the field 'clash' from model 'invalid_models_tests.grandparent'.") ((((((xGrandChild).x_meta).xget_field)).apply ("clash"))) ("models.E006"))))))
                xtest_id_clash.write
                  [xself]
                    memory > xfk_id
                    memory > xfk
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfk.write ((((xmodels).xForeignKey)).apply ((xTarget)) (((xmodels).xCASCADE)))
                            xfk_id.write ((((xmodels).xIntegerField)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field 'fk_id' clashes with the field 'fk' from model 'invalid_models_tests.model'.") ((((((xModel).x_meta).xget_field)).apply ("fk_id"))) ("models.E006"))))))
            (((unsupported)).apply ((xSimpleTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xtest_unique_primary_key.write
                  [xself]
                    memory > xinvalid_id
                    memory > xid
                    seq > @
                      seq
                        xinvalid_id.write (((unsupported)).apply (((xmodels).xIntegerField)) (FALSE))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xid.write (xinvalid_id)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'id' can only be used as a field name if the field also sets 'primary_key=True'.") ((xModel)) ("models.E004"))))))
                xtest_ordering_non_iterable.write
                  [xself]
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xordering.write "missing_field"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' must be a tuple or list (even if you want to order by only one field).") ((xModel)) ("models.E014"))))))
                xtest_just_ordering_no_errors.write
                  [xself]
                    memory > xorder
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xorder.write ((((xmodels).xPositiveIntegerField)).apply)
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("order"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_just_order_with_respect_to_no_errors.write
                  [xself]
                    memory > xorder_with_respect_to
                    memory > xquestion
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xquestion.write ((((xmodels).xForeignKey)).apply ((xQuestion)) (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xorder_with_respect_to.write "question"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xAnswer).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_ordering_with_order_with_respect_to.write
                  [xself]
                    memory > xorder
                    memory > xorder_with_respect_to
                    memory > xquestion
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xquestion.write ((((xmodels).xForeignKey)).apply ((xQuestion)) (((xmodels).xCASCADE)))
                            xorder.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xorder_with_respect_to.write "question"
                                xordering.write (((unsupported)).apply ("order"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xAnswer).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' and 'order_with_respect_to' cannot be used together.") ((xAnswer)) ("models.E021"))))))
                xtest_non_valid.write
                  [xself]
                    memory > xrelation
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xrelation.write ((((xmodels).xManyToManyField)).apply ((xRelationModel)))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("relation"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'relation'.") ((xModel)) ("models.E015"))))))
                xtest_ordering_pointing_to_missing_field.write
                  [xself]
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xordering.write (((unsupported)).apply ("missing_field"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'missing_field'.") ((xModel)) ("models.E015"))))))
                xtest_ordering_pointing_to_missing_foreignkey_field.write
                  [xself]
                    memory > xmissing_fk_field
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xmissing_fk_field.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("missing_fk_field_id"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'missing_fk_field_id'.") ((xModel)) ("models.E015"))))))
                xtest_ordering_pointing_to_missing_related_field.write
                  [xself]
                    memory > xtest
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xtest.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("missing_related__id"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'missing_related__id'.") ((xModel)) ("models.E015"))))))
                xtest_ordering_pointing_to_missing_related_model_field.write
                  [xself]
                    memory > xparent
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xForeignKey)).apply ((xParent)) (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("parent__missing_field"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'parent__missing_field'.") ((xChild)) ("models.E015"))))))
                xtest_ordering_pointing_to_non_related_field.write
                  [xself]
                    memory > xparent
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("parent__missing_field"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'parent__missing_field'.") ((xChild)) ("models.E015"))))))
                xtest_ordering_pointing_to_two_related_model_field.write
                  [xself]
                    memory > xparent1
                    memory > xparent2
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xparent2.write ((((xmodels).xForeignKey)).apply ((xParent2)) (((xmodels).xCASCADE)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent1.write ((((xmodels).xForeignKey)).apply ((xParent1)) (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("parent1__parent2__missing_field"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'parent1__parent2__missing_field'.") ((xChild)) ("models.E015"))))))
                xtest_ordering_pointing_multiple_times_to_model_fields.write
                  [xself]
                    memory > xparent
                    memory > xfield1
                    memory > xfield2
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfield1.write (((unsupported)).apply (((xmodels).xCharField)) (100))
                            xfield2.write (((unsupported)).apply (((xmodels).xCharField)) (100))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xForeignKey)).apply ((xParent)) (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("parent__field1__field2"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'ordering' refers to the nonexistent field, related field, or lookup 'parent__field1__field2'.") ((xChild)) ("models.E015"))))))
                xtest_ordering_allows_registered_lookups.write
                  [xself]
                    memory > xtest
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xtest.write (((unsupported)).apply (((xmodels).xCharField)) (100))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("test__lower"))
                        (((unsupported)).apply ((((xregister_lookup)).apply (((xmodels).xCharField)) ((xLower)))))
                          bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_ordering_pointing_to_lookup_not_transform.write
                  [xself]
                    memory > xtest
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xtest.write (((unsupported)).apply (((xmodels).xCharField)) (100))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("test__isnull"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_ordering_pointing_to_related_model_pk.write
                  [xself]
                    memory > xparent
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xForeignKey)).apply ((xParent)) (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("parent__pk"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xChild).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_ordering_pointing_to_foreignkey_field.write
                  [xself]
                    memory > xparent
                    memory > xordering
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xForeignKey)).apply ((xParent)) (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("parent_id"))
                        bogusForceDataize.write ((((xself).xassertFalse)).apply (((((xChild).xcheck)).apply)))
                xtest_name_beginning_with_underscore.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((x_Model).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The model name '_Model' cannot start or end with an underscore as it collides with the query lookup syntax.") ((x_Model)) ("models.E023"))))))
                xtest_name_ending_with_underscore.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel_).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The model name 'Model_' cannot start or end with an underscore as it collides with the query lookup syntax.") ((xModel_)) ("models.E023"))))))
                xtest_name_contains_double_underscores.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xTest__Model).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The model name 'Test__Model' cannot contain double underscores as it collides with the query lookup syntax.") ((xTest__Model)) ("models.E024"))))))
                xtest_property_and_related_field_accessor_clash.write
                  [xself]
                    memory > xfk
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfk.write ((((xmodels).xForeignKey)).apply ("self") (((xmodels).xCASCADE)))
                        (((unsupported)).apply (((xModel).xfk_id)) ((((xproperty)).apply ((((unsupported)).apply ("ERROR"))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The property 'fk_id' clashes with a related field accessor.") ((xModel)) ("models.E025"))))))
                xtest_single_primary_key.write
                  [xself]
                    memory > xfoo
                    memory > xbar
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoo.write (((unsupported)).apply (((xmodels).xIntegerField)) (TRUE))
                            xbar.write (((unsupported)).apply (((xmodels).xIntegerField)) (TRUE))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The model cannot have more than one field with 'primary_key=True'.") ((xModel)) ("models.E026"))))))
                xtest_swappable_missing_app_name.write
                  [xself]
                    memory > xswappable
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xswappable.write "TEST_SWAPPED_MODEL_BAD_VALUE"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'TEST_SWAPPED_MODEL_BAD_VALUE' is not of the form 'app_label.app_name'.") ("models.E001"))))))
                xtest_swappable_missing_app.write
                  [xself]
                    memory > xswappable
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xswappable.write "TEST_SWAPPED_MODEL_BAD_MODEL"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xModel).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'TEST_SWAPPED_MODEL_BAD_MODEL' references 'not_an_app.Target', which has not been installed, or is abstract.") ("models.E002"))))))
                xtest_two_m2m_through_same_relationship.write
                  [xself]
                    memory > xprimary
                    memory > xgroup
                    memory > xperson
                    memory > xsecondary
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xprimary.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xPerson)) ("Membership") ("primary"))
                            xsecondary.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xPerson)) ("Membership") ("secondary"))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xperson.write ((((xmodels).xForeignKey)).apply ((xPerson)) (((xmodels).xCASCADE)))
                            xgroup.write ((((xmodels).xForeignKey)).apply ((xGroup)) (((xmodels).xCASCADE)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xGroup).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The model has two identical many-to-many relations through the intermediate model 'invalid_models_tests.Membership'.") ((xGroup)) ("models.E003"))))))
                xtest_two_m2m_through_same_model_with_different_through_fields.write
                  [xself]
                    memory > xfrom_countries
                    memory > xto_countries
                    memory > xto_country
                    memory > xfrom_country
                    memory > xmethod
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xto_countries.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xCountry)) ("ShippingMethodPrice") ((((unsupported)).apply ("method") ("to_country"))))
                            xfrom_countries.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xCountry)) ("ShippingMethodPrice") ((((unsupported)).apply ("method") ("from_country"))) ("-"))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xmethod.write ((((xmodels).xForeignKey)).apply ((xShippingMethod)) (((xmodels).xCASCADE)))
                            xto_country.write ((((xmodels).xForeignKey)).apply ((xCountry)) (((xmodels).xCASCADE)))
                            xfrom_country.write ((((xmodels).xForeignKey)).apply ((xCountry)) (((xmodels).xCASCADE)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xShippingMethod).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_onetoone_with_parent_model.write
                  [xself]
                    memory > xother_place
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply ((xPlace)))
                          xother_place.write (((unsupported)).apply (((xmodels).xOneToOneField)) ((xPlace)) (((xmodels).xCASCADE)) ("other_parking"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xParkingLot).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_onetoone_with_explicit_parent_link_parent_model.write
                  [xself]
                    memory > xplace
                    memory > xother_place
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply ((xPlace)))
                          seq
                            xplace.write (((unsupported)).apply (((xmodels).xOneToOneField)) ((xPlace)) (((xmodels).xCASCADE)) (TRUE) (TRUE))
                            xother_place.write (((unsupported)).apply (((xmodels).xOneToOneField)) ((xPlace)) (((xmodels).xCASCADE)) ("other_parking"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xParkingLot).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_m2m_table_name_clash.write
                  [xself]
                    memory > xdb_table
                    memory > xbar
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xbar.write (((unsupported)).apply (((xmodels).xManyToManyField)) ("Bar") ("myapp_bar"))
                            (((unsupported)).apply)
                              xdb_table.write "myapp_foo"
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xdb_table.write "myapp_bar"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xFoo).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field's intermediary table 'myapp_bar' clashes with the table name of 'invalid_models_tests.Bar'.") ((((((xFoo).x_meta).xget_field)).apply ("bar"))) ("fields.E340"))))))
                xtest_m2m_table_name_clash_database_routers_installed.write
                  [xself]
                    memory > xdb_table
                    memory > xbar
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xbar.write (((unsupported)).apply (((xmodels).xManyToManyField)) ("Bar") ("myapp_bar"))
                            (((unsupported)).apply)
                              xdb_table.write "myapp_foo"
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xdb_table.write "myapp_bar"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xFoo).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xWarning)) ("The field's intermediary table 'myapp_bar' clashes with the table name of 'invalid_models_tests.Bar'.") ((((((xFoo).x_meta).xget_field)).apply ("bar"))) ("You have configured settings.DATABASE_ROUTERS. Verify that the table of 'invalid_models_tests.Bar' is correctly routed to a separate database.") ("fields.W344"))))))
                xtest_m2m_field_table_name_clash.write
                  [xself]
                    memory > xfoos
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfoos.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xFoo)) ("clash"))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfoos.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xFoo)) ("clash"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((((xBar).xcheck)).apply).sub ((((xBaz).xcheck)).apply))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field's intermediary table 'clash' clashes with the table name of 'invalid_models_tests.Baz.foos'.") ((((((xBar).x_meta).xget_field)).apply ("foos"))) ("fields.E340"))) ((((unsupported)).apply ((xError)) ("The field's intermediary table 'clash' clashes with the table name of 'invalid_models_tests.Bar.foos'.") ((((((xBaz).x_meta).xget_field)).apply ("foos"))) ("fields.E340"))))))
                xtest_m2m_field_table_name_clash_database_routers_installed.write
                  [xself]
                    memory > xfoos
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfoos.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xFoo)) ("clash"))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfoos.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xFoo)) ("clash"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((((xBar).xcheck)).apply).sub ((((xBaz).xcheck)).apply))) ((((unsupported)).apply ((((unsupported)).apply ((xWarning)) (("The field's intermediary table 'clash' clashes with the table name of 'invalid_models_tests.%s.foos'.".mod (xclashing_model))) ((((((xmodel_cls).x_meta).xget_field)).apply ("foos"))) (("You have configured settings.DATABASE_ROUTERS. Verify that the table of 'invalid_models_tests.%s.foos' is correctly routed to a separate database.".mod (xclashing_model))) ("fields.W344"))) ((((unsupported)).apply ((xmodel_cls)) ((xclashing_model)))) ((((unsupported)).apply ((((unsupported)).apply ((xBar)) ("Baz"))) ((((unsupported)).apply ((xBaz)) ("Bar"))))))))
                xtest_m2m_autogenerated_table_name_clash.write
                  [xself]
                    memory > xfoos
                    memory > xdb_table
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xdb_table.write "bar_foos"
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoos.write ((((xmodels).xManyToManyField)).apply ((xFoo)))
                            (((unsupported)).apply)
                              xdb_table.write "bar"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("The field's intermediary table 'bar_foos' clashes with the table name of 'invalid_models_tests.Foo'.") ((((((xBar).x_meta).xget_field)).apply ("foos"))) ("fields.E340"))))))
                xtest_m2m_autogenerated_table_name_clash_database_routers_installed.write
                  [xself]
                    memory > xfoos
                    memory > xdb_table
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xdb_table.write "bar_foos"
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoos.write ((((xmodels).xManyToManyField)).apply ((xFoo)))
                            (((unsupported)).apply)
                              xdb_table.write "bar"
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xBar).xcheck)).apply)) ((((unsupported)).apply ((((unsupported)).apply ((xWarning)) ("The field's intermediary table 'bar_foos' clashes with the table name of 'invalid_models_tests.Foo'.") ((((((xBar).x_meta).xget_field)).apply ("foos"))) ("You have configured settings.DATABASE_ROUTERS. Verify that the table of 'invalid_models_tests.Foo' is correctly routed to a separate database.") ("fields.W344"))))))
                xtest_m2m_unmanaged_shadow_models_not_checked.write
                  [xself]
                    memory > xdb_table
                    memory > xc2
                    memory > xmm_a
                    memory > xa2
                    memory > xmanaged
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          xmm_a.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xA1)) ("d1"))
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xmanaged.write FALSE
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xmm_a.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xA2)) ("Intermediate"))
                            (((unsupported)).apply)
                              xmanaged.write FALSE
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xa2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xA2)) (((xmodels).xCASCADE)) ("a1_id"))
                            xc2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xC2)) (((xmodels).xCASCADE)) ("c1_id"))
                            (((unsupported)).apply)
                              seq
                                xdb_table.write "d1"
                                xmanaged.write FALSE
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xC1).xcheck)).apply)) ((((unsupported)).apply)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xC2).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_m2m_to_concrete_and_proxy_allowed.write
                  [xself]
                    memory > xc
                    memory > xproxy
                    memory > xmm_a
                    memory > xmm_aproxy
                    memory > xa
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xa.write ((((xmodels).xForeignKey)).apply ("A") (((xmodels).xCASCADE)))
                            xc.write ((((xmodels).xForeignKey)).apply ("C") (((xmodels).xCASCADE)))
                        (((unsupported)).apply ((xThrough)))
                          (((unsupported)).apply)
                            xproxy.write TRUE
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xmm_a.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xA)) ((xThrough)))
                            xmm_aproxy.write (((unsupported)).apply (((xmodels).xManyToManyField)) ((xA)) ((xThroughProxy)) ("proxied_m2m"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xC).xcheck)).apply)) ((((unsupported)).apply)))
                xtest_lazy_reference_checks.write
                  [xself xapps]
                    memory > x__call__
                    memory > xdummy_function
                    memory > xapp_label
                    memory > xdummy_method
                    memory > xauthor
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xauthor.write ((((xmodels).xForeignKey)).apply ("Author") (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xapp_label.write "invalid_models_tests"
                        (((unsupported)).apply)
                          seq
                            x__call__.write
                              [xself]
                                seq > @
                                  (((unsupported)).apply)
                            xdummy_method.write
                              [xself]
                                seq > @
                        xdummy_function.write
                          []
                            seq > @
                              (((unsupported)).apply)
                        bogusForceDataize.write ((((xapps).xlazy_model_operation)).apply ((xdummy_function)) ((((unsupported)).apply ("auth") ("imaginarymodel"))))
                        bogusForceDataize.write ((((xapps).xlazy_model_operation)).apply ((xdummy_function)) ((((unsupported)).apply ("fanciful_app") ("imaginarymodel"))))
                        (((unsupported)).apply (((xpost_init).xconnect)) ((xdummy_function)) ("missing-app.Model") ((xapps)))
                        (((unsupported)).apply (((xpost_init).xconnect)) ((((xDummyClass)).apply)) ("missing-app.Model") ((xapps)))
                        (((unsupported)).apply (((xpost_init).xconnect)) (((((xDummyClass)).apply).xdummy_method)) ("missing-app.Model") ((xapps)))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((x_check_lazy_references)).apply ((xapps)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) (("%r contains a lazy reference to auth.imaginarymodel, but app 'auth' doesn't provide model 'imaginarymodel'.".mod (xdummy_function))) ((xdummy_function)) ("models.E022"))) ((((unsupported)).apply ((xError)) (("%r contains a lazy reference to fanciful_app.imaginarymodel, but app 'fanciful_app' isn't installed.".mod (xdummy_function))) ((xdummy_function)) ("models.E022"))) ((((unsupported)).apply ((xError)) ("An instance of class 'DummyClass' was connected to the 'post_init' signal with a lazy reference to the sender 'missing-app.model', but app 'missing-app' isn't installed.") ("None: is there a None literal in the EO language?") ("invalid_models_tests.test_models") ("signals.E001"))) ((((unsupported)).apply ((xError)) ("Bound method 'DummyClass.dummy_method' was connected to the 'post_init' signal with a lazy reference to the sender 'missing-app.model', but app 'missing-app' isn't installed.") ("None: is there a None literal in the EO language?") ("invalid_models_tests.test_models") ("signals.E001"))) ((((unsupported)).apply ((xError)) ("The field invalid_models_tests.DummyModel.author was declared with a lazy reference to 'invalid_models_tests.author', but app 'invalid_models_tests' isn't installed.") ("None: is there a None literal in the EO language?") ((((xDummyModel).xauthor).xfield)) ("fields.E307"))) ((((unsupported)).apply ((xError)) ("The function 'dummy_function' was connected to the 'post_init' signal with a lazy reference to the sender 'missing-app.model', but app 'missing-app' isn't installed.") ("None: is there a None literal in the EO language?") ("invalid_models_tests.test_models") ("signals.E001"))))))
            (((unsupported)).apply ((xTestCase)))
              xtest_multiple_autofields.write
                [xself]
                  memory > xauto1
                  memory > xauto2
                  memory > xmsg
                  seq > @
                    seq
                      xmsg.write "Model invalid_models_tests.MultipleAutoFields can't have more than one auto-generated field."
                      (((unsupported)).apply (((((xself).xassertRaisesMessage)).apply ((xValueError)) ((xmsg)))))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xauto1.write (((unsupported)).apply (((xmodels).xAutoField)) (TRUE))
                            xauto2.write (((unsupported)).apply (((xmodels).xAutoField)) (TRUE))
            (((unsupported)).apply ((xTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xtest_ordering_pointing_to_json_field_value.write
                  [xself]
                    memory > xfield
                    memory > xordering
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfield.write ((((xmodels).xJSONField)).apply)
                            (((unsupported)).apply)
                              xordering.write (((unsupported)).apply ("field__value"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_check_jsonfield.write
                  [xself]
                    memory > xfield
                    memory > xexpected
                    memory > xerror
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield.write ((((xmodels).xJSONField)).apply)
                        xerror.write (((unsupported)).apply ((xError)) (("%s does not support JSONFields.".mod ((xconnection).xdisplay_name))) ((xModel)) ("fields.E180"))
                        xexpected.write ((((xconnection).xfeatures).xsupports_json_field).if (((unsupported)).apply) (((unsupported)).apply ((xerror))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((xexpected)))
                xtest_check_jsonfield_required_db_features.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xfield
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfield.write ((((xmodels).xJSONField)).apply)
                            (((unsupported)).apply)
                              xrequired_db_features.write (((unsupported)).apply ("supports_json_field"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
            (((unsupported)).apply ((xTestCase)) ((((xisolate_apps)).apply ("invalid_models_tests"))))
              seq
                xtest_check_constraints.write
                  [xself]
                    memory > xerrors
                    memory > xwarn
                    memory > xage
                    memory > xexpected
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ((((unsupported)).apply (((xmodels).xQ)) (18))) ("is_adult"))))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xwarn.write (((unsupported)).apply ((xWarning)) (("%s does not support check constraints.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xModel)) ("models.W027"))
                        xexpected.write ((((xconnection).xfeatures).xsupports_table_check_constraints).if (((unsupported)).apply) (((unsupported)).apply ((xwarn))))
                        bogusForceDataize.write ((((xself).xassertCountEqual)).apply ((xerrors)) ((xexpected)))
                xtest_check_constraints_required_db_features.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_table_check_constraints"))
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ((((unsupported)).apply (((xmodels).xQ)) (18))) ("is_adult"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_check_constraint_pointing_to_missing_field.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            seq
                              xrequired_db_features.write (((unsupported)).apply ("supports_table_check_constraints"))
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") ((((unsupported)).apply (((xmodels).xQ)) (2))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) (((((xconnection).xfeatures).xsupports_table_check_constraints).if (((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012")))) (((unsupported)).apply))))
                xtest_check_constraint_pointing_to_reverse_fk.write
                  [xself]
                    memory > xparent
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write (((unsupported)).apply (((xmodels).xForeignKey)) ("self") (((xmodels).xCASCADE)) ("parents"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") ((((unsupported)).apply (((xmodels).xQ)) (3))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'parents'.") ((xModel)) ("models.E012"))))))
                xtest_check_constraint_pointing_to_reverse_o2o.write
                  [xself]
                    memory > xparent
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xOneToOneField)).apply ("self") (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") ((((unsupported)).apply (((xmodels).xQ)) (TRUE))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'model'.") ((xModel)) ("models.E012"))))))
                xtest_check_constraint_pointing_to_m2m_field.write
                  [xself]
                    memory > xconstraints
                    memory > xm2m
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") ((((unsupported)).apply (((xmodels).xQ)) (2))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'constraints'.") ((xModel)) ("models.E013"))))))
                xtest_check_constraint_pointing_to_fk.write
                  [xself]
                    memory > xfk_1
                    memory > xfk_2
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfk_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_1"))
                            xfk_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_2"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") (((((unsupported)).apply (((xmodels).xQ)) (2)).or (((unsupported)).apply (((xmodels).xQ)) (2)))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_check_constraint_pointing_to_pk.write
                  [xself]
                    memory > xage
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xSmallIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") (((((unsupported)).apply (((xmodels).xQ)) (5)).and (((unsupported)).apply (((xmodels).xQ)) (((((xmodels).xF)).apply ("pk")))))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_check_constraint_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xParent)))
                          seq
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") ((((unsupported)).apply (((xmodels).xQ)) (1))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xChild).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to field 'field1' which is not local to model 'Child'.") ("This issue may be caused by multi-table inheritance.") ((xChild)) ("models.E016"))))))
                xtest_check_constraint_pointing_to_joined_fields.write
                  [xself]
                    memory > xconstraints
                    memory > xparent
                    memory > xfield2
                    memory > xerrors
                    memory > xfield3
                    memory > xexpected_errors
                    memory > xprevious
                    memory > xname
                    memory > xjoined_fields
                    memory > xfield1
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xname.write (((unsupported)).apply (((xmodels).xCharField)) (10))
                            xfield1.write ((((xmodels).xPositiveSmallIntegerField)).apply)
                            xfield2.write ((((xmodels).xPositiveSmallIntegerField)).apply)
                            xfield3.write ((((xmodels).xPositiveSmallIntegerField)).apply)
                            xparent.write ((((xmodels).xForeignKey)).apply ("self") (((xmodels).xCASCADE)))
                            xprevious.write (((unsupported)).apply (((xmodels).xOneToOneField)) ("self") (((xmodels).xCASCADE)) ("next"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name1") ((((unsupported)).apply (((xmodels).xQ)) ((((((xmodels).xF)).apply ("parent__field1")).sub ((((xmodels).xF)).apply ("parent__field2")))))))) ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name2") ((((unsupported)).apply (((xmodels).xQ)) ((((xLower)).apply ("parent__name"))))))) ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name3") ((((unsupported)).apply (((xmodels).xQ)) (((((xmodels).xF)).apply ("field1"))))))) ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name4") ((((unsupported)).apply (((xmodels).xQ)) ((((xLower)).apply ("previous__name"))))))))
                        xjoined_fields.write (((unsupported)).apply ("parent__field1") ("parent__field2") ("parent__field3") ("parent__name") ("previous__name"))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xexpected_errors.write (((unsupported)).apply ((((unsupported)).apply ((xError)) (("'constraints' refers to the joined field '%s'.".mod (xfield_name))) ((xModel)) ("models.E041"))) ((xfield_name)) ((xjoined_fields)))
                        bogusForceDataize.write ((((xself).xassertCountEqual)).apply ((xerrors)) ((xexpected_errors)))
                xtest_check_constraint_pointing_to_joined_fields_complex_check.write
                  [xself]
                    memory > xconstraints
                    memory > xparent
                    memory > xfield2
                    memory > xerrors
                    memory > xexpected_errors
                    memory > xname
                    memory > xjoined_fields
                    memory > xfield1
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xname.write ((((xmodels).xPositiveSmallIntegerField)).apply)
                            xfield1.write ((((xmodels).xPositiveSmallIntegerField)).apply)
                            xfield2.write ((((xmodels).xPositiveSmallIntegerField)).apply)
                            xparent.write ((((xmodels).xForeignKey)).apply ("self") (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xCheckConstraint)) ("name") ((((((xmodels).xQ)).apply ((((((unsupported)).apply (((xmodels).xQ)) ("test")).and (((unsupported)).apply (((xmodels).xQ)) (((((xmodels).xF)).apply ("parent__field1"))))).or ((((unsupported)).apply (((xmodels).xQ)) ((((xLower)).apply ("parent__name")))).and (((unsupported)).apply (((xmodels).xQ)) ((((((xmodels).xF)).apply ("parent__field1")).sub ((((xmodels).xF)).apply ("parent__field2"))))))))).or (((unsupported)).apply (((xmodels).xQ)) ("test1")))))))
                        xjoined_fields.write (((unsupported)).apply ("parent__field1") ("parent__field2") ("parent__name"))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xexpected_errors.write (((unsupported)).apply ((((unsupported)).apply ((xError)) (("'constraints' refers to the joined field '%s'.".mod (xfield_name))) ((xModel)) ("models.E041"))) ((xfield_name)) ((xjoined_fields)))
                        bogusForceDataize.write ((((xself).xassertCountEqual)).apply ((xerrors)) ((xexpected_errors)))
                xtest_unique_constraint_with_condition.write
                  [xself]
                    memory > xerrors
                    memory > xexpected
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("age"))) ("unique_age_gte_100") ((((unsupported)).apply (((xmodels).xQ)) (100))))))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xexpected.write ((((xconnection).xfeatures).xsupports_partial_indexes).if (((unsupported)).apply) (((unsupported)).apply ((((unsupported)).apply ((xWarning)) (("%s does not support unique constraints with conditions.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xModel)) ("models.W036")))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerrors)) ((xexpected)))
                xtest_unique_constraint_with_condition_required_db_features.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_partial_indexes"))
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("age"))) ("unique_age_gte_100") ((((unsupported)).apply (((xmodels).xQ)) (100))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_unique_constraint_condition_pointing_to_missing_field.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xSmallIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_partial_indexes"))
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ("name") ((((unsupported)).apply ("age"))) ((((unsupported)).apply (((xmodels).xQ)) (2))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) (((((xconnection).xfeatures).xsupports_partial_indexes).if (((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012")))) (((unsupported)).apply))))
                xtest_unique_constraint_condition_pointing_to_joined_fields.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xparent
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xSmallIntegerField)).apply)
                            xparent.write ((((xmodels).xForeignKey)).apply ("self") (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_partial_indexes"))
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ("name") ((((unsupported)).apply ("age"))) ((((unsupported)).apply (((xmodels).xQ)) (2))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) (((((xconnection).xfeatures).xsupports_partial_indexes).if (((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the joined field 'parent__age__lt'.") ((xModel)) ("models.E041")))) (((unsupported)).apply))))
                xtest_unique_constraint_pointing_to_reverse_o2o.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xparent
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xparent.write ((((xmodels).xOneToOneField)).apply ("self") (((xmodels).xCASCADE)))
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_partial_indexes"))
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("parent"))) ("name") ((((unsupported)).apply (((xmodels).xQ)) (TRUE))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) (((((xconnection).xfeatures).xsupports_partial_indexes).if (((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'model'.") ((xModel)) ("models.E012")))) (((unsupported)).apply))))
                xtest_deferrable_unique_constraint.write
                  [xself]
                    memory > xerrors
                    memory > xexpected
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("age"))) ("unique_age_deferrable") ((((xmodels).xDeferrable).xDEFERRED)))))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xexpected.write ((((xconnection).xfeatures).xsupports_deferrable_unique_constraints).if (((unsupported)).apply) (((unsupported)).apply ((((unsupported)).apply ((xWarning)) (("%s does not support deferrable unique constraints.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xModel)) ("models.W038")))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerrors)) ((xexpected)))
                xtest_deferrable_unique_constraint_required_db_features.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_deferrable_unique_constraints"))
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("age"))) ("unique_age_deferrable") ((((xmodels).xDeferrable).xIMMEDIATE)))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_unique_constraint_pointing_to_missing_field.write
                  [xself]
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("missing_field"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_unique_constraint_pointing_to_m2m_field.write
                  [xself]
                    memory > xconstraints
                    memory > xm2m
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("m2m"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'constraints'.") ((xModel)) ("models.E013"))))))
                xtest_unique_constraint_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xfield2
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xParent)))
                          seq
                            xfield2.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("field2") ("field1"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xChild).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to field 'field1' which is not local to model 'Child'.") ("This issue may be caused by multi-table inheritance.") ((xChild)) ("models.E016"))))))
                xtest_unique_constraint_pointing_to_fk.write
                  [xself]
                    memory > xfk_1
                    memory > xfk_2
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfk_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_1"))
                            xfk_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_2"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("fk_1_id") ("fk_2"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_unique_constraint_with_include.write
                  [xself]
                    memory > xerrors
                    memory > xexpected
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("age"))) ("unique_age_include_id") ((((unsupported)).apply ("id"))))))
                        xerrors.write (((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))
                        xexpected.write ((((xconnection).xfeatures).xsupports_covering_indexes).if (((unsupported)).apply) (((unsupported)).apply ((((unsupported)).apply ((xWarning)) (("%s does not support unique constraints with non-key columns.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xModel)) ("models.W039")))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerrors)) ((xexpected)))
                xtest_unique_constraint_with_include_required_db_features.write
                  [xself]
                    memory > xrequired_db_features
                    memory > xage
                    memory > xconstraints
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xage.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              seq
                                xrequired_db_features.write (((unsupported)).apply ("supports_covering_indexes"))
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("age"))) ("unique_age_include_id") ((((unsupported)).apply ("id"))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_unique_constraint_include_pointing_to_missing_field.write
                  [xself]
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("id"))) ((((unsupported)).apply ("missing_field"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_unique_constraint_include_pointing_to_m2m_field.write
                  [xself]
                    memory > xconstraints
                    memory > xm2m
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("id"))) ((((unsupported)).apply ("m2m"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'constraints'.") ((xModel)) ("models.E013"))))))
                xtest_unique_constraint_include_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xfield2
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write ((((xmodels).xIntegerField)).apply)
                        (((unsupported)).apply ((xParent)))
                          seq
                            xfield2.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("field2"))) ((((unsupported)).apply ("field1"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xChild).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to field 'field1' which is not local to model 'Child'.") ("This issue may be caused by multi-table inheritance.") ((xChild)) ("models.E016"))))))
                xtest_unique_constraint_include_pointing_to_fk.write
                  [xself]
                    memory > xfk_1
                    memory > xfk_2
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfk_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_1"))
                            xfk_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xTarget)) (((xmodels).xCASCADE)) ("target_2"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((unsupported)).apply ("id"))) ((((unsupported)).apply ("fk_1_id") ("fk_2"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_func_unique_constraint.write
                  [xself]
                    memory > xname
                    memory > xconstraints
                    memory > xexpected
                    memory > xwarn
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xname.write (((unsupported)).apply (((xmodels).xCharField)) (10))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((xLower)).apply ("name"))) ("lower_name_uq"))))
                        xwarn.write (((unsupported)).apply ((xWarning)) (("%s does not support unique constraints on expressions.".mod ((xconnection).xdisplay_name))) ("A constraint won't be created. Silence this warning if you don't care about it.") ((xModel)) ("models.W044"))
                        xexpected.write ((((xconnection).xfeatures).xsupports_expression_indexes).if (((unsupported)).apply) (((unsupported)).apply ((xwarn))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((xexpected)))
                xtest_func_unique_constraint_required_db_features.write
                  [xself]
                    memory > xconstraints
                    memory > xrequired_db_features
                    memory > xname
                    seq > @
                      seq
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xname.write (((unsupported)).apply (((xmodels).xCharField)) (10))
                            (((unsupported)).apply)
                              seq
                                xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((xLower)).apply ("name"))) ("lower_name_unq"))))
                                xrequired_db_features.write (((unsupported)).apply ("supports_expression_indexes"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_func_unique_constraint_expression_custom_lookup.write
                  [xself]
                    memory > xweight
                    memory > xheight
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xheight.write ((((xmodels).xIntegerField)).apply)
                            xweight.write ((((xmodels).xIntegerField)).apply)
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((((xmodels).xF)).apply ("height")).div (((((xmodels).xF)).apply ("weight__abs")).sub ((((xmodels).xValue)).apply (5))))) ("name"))))
                        (((unsupported)).apply ((((xregister_lookup)).apply (((xmodels).xIntegerField)) ((xAbs)))))
                          bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))
                xtest_func_unique_constraint_pointing_to_missing_field.write
                  [xself]
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) (((((((xLower)).apply ("missing_field")).xdesc)).apply)) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_func_unique_constraint_pointing_to_missing_field_nested.write
                  [xself]
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          (((unsupported)).apply)
                            xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((xAbs)).apply ((((xRound)).apply ("missing_field"))))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to the nonexistent field 'missing_field'.") ((xModel)) ("models.E012"))))))
                xtest_func_unique_constraint_pointing_to_m2m_field.write
                  [xself]
                    memory > xconstraints
                    memory > xm2m
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xm2m.write ((((xmodels).xManyToManyField)).apply ("self"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((xLower)).apply ("m2m"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xModel).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to a ManyToManyField 'm2m', but ManyToManyFields are not permitted in 'constraints'.") ((xModel)) ("models.E013"))))))
                xtest_func_unique_constraint_pointing_to_non_local_field.write
                  [xself]
                    memory > xfield1
                    memory > xconstraints
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xfield1.write (((unsupported)).apply (((xmodels).xCharField)) (15))
                        (((unsupported)).apply ((xFoo)))
                          (((unsupported)).apply)
                            xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((xLower)).apply ("field1"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xBar).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("'constraints' refers to field 'field1' which is not local to model 'Bar'.") ("This issue may be caused by multi-table inheritance.") ((xBar)) ("models.E016"))))))
                xtest_func_unique_constraint_pointing_to_fk.write
                  [xself]
                    memory > xid
                    memory > xconstraints
                    memory > xfoo_2
                    memory > xfoo_1
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xmodels).xModel)))
                          xid.write (((unsupported)).apply (((xmodels).xCharField)) (TRUE) (255))
                        (((unsupported)).apply (((xmodels).xModel)))
                          seq
                            xfoo_1.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_1"))
                            xfoo_2.write (((unsupported)).apply (((xmodels).xForeignKey)) ((xFoo)) (((xmodels).xCASCADE)) ("bar_2"))
                            (((unsupported)).apply)
                              xconstraints.write (((unsupported)).apply ((((unsupported)).apply (((xmodels).xUniqueConstraint)) ((((xLower)).apply ("foo_1_id"))) ((((xLower)).apply ("foo_2"))) ("name"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply (((xBar).xcheck)) (((xself).xdatabases)))) ((((unsupported)).apply)))