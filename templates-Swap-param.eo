memory > xContext
memory > xfilename
memory > xImportError
memory > xexclude
memory > xold_suffix
memory > ximport_module
memory > xstat
memory > xfile
memory > x_
memory > xdirs
memory > xtempfile
memory > xopen
memory > xBaseCommand
memory > xsettings
memory > xtuple
memory > xmap
memory > xpath_to_remove
memory > xhandle_extensions
memory > xdjango
memory > xarchive
memory > xEngine
memory > xtemplate_file
memory > xx
memory > xnew_suffix
memory > xparams
memory > xdisplay_url
memory > xargparse
memory > xfiles
memory > xOSError
memory > xos
memory > xdirname
memory > xnew_file
memory > xe
memory > xtarget
memory > xposixpath
memory > xbuild_opener
memory > xshutil
memory > xsource
memory > xdirectory
memory > xoptions
memory > xget_docs_version
memory > xcgi
memory > xrun_formatters
memory > xroot
memory > xCommandError
memory > xlen
memory > xFileExistsError
memory > xmimetypes
[] > templates
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xrequires_system_checks
        memory > xapply_umask
        memory > xhandle_template
        memory > xextract
        memory > xurl_schemes
        memory > xis_url
        memory > xrewrite_template_suffixes
        memory > xhandle
        memory > xmake_writeable
        memory > xsplitext
        memory > xadd_arguments
        memory > xvalidate_name
        memory > xdownload
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply ((xBaseCommand)))
              seq
                (((unsupported)).apply)
                xrequires_system_checks.write (((unsupported)).apply)
                xurl_schemes.write (((unsupported)).apply ("http") ("https") ("ftp"))
                xrewrite_template_suffixes.write (((unsupported)).apply ((((unsupported)).apply (".py-tpl") (".py"))))
                xadd_arguments.write
                  [xself xparser]
                    seq > @
                      seq
                        (((unsupported)).apply (((xparser).xadd_argument)) ("name") ("Name of the application or project."))
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        seq
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--template") ("The path or URL to load the template from."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--extension") ("-e") ("extensions") ("append") ((((unsupported)).apply ("py"))) ("The file extension(s) to render (default: \"py\"). Separate multiple extensions with commas, or use -e multiple times."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--name") ("-n") ("files") ("append") ((((unsupported)).apply)) ("The file name(s) to render. Separate multiple file names with commas, or use -n multiple times."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--exclude") ("-x") ("append") (((xargparse).xSUPPRESS)) ("?") ("") ("The directory name(s) to exclude, in addition to .git and __pycache__. Can be used multiple times."))
                xhandle.write
                  [xself xapp_or_project xname xtarget]
                    memory > xbase_name
                    memory > xbase_directory
                    memory > xtemplate
                    memory > xprefix_length
                    memory > xtarget_dir
                    memory > xcontent
                    memory > xnew_path
                    memory > xcamel_case_name
                    memory > xbase_subdir
                    memory > xtop_dir
                    memory > xextensions
                    memory > xtemplate_dir
                    memory > xexcluded_directories
                    memory > xrelative_dir
                    memory > xold_path
                    memory > xextra_files
                    memory > xcamel_case_value
                    memory > xcontext
                    memory > xpath_rest
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xwritten_files)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xapp_or_project)) ((xapp_or_project)))
                        (((unsupported)).apply (((xself).xa_or_an)) ((((xapp_or_project).eq "app").if "an" "a")))
                        (((unsupported)).apply (((xself).xpaths_to_remove)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xverbosity)) ((((unsupported)).apply ((xoptions)) ("verbosity"))))
                        bogusForceDataize.write ((((xself).xvalidate_name)).apply ((xname)))
                        (((unsupported)).apply ((xtarget)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xtop_dir.write (((((xos).xpath).xjoin)).apply (((((xos).xgetcwd)).apply)) ((xname)))
                            (((unsupported)).apply ((xFileExistsError)) ((xOSError)))
                              bogusForceDataize.write ((((xos).xmakedirs)).apply ((xtop_dir)))
                              (((unsupported)).apply ((((xCommandError)).apply (("'%s' already exists".mod (xtop_dir))))))
                              (((unsupported)).apply ((((xCommandError)).apply ((xe)))))
                          seq
                            xtop_dir.write (((((xos).xpath).xabspath)).apply ((((((xos).xpath).xexpanduser)).apply ((xtarget)))))
                            ((xapp_or_project).eq "app").if
                              bogusForceDataize.write ((((xself).xvalidate_name)).apply ((((((xos).xpath).xbasename)).apply ((xtop_dir)))) ("directory"))
                            ((((((xos).xpath).xexists)).apply ((xtop_dir))).not).if
                              (((unsupported)).apply ((((xCommandError)).apply (("Destination directory '%s' does not exist, please create it first.".mod (xtop_dir))))))
                        xextensions.write (((xtuple)).apply ((((xhandle_extensions)).apply ((((unsupported)).apply ((xoptions)) ("extensions"))))))
                        xextra_files.write (((unsupported)).apply)
                        xexcluded_directories.write (((unsupported)).apply (".git") ("__pycache__"))
                        (((unsupported)).apply ((xfile)) ((((unsupported)).apply ((xoptions)) ("files"))))
                          bogusForceDataize.write ((((xextra_files).xextend)).apply ((((xmap)).apply ((((unsupported)).apply (((((xx).xstrip)).apply)))) (((((xfile).xsplit)).apply (","))))))
                        (((unsupported)).apply (((((xoptions).xget)).apply ("exclude")))).if
                          (((unsupported)).apply ((xdirectory)) ((xexclude)))
                            bogusForceDataize.write ((((xexcluded_directories).xappend)).apply (((((xdirectory).xstrip)).apply)))
                        (((xself).xverbosity).geq 2).if
                          seq
                            bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("Rendering %s template files with extensions: %s".mod (((unsupported)).apply ((xapp_or_project)) ((((", ".xjoin)).apply ((xextensions))))))))
                            bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("Rendering %s template files with filenames: %s".mod (((unsupported)).apply ((xapp_or_project)) ((((", ".xjoin)).apply ((xextra_files))))))))
                        xbase_name.write ("%s_name".mod (xapp_or_project))
                        xbase_subdir.write ("%s_template".mod (xapp_or_project))
                        xbase_directory.write ("%s_directory".mod (xapp_or_project))
                        xcamel_case_name.write ("camel_case_%s_name".mod (xapp_or_project))
                        xcamel_case_value.write ((("".xjoin)).apply ((((unsupported)).apply ((xx)) ((xx)) (((((xname).xtitle)).apply)) (((xx).neq "_")))))
                        xcontext.write (((unsupported)).apply ((xContext)) ((((unsupported)).apply ((xoptions)) ((xbase_name)) ((xname)) ((xbase_directory)) ((xtop_dir)) ((xcamel_case_name)) ((xcamel_case_value)) ("docs_version") ((((xget_docs_version)).apply)) ("django_version") (((xdjango).x__version__)))) (FALSE))
                        (((xsettings).xconfigured).not).if
                          seq
                            bogusForceDataize.write ((((xsettings).xconfigure)).apply)
                            bogusForceDataize.write ((((xdjango).xsetup)).apply)
                        xtemplate_dir.write ((((xself).xhandle_template)).apply ((((unsupported)).apply ((xoptions)) ("template"))) ((xbase_subdir)))
                        xprefix_length.write ((((xlen)).apply ((xtemplate_dir))).add 1)
                        (((unsupported)).apply ((((unsupported)).apply ((xroot)) ((xdirs)) ((xfiles)))) (((((xos).xwalk)).apply ((xtemplate_dir)))))
                          seq
                            xpath_rest.write (((unsupported)).apply ((xroot)) ((((unsupported)).apply ((xprefix_length)))))
                            xrelative_dir.write ((((xpath_rest).xreplace)).apply ((xbase_name)) ((xname)))
                            (xrelative_dir).if
                              seq
                                xtarget_dir.write (((((xos).xpath).xjoin)).apply ((xtop_dir)) ((xrelative_dir)))
                                (((unsupported)).apply (((xos).xmakedirs)) ((xtarget_dir)) (TRUE))
                            (((unsupported)).apply ((xdirname)) ((((unsupported)).apply ((xdirs)) ((((unsupported)).apply)))))
                              (((unsupported)).apply ("exclude") ((xoptions))).if
                                (((((xdirname).xstartswith)).apply (".")).or ((xdirname).eq "__pycache__")).if
                                  bogusForceDataize.write ((((xdirs).xremove)).apply ((xdirname)))
                                (((unsupported)).apply ((xdirname)) ((xexcluded_directories))).if
                                  bogusForceDataize.write ((((xdirs).xremove)).apply ((xdirname)))
                            (((unsupported)).apply ((xfilename)) ((xfiles)))
                              seq
                                ((((xfilename).xendswith)).apply ((((unsupported)).apply (".pyo") (".pyc") (".py.class")))).if
                                  (((unsupported)).apply)
                                xold_path.write (((((xos).xpath).xjoin)).apply ((xroot)) ((xfilename)))
                                xnew_path.write (((((xos).xpath).xjoin)).apply ((xtop_dir)) ((xrelative_dir)) (((((xfilename).xreplace)).apply ((xbase_name)) ((xname)))))
                                (((unsupported)).apply ((((unsupported)).apply ((xold_suffix)) ((xnew_suffix)))) (((xself).xrewrite_template_suffixes)))
                                  ((((xnew_path).xendswith)).apply ((xold_suffix))).if
                                    seq
                                      xnew_path.write ((((unsupported)).apply ((xnew_path)) ((((unsupported)).apply (((((xlen)).apply ((xold_suffix))).neg))))).add (xnew_suffix))
                                      (((unsupported)).apply)
                                (((((xos).xpath).xexists)).apply ((xnew_path))).if
                                  (((unsupported)).apply ((((xCommandError)).apply (("%s already exists. Overlaying %s %s into an existing directory won't replace conflicting files.".mod (((unsupported)).apply ((xnew_path)) (((xself).xa_or_an)) ((xapp_or_project))))))))
                                (((((xnew_path).xendswith)).apply ((xextensions))).or (((unsupported)).apply ((xfilename)) ((xextra_files)))).if
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply ((xopen)) ((xold_path)) ("utf-8"))) ((xtemplate_file)))
                                      xcontent.write ((((xtemplate_file).xread)).apply)
                                    xtemplate.write ((((((xEngine)).apply).xfrom_string)).apply ((xcontent)))
                                    xcontent.write ((((xtemplate).xrender)).apply ((xcontext)))
                                    (((unsupported)).apply ((((unsupported)).apply ((xopen)) ((xnew_path)) ("w") ("utf-8"))) ((xnew_file)))
                                      bogusForceDataize.write ((((xnew_file).xwrite)).apply ((xcontent)))
                                  bogusForceDataize.write ((((xshutil).xcopyfile)).apply ((xold_path)) ((xnew_path)))
                                bogusForceDataize.write (((((xself).xwritten_files).xappend)).apply ((xnew_path)))
                                (((xself).xverbosity).geq 2).if
                                  bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("Creating %s".mod (xnew_path))))
                                (((unsupported)).apply ((xOSError)))
                                  seq
                                    bogusForceDataize.write ((((xself).xapply_umask)).apply ((xold_path)) ((xnew_path)))
                                    bogusForceDataize.write ((((xself).xmake_writeable)).apply ((xnew_path)))
                                  bogusForceDataize.write (((((xself).xstderr).xwrite)).apply (("Notice: Couldn't set permission bits on %s. You're probably using an uncommon filesystem setup. No problem.".mod (xnew_path))) ((((xself).xstyle).xNOTICE)))
                        ((xself).xpaths_to_remove).if
                          seq
                            (((xself).xverbosity).geq 2).if
                              bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("Cleaning up temporary files."))
                            (((unsupported)).apply ((xpath_to_remove)) (((xself).xpaths_to_remove)))
                              (((((xos).xpath).xisfile)).apply ((xpath_to_remove))).if
                                bogusForceDataize.write ((((xos).xremove)).apply ((xpath_to_remove)))
                                bogusForceDataize.write ((((xshutil).xrmtree)).apply ((xpath_to_remove)))
                        bogusForceDataize.write (((xrun_formatters)).apply (((xself).xwritten_files)))
                xhandle_template.write
                  [xself xtemplate xsubdir]
                    memory > xexpanded_template
                    memory > xabsolute_path
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xtemplate)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((((xos).xpath).xjoin)).apply ((((unsupported)).apply (((xdjango).x__path__)) (0))) ("conf") ((xsubdir)))))
                          seq
                            ((((xtemplate).xstartswith)).apply ("file://")).if
                              xtemplate.write (((unsupported)).apply ((xtemplate)) ((((unsupported)).apply (7))))
                            xexpanded_template.write (((((xos).xpath).xexpanduser)).apply ((xtemplate)))
                            xexpanded_template.write (((((xos).xpath).xnormpath)).apply ((xexpanded_template)))
                            (((((xos).xpath).xisdir)).apply ((xexpanded_template))).if
                              (((unsupported)).apply ((xexpanded_template)))
                            ((((xself).xis_url)).apply ((xtemplate))).if
                              xabsolute_path.write ((((xself).xdownload)).apply ((xtemplate)))
                              xabsolute_path.write (((((xos).xpath).xabspath)).apply ((xexpanded_template)))
                            (((((xos).xpath).xexists)).apply ((xabsolute_path))).if
                              (((unsupported)).apply (((((xself).xextract)).apply ((xabsolute_path)))))
                        (((unsupported)).apply ((((xCommandError)).apply (("couldn't handle %s template %s.".mod (((unsupported)).apply (((xself).xapp_or_project)) ((xtemplate))))))))
                xvalidate_name.write
                  [xself xname xname_or_dir]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xname)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xCommandError)).apply ((((unsupported)).apply (("you must provide {an} {app} name".xformat)) (((xself).xa_or_an)) (((xself).xapp_or_project)))))))
                        (((((xname).xisidentifier)).apply).not).if
                          (((unsupported)).apply ((((xCommandError)).apply ((((unsupported)).apply (("'{name}' is not a valid {app} {type}. Please make sure the {type} is a valid identifier.".xformat)) ((xname)) (((xself).xapp_or_project)) ((xname_or_dir)))))))
                        (((unsupported)).apply ((xImportError)))
                          bogusForceDataize.write (((ximport_module)).apply ((xname)))
                          (((unsupported)).apply ((((xCommandError)).apply ((((unsupported)).apply (("'{name}' conflicts with the name of an existing Python module and cannot be used as {an} {app} {type}. Please try another {type}.".xformat)) ((xname)) (((xself).xa_or_an)) (((xself).xapp_or_project)) ((xname_or_dir)))))))
                xdownload.write
                  [xself xurl]
                    memory > xused_name
                    memory > xprefix
                    memory > xext
                    memory > xopener
                    memory > xheaders
                    memory > xguessed_filename
                    memory > xcleanup_url
                    memory > xcontent_disposition
                    memory > xtempdir
                    memory > xcontent_type
                    memory > xguessed_path
                    memory > xthe_path
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xcleanup_url.write
                          [xurl]
                            memory > xdisplay_url
                            memory > xtmp
                            memory > xfilename
                            seq > @
                              seq
                                xtmp.write ((((xurl).xrstrip)).apply ("/"))
                                xfilename.write (((unsupported)).apply (((((xtmp).xsplit)).apply ("/"))) ((1.neg)))
                                ((((xurl).xendswith)).apply ("/")).if
                                  xdisplay_url.write ((xtmp).add "/")
                                  xdisplay_url.write (xurl)
                                (((unsupported)).apply ((((unsupported)).apply ((xfilename)) ((xdisplay_url)))))
                        xprefix.write ("django_%s_template_".mod ((xself).xapp_or_project))
                        xtempdir.write (((unsupported)).apply (((xtempfile).xmkdtemp)) ((xprefix)) ("_download"))
                        bogusForceDataize.write (((((xself).xpaths_to_remove).xappend)).apply ((xtempdir)))
                        (((unsupported)).apply ((((unsupported)).apply ((xfilename)) ((xdisplay_url)))) ((((xcleanup_url)).apply ((xurl)))))
                        (((xself).xverbosity).geq 2).if
                          bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("Downloading %s".mod (xdisplay_url))))
                        xthe_path.write (((((xos).xpath).xjoin)).apply ((xtempdir)) ((xfilename)))
                        xopener.write (((xbuild_opener)).apply)
                        (((unsupported)).apply (((xopener).xaddheaders)) ((((unsupported)).apply ((((unsupported)).apply ("User-Agent") ("Django/{django.__version__}"))))))
                        (((unsupported)).apply ((xOSError)))
                          (((unsupported)).apply (((((xopener).xopen)).apply ((xurl)))) ((xsource)) ((((xopen)).apply ((xthe_path)) ("wb"))) ((xtarget)))
                            seq
                              xheaders.write ((((xsource).xinfo)).apply)
                              bogusForceDataize.write ((((xtarget).xwrite)).apply (((((xsource).xread)).apply)))
                          (((unsupported)).apply ((((xCommandError)).apply (("couldn't download URL %s to %s: %s".mod (((unsupported)).apply ((xurl)) ((xfilename)) ((xe))))))))
                        xused_name.write (((unsupported)).apply (((((xthe_path).xsplit)).apply ("/"))) ((1.neg)))
                        xcontent_disposition.write (((unsupported)).apply ((xheaders)) ("content-disposition"))
                        (xcontent_disposition).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xparams)))) (((((xcgi).xparse_header)).apply ((xcontent_disposition)))))
                            xguessed_filename.write (((((xparams).xget)).apply ("filename")).or (xused_name))
                          xguessed_filename.write (xused_name)
                        xext.write (((unsupported)).apply (((((xself).xsplitext)).apply ((xguessed_filename)))) (1))
                        xcontent_type.write (((unsupported)).apply ((xheaders)) ("content-type"))
                        (((xext).not).and (xcontent_type)).if
                          seq
                            xext.write ((((xmimetypes).xguess_extension)).apply ((xcontent_type)))
                            (xext).if
                              (((unsupported)).apply ((xguessed_filename)) ((xext)))
                        ((xused_name).neq (xguessed_filename)).if
                          seq
                            xguessed_path.write (((((xos).xpath).xjoin)).apply ((xtempdir)) ((xguessed_filename)))
                            bogusForceDataize.write ((((xshutil).xmove)).apply ((xthe_path)) ((xguessed_path)))
                            (((unsupported)).apply ((xguessed_path)))
                        (((unsupported)).apply ((xthe_path)))
                xsplitext.write
                  [xself xthe_path]
                    memory > xext
                    memory > xbase
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xbase)) ((xext)))) (((((xposixpath).xsplitext)).apply ((xthe_path)))))
                        (((((((xbase).xlower)).apply).xendswith)).apply (".tar")).if
                          seq
                            xext.write ((((unsupported)).apply ((xbase)) ((((unsupported)).apply ((4.neg))))).add (xext))
                            xbase.write (((unsupported)).apply ((xbase)) ((((unsupported)).apply ((4.neg)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xbase)) ((xext)))))
                xextract.write
                  [xself xfilename]
                    memory > xtempdir
                    memory > xprefix
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xprefix.write ("django_%s_template_".mod ((xself).xapp_or_project))
                        xtempdir.write (((unsupported)).apply (((xtempfile).xmkdtemp)) ((xprefix)) ("_extract"))
                        bogusForceDataize.write (((((xself).xpaths_to_remove).xappend)).apply ((xtempdir)))
                        (((xself).xverbosity).geq 2).if
                          bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("Extracting %s".mod (xfilename))))
                        (((unsupported)).apply ((((unsupported)).apply (((xarchive).xArchiveException)) ((xOSError)))))
                          seq
                            bogusForceDataize.write ((((xarchive).xextract)).apply ((xfilename)) ((xtempdir)))
                            (((unsupported)).apply ((xtempdir)))
                          (((unsupported)).apply ((((xCommandError)).apply (("couldn't extract file %s to %s: %s".mod (((unsupported)).apply ((xfilename)) ((xtempdir)) ((xe))))))))
                xis_url.write
                  [xself xtemplate]
                    memory > xscheme
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (":") ((xtemplate))).if
                          (((unsupported)).apply (FALSE))
                        xscheme.write ((((((unsupported)).apply (((((xtemplate).xsplit)).apply (":") (1))) (0)).xlower)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xscheme)) (((xself).xurl_schemes)))))
                xapply_umask.write
                  [xself xold_path xnew_path]
                    memory > xcurrent_umask
                    memory > xcurrent_mode
                    seq > @
                      seq
                        xcurrent_umask.write ((((xos).xumask)).apply (0))
                        bogusForceDataize.write ((((xos).xumask)).apply ((xcurrent_umask)))
                        xcurrent_mode.write ((((xstat).xS_IMODE)).apply ((((((xos).xstat)).apply ((xold_path))).xst_mode)))
                        bogusForceDataize.write ((((xos).xchmod)).apply ((xnew_path)) (((xcurrent_mode).and ((xcurrent_umask).neg))))
                xmake_writeable.write
                  [xself xfilename]
                    memory > xst
                    memory > xnew_permissions
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((((xos).xaccess)).apply ((xfilename)) (((xos).xW_OK))).not).if
                          seq
                            xst.write ((((xos).xstat)).apply ((xfilename)))
                            xnew_permissions.write (((((xstat).xS_IMODE)).apply (((xst).xst_mode))).or ((xstat).xS_IWUSR))
                            bogusForceDataize.write ((((xos).xchmod)).apply ((xfilename)) ((xnew_permissions)))