memory > xValueError
memory > xapps
memory > xCombinable
memory > xhasattr
memory > xModelAdmin
memory > xDjangoTemplates
memory > xListFilter
memory > xengine
memory > xsubfield_name
memory > xflatten
memory > xImportError
memory > xAttributeError
memory > xFieldDoesNotExist
memory > xcount
memory > xlist
memory > xsite
memory > xBaseModelForm
memory > xindex
memory > xfieldset_fields
memory > xenumerate
memory > xNotRelationField
memory > xFieldListFilter
memory > ximport_string
memory > xchecks
memory > xLOOKUP_SEP
memory > xlist_filter_class
memory > xfunc
memory > xfieldset
memory > xcollections
memory > x_
memory > x_get_foreign_key
memory > xVERTICAL
memory > xany
memory > xtype
memory > xpermission
memory > xcallable
memory > xpath
memory > xset
memory > xsettings
memory > xint
memory > xHORIZONTAL
memory > xall_sites
memory > xsuper
memory > xchain
memory > xbool
memory > xissubclass
memory > xtuple
memory > xitem
memory > xval
memory > xgetattr
memory > xBaseModelFormSet
memory > xe
memory > xname
memory > xengines
memory > xget_fields_from_path
memory > xmodels
memory > xBaseModelAdminChecks
memory > xInlineModelAdmin
memory > xisinstance
memory > xfield_name
memory > xdict
memory > xlen
memory > xapp_name
memory > xTypeError
memory > xerror_code
[] > checks
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > x_check_date_hierarchy
        memory > x_check_inlines
        memory > x_check_list_select_related
        memory > x_check_min_num
        memory > x_check_action_permission_methods
        memory > x_check_extra
        memory > x_check_formset
        memory > x_check_radio_fields_value
        memory > x_check_exclude_of_parent_model
        memory > x_check_filter_vertical
        memory > x_contains_subclass
        memory > x_check_list_display_item
        memory > x_check_list_display
        memory > x_check_raw_id_fields_item
        memory > xcheck_admin_app
        memory > x_check_list_display_links_item
        memory > x_check_list_filter_item
        memory > xcheck
        memory > x_check_list_editable_item
        memory > x_check_fields
        memory > x_check_form
        memory > x_check_relation
        memory > x_check_field_spec_item
        memory > x_check_field_spec
        memory > x_check_filter_horizontal
        memory > x_check_fieldsets
        memory > x_check_prepopulated_fields
        memory > x_check_readonly_fields
        memory > x_check_autocomplete_fields_item
        memory > x_check_actions_uniqueness
        memory > x_check_radio_fields_key
        memory > x_check_raw_id_fields
        memory > x_check_save_as
        memory > xmust_be
        memory > x_check_list_filter
        memory > x_check_save_on_top
        memory > x_check_exclude
        memory > x_check_view_on_site_url
        memory > xrefer_to_missing_field
        memory > x_check_prepopulated_fields_value_item
        memory > x_check_search_fields
        memory > x_check_inlines_item
        memory > x_check_filter_item
        memory > x_check_radio_fields
        memory > x_check_fieldsets_item
        memory > x_check_list_editable
        memory > x_check_autocomplete_fields
        memory > x_check_ordering
        memory > x_check_max_num
        memory > x_check_ordering_item
        memory > x_check_prepopulated_fields_key
        memory > x_check_list_max_show_all
        memory > xmust_inherit_from
        memory > x_check_readonly_fields_item
        memory > x_issubclass
        memory > x_check_prepopulated_fields_value
        memory > x_check_list_per_page
        memory > x_check_list_display_links
        memory > xcheck_dependencies
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x_issubclass.write
              [xcls xclassinfo]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xTypeError)))
                      (((unsupported)).apply ((((xissubclass)).apply ((xcls)) ((xclassinfo)))))
                      (((unsupported)).apply (FALSE))
            x_contains_subclass.write
              [xclass_path xcandidate_paths]
                memory > xcls
                memory > xcandidate_cls
                seq > @
                  seq
                    (((unsupported)).apply)
                    xcls.write (((ximport_string)).apply ((xclass_path)))
                    (((unsupported)).apply ((xpath)) ((xcandidate_paths)))
                      seq
                        (((unsupported)).apply ((xImportError)))
                          xcandidate_cls.write (((ximport_string)).apply ((xpath)))
                          (((unsupported)).apply)
                        (((x_issubclass)).apply ((xcandidate_cls)) ((xcls))).if
                          (((unsupported)).apply (TRUE))
                    (((unsupported)).apply (FALSE))
            xcheck_admin_app.write
              [xapp_configs]
                memory > xerrors
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xerrors.write (((unsupported)).apply)
                    (((unsupported)).apply ((xsite)) ((xall_sites)))
                      bogusForceDataize.write ((((xerrors).xextend)).apply (((((xsite).xcheck)).apply ((xapp_configs)))))
                    (((unsupported)).apply ((xerrors)))
            xcheck_dependencies.write
              []
                memory > xerrors
                memory > xdjango_templates_instance
                memory > xsidebar_enabled
                memory > xapp_dependencies
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((((xapps).xis_installed)).apply ("django.contrib.admin")).not).if
                      (((unsupported)).apply ((((unsupported)).apply)))
                    xerrors.write (((unsupported)).apply)
                    xapp_dependencies.write (((unsupported)).apply ((((unsupported)).apply ("django.contrib.contenttypes") (401))) ((((unsupported)).apply ("django.contrib.auth") (405))) ((((unsupported)).apply ("django.contrib.messages") (406))))
                    (((unsupported)).apply ((((unsupported)).apply ((xapp_name)) ((xerror_code)))) ((xapp_dependencies)))
                      (((((xapps).xis_installed)).apply ((xapp_name))).not).if
                        bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' must be in INSTALLED_APPS in order to use the admin application.".mod (xapp_name))) (("admin.E%d".mod (xerror_code))))))
                    (((unsupported)).apply ((xengine)) (((((xengines).xall)).apply)))
                      (((xisinstance)).apply ((xengine)) ((xDjangoTemplates))).if
                        seq
                          xdjango_templates_instance.write ((xengine).xengine)
                          (((unsupported)).apply)
                      xdjango_templates_instance.write "None: is there a None literal in the EO language?"
                    ((xdjango_templates_instance).not).if
                      bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("A 'django.template.backends.django.DjangoTemplates' instance must be configured in TEMPLATES in order to use the admin application.") ("admin.E403"))))
                      seq
                        ((((unsupported)).apply ("django.contrib.auth.context_processors.auth") (((xdjango_templates_instance).xcontext_processors))).and (((x_contains_subclass)).apply ("django.contrib.auth.backends.ModelBackend") (((xsettings).xAUTHENTICATION_BACKENDS)))).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("'django.contrib.auth.context_processors.auth' must be enabled in DjangoTemplates (TEMPLATES) if using the default auth backend in order to use the admin application.") ("admin.E402"))))
                        (((unsupported)).apply ("django.contrib.messages.context_processors.messages") (((xdjango_templates_instance).xcontext_processors))).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("'django.contrib.messages.context_processors.messages' must be enabled in DjangoTemplates (TEMPLATES) in order to use the admin application.") ("admin.E404"))))
                        xsidebar_enabled.write (((xany)).apply ((((unsupported)).apply (((xsite).xenable_nav_sidebar)) ((xsite)) ((xall_sites)))))
                        ((xsidebar_enabled).and (((unsupported)).apply ("django.template.context_processors.request") (((xdjango_templates_instance).xcontext_processors)))).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) ("'django.template.context_processors.request' must be enabled in DjangoTemplates (TEMPLATES) in order to use the admin navigation sidebar.") ("admin.W411"))))
                    ((((x_contains_subclass)).apply ("django.contrib.auth.middleware.AuthenticationMiddleware") (((xsettings).xMIDDLEWARE))).not).if
                      bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("'django.contrib.auth.middleware.AuthenticationMiddleware' must be in MIDDLEWARE in order to use the admin application.") ("admin.E408"))))
                    ((((x_contains_subclass)).apply ("django.contrib.messages.middleware.MessageMiddleware") (((xsettings).xMIDDLEWARE))).not).if
                      bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("'django.contrib.messages.middleware.MessageMiddleware' must be in MIDDLEWARE in order to use the admin application.") ("admin.E409"))))
                    ((((x_contains_subclass)).apply ("django.contrib.sessions.middleware.SessionMiddleware") (((xsettings).xMIDDLEWARE))).not).if
                      bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("'django.contrib.sessions.middleware.SessionMiddleware' must be in MIDDLEWARE in order to use the admin application.") ("Insert 'django.contrib.sessions.middleware.SessionMiddleware' before 'django.contrib.auth.middleware.AuthenticationMiddleware'.") ("admin.E410"))))
                    (((unsupported)).apply ((xerrors)))
            (((unsupported)).apply)
              seq
                xcheck.write
                  [xself xadmin_obj]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((xself).x_check_autocomplete_fields)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_raw_id_fields)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_fields)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_fieldsets)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_exclude)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_form)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_filter_vertical)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_filter_horizontal)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_radio_fields)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_prepopulated_fields)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_view_on_site_url)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_ordering)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_readonly_fields)).apply ((xadmin_obj)))))))))
                x_check_autocomplete_fields.write
                  [xself xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xisinstance)).apply (((xobj).xautocomplete_fields)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("autocomplete_fields") ((xobj)) ("admin.E036"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_autocomplete_fields_item)).apply ((xobj)) ((xfield_name)) (("autocomplete_fields[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply (((xobj).xautocomplete_fields)))))))))))
                x_check_autocomplete_fields_item.write
                  [xself xobj xfield_name xlabel]
                    memory > xfield
                    memory > xrelated_admin
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E037"))))
                          seq
                            ((((xfield).xmany_to_many).not).and ((((xisinstance)).apply ((xfield)) (((xmodels).xForeignKey))).not)).if
                              (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a foreign key or a many-to-many field") ((xlabel)) ((xobj)) ("admin.E038"))))
                            xrelated_admin.write ((((((xobj).xadmin_site).x_registry).xget)).apply ((((xfield).xremote_field).xmodel)))
                            (((unsupported)).apply ((xrelated_admin)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("An admin for model \"%s\" has to be registered to be referenced by %s.autocomplete_fields.".mod (((unsupported)).apply (((((xfield).xremote_field).xmodel).x__name__)) (((((xtype)).apply ((xobj))).x__name__))))) (((xobj).x__class__)) ("admin.E039"))))))
                              (((xrelated_admin).xsearch_fields).not).if
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("%s must define \"search_fields\", because it's referenced by %s.autocomplete_fields.".mod (((unsupported)).apply ((((xrelated_admin).x__class__).x__name__)) (((((xtype)).apply ((xobj))).x__name__))))) (((xobj).x__class__)) ("admin.E040"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_raw_id_fields.write
                  [xself xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xisinstance)).apply (((xobj).xraw_id_fields)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("raw_id_fields") ((xobj)) ("admin.E001"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_raw_id_fields_item)).apply ((xobj)) ((xfield_name)) (("raw_id_fields[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply (((xobj).xraw_id_fields)))))))))))
                x_check_raw_id_fields_item.write
                  [xself xobj xfield_name xlabel]
                    memory > xfield
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E002"))))
                          seq
                            (((xfield).xname).neq (xfield_name)).if
                              (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E002"))))
                            ((((xfield).xmany_to_many).not).and ((((xisinstance)).apply ((xfield)) (((xmodels).xForeignKey))).not)).if
                              (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a foreign key or a many-to-many field") ((xlabel)) ((xobj)) ("admin.E003"))))
                              (((unsupported)).apply ((((unsupported)).apply)))
                x_check_fields.write
                  [xself xobj]
                    memory > xfields
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xobj).xfields)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xfields)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("fields") ((xobj)) ("admin.E004"))))
                            ((xobj).xfieldsets).if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("Both 'fieldsets' and 'fields' are specified.") (((xobj).x__class__)) ("admin.E005"))))))
                        xfields.write (((xflatten)).apply (((xobj).xfields)))
                        ((((xlen)).apply ((xfields))).neq (((xlen)).apply ((((xset)).apply ((xfields)))))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("The value of 'fields' contains duplicate field(s).") (((xobj).x__class__)) ("admin.E006"))))))
                        (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_field_spec)).apply ((xobj)) ((xfield_name)) ("fields"))) ((xfield_name)) (((xobj).xfields)))))))))
                x_check_fieldsets.write
                  [xself xobj]
                    memory > xseen_fields
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xobj).xfieldsets)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xfieldsets)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("fieldsets") ((xobj)) ("admin.E007"))))
                            seq
                              xseen_fields.write (((unsupported)).apply)
                              (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_fieldsets_item)).apply ((xobj)) ((xfieldset)) (("fieldsets[%d]".mod (xindex))) ((xseen_fields)))) ((((unsupported)).apply ((xindex)) ((xfieldset)))) ((((xenumerate)).apply (((xobj).xfieldsets)))))))))))
                x_check_fieldsets_item.write
                  [xself xobj xfieldset xlabel xseen_fields]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xisinstance)).apply ((xfieldset)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ((xlabel)) ((xobj)) ("admin.E008"))))
                          ((((xlen)).apply ((xfieldset))).neq 2).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("of length 2") ((xlabel)) ((xobj)) ("admin.E009"))))
                            ((((xisinstance)).apply ((((unsupported)).apply ((xfieldset)) (1))) ((xdict))).not).if
                              (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a dictionary") (("%s[1]".mod (xlabel))) ((xobj)) ("admin.E010"))))
                              (((unsupported)).apply ("fields") ((((unsupported)).apply ((xfieldset)) (1)))).if
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s[1]' must contain the key 'fields'.".mod (xlabel))) (((xobj).x__class__)) ("admin.E011"))))))
                                ((((xisinstance)).apply ((((unsupported)).apply ((((unsupported)).apply ((xfieldset)) (1))) ("fields"))) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                                  (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") (("%s[1]['fields']".mod (xlabel))) ((xobj)) ("admin.E008"))))
                        bogusForceDataize.write ((((xseen_fields).xextend)).apply ((((xflatten)).apply ((((unsupported)).apply ((((unsupported)).apply ((xfieldset)) (1))) ("fields"))))))
                        ((((xlen)).apply ((xseen_fields))).neq (((xlen)).apply ((((xset)).apply ((xseen_fields)))))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("There are duplicate field(s) in '%s[1]'.".mod (xlabel))) (((xobj).x__class__)) ("admin.E012"))))))
                        (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_field_spec)).apply ((xobj)) ((xfieldset_fields)) (("%s[1][\"fields\"]".mod (xlabel))))) ((xfieldset_fields)) ((((unsupported)).apply ((((unsupported)).apply ((xfieldset)) (1))) ("fields"))))))))))
                x_check_field_spec.write
                  [xself xobj xfields xlabel]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xisinstance)).apply ((xfields)) ((xtuple))).if
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_field_spec_item)).apply ((xobj)) ((xfield_name)) (("%s[%d]".mod (((unsupported)).apply ((xlabel)) ((xindex))))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply ((xfields)))))))))))
                          (((unsupported)).apply (((((xself).x_check_field_spec_item)).apply ((xobj)) ((xfields)) ((xlabel)))))
                x_check_field_spec_item.write
                  [xself xobj xfield_name xlabel]
                    memory > xfield
                    seq > @
                      (((unsupported)).apply ((xfield_name)) (((xobj).xreadonly_fields))).if
                        (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply ((xfield)) (((xmodels).xManyToManyField))).and ((((((xfield).xremote_field).xthrough).x_meta).xauto_created).not)).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' cannot include the ManyToManyField '%s', because that field manually specifies a relationship model.".mod (((unsupported)).apply ((xlabel)) ((xfield_name))))) (((xobj).x__class__)) ("admin.E013"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_exclude.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xobj).xexclude)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xexclude)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("exclude") ((xobj)) ("admin.E014"))))
                            ((((xlen)).apply (((xobj).xexclude))).greater (((xlen)).apply ((((xset)).apply (((xobj).xexclude)))))).if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("The value of 'exclude' contains duplicate field(s).") (((xobj).x__class__)) ("admin.E015"))))))
                              (((unsupported)).apply ((((unsupported)).apply)))
                x_check_form.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((x_issubclass)).apply (((xobj).xform)) ((xBaseModelForm))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_inherit_from)) ("BaseModelForm") ("form") ((xobj)) ("admin.E016"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_filter_vertical.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xfilter_vertical)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("filter_vertical") ((xobj)) ("admin.E017"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_filter_item)).apply ((xobj)) ((xfield_name)) (("filter_vertical[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply (((xobj).xfilter_vertical)))))))))))
                x_check_filter_horizontal.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xfilter_horizontal)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("filter_horizontal") ((xobj)) ("admin.E018"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_filter_item)).apply ((xobj)) ((xfield_name)) (("filter_horizontal[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply (((xobj).xfilter_horizontal)))))))))))
                x_check_filter_item.write
                  [xself xobj xfield_name xlabel]
                    memory > xfield
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E019"))))
                          (((xfield).xmany_to_many).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a many-to-many field") ((xlabel)) ((xobj)) ("admin.E020"))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_radio_fields.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xradio_fields)) ((xdict))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a dictionary") ("radio_fields") ((xobj)) ("admin.E021"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply ((((((xself).x_check_radio_fields_key)).apply ((xobj)) ((xfield_name)) ("radio_fields")).add ((((xself).x_check_radio_fields_value)).apply ((xobj)) ((xval)) (("radio_fields[\"%s\"]".mod (xfield_name)))))) ((((unsupported)).apply ((xfield_name)) ((xval)))) ((((((xobj).xradio_fields).xitems)).apply)))))))))
                x_check_radio_fields_key.write
                  [xself xobj xfield_name xlabel]
                    memory > xfield
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E022"))))
                          (((((xisinstance)).apply ((xfield)) (((xmodels).xForeignKey))).or ((xfield).xchoices)).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which is not an instance of ForeignKey, and does not have a 'choices' definition.".mod (((unsupported)).apply ((xlabel)) ((xfield_name))))) (((xobj).x__class__)) ("admin.E023"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_radio_fields_value.write
                  [xself xobj xval xlabel]
                    seq > @
                      seq
                        unsupported
                        seq
                          (((unsupported)).apply)
                          (((unsupported)).apply)
                        (((unsupported)).apply ((xval)) ((((unsupported)).apply ((xHORIZONTAL)) ((xVERTICAL))))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' must be either admin.HORIZONTAL or admin.VERTICAL.".mod (xlabel))) (((xobj).x__class__)) ("admin.E024"))))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_view_on_site_url.write
                  [xself xobj]
                    seq > @
                      (((((xcallable)).apply (((xobj).xview_on_site))).not).and ((((xisinstance)).apply (((xobj).xview_on_site)) ((xbool))).not)).if
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("The value of 'view_on_site' must be a callable or a boolean value.") (((xobj).x__class__)) ("admin.E025"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_prepopulated_fields.write
                  [xself xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xisinstance)).apply (((xobj).xprepopulated_fields)) ((xdict))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a dictionary") ("prepopulated_fields") ((xobj)) ("admin.E026"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply ((((((xself).x_check_prepopulated_fields_key)).apply ((xobj)) ((xfield_name)) ("prepopulated_fields")).add ((((xself).x_check_prepopulated_fields_value)).apply ((xobj)) ((xval)) (("prepopulated_fields[\"%s\"]".mod (xfield_name)))))) ((((unsupported)).apply ((xfield_name)) ((xval)))) ((((((xobj).xprepopulated_fields).xitems)).apply)))))))))
                x_check_prepopulated_fields_key.write
                  [xself xobj xfield_name xlabel]
                    memory > xfield
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E027"))))
                          (((xisinstance)).apply ((xfield)) ((((unsupported)).apply (((xmodels).xDateTimeField)) (((xmodels).xForeignKey)) (((xmodels).xManyToManyField))))).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which must not be a DateTimeField, a ForeignKey, a OneToOneField, or a ManyToManyField.".mod (((unsupported)).apply ((xlabel)) ((xfield_name))))) (((xobj).x__class__)) ("admin.E028"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_prepopulated_fields_value.write
                  [xself xobj xval xlabel]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xisinstance)).apply ((xval)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ((xlabel)) ((xobj)) ("admin.E029"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_prepopulated_fields_value_item)).apply ((xobj)) ((xsubfield_name)) (("%s[%r]".mod (((unsupported)).apply ((xlabel)) ((xindex))))))) ((((unsupported)).apply ((xindex)) ((xsubfield_name)))) ((((xenumerate)).apply ((xval)))))))))))
                x_check_prepopulated_fields_value_item.write
                  [xself xobj xfield_name xlabel]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          bogusForceDataize.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                          (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E030"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_ordering.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xobj).xordering)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xordering)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("ordering") ((xobj)) ("admin.E031"))))
                            (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_ordering_item)).apply ((xobj)) ((xfield_name)) (("ordering[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply (((xobj).xordering)))))))))))
                x_check_ordering_item.write
                  [xself xobj xfield_name xlabel]
                    seq > @
                      seq
                        unsupported
                        (((xisinstance)).apply ((xfield_name)) ((((unsupported)).apply ((xCombinable)) (((xmodels).xOrderBy))))).if
                          seq
                            ((((xisinstance)).apply ((xfield_name)) (((xmodels).xOrderBy))).not).if
                              xfield_name.write ((((xfield_name).xasc)).apply)
                            (((xisinstance)).apply (((xfield_name).xexpression)) (((xmodels).xF))).if
                              xfield_name.write (((xfield_name).xexpression).xname)
                              (((unsupported)).apply ((((unsupported)).apply)))
                        (((xfield_name).eq "?").and ((((xlen)).apply (((xobj).xordering))).neq 1)).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("The value of 'ordering' has the random ordering marker '?', but contains other fields as well.") ("Either remove the \"?\", or remove the other fields.") (((xobj).x__class__)) ("admin.E032"))))))
                          ((xfield_name).eq "?").if
                            (((unsupported)).apply ((((unsupported)).apply)))
                            (((unsupported)).apply ((xLOOKUP_SEP)) ((xfield_name))).if
                              (((unsupported)).apply ((((unsupported)).apply)))
                              seq
                                ((((xfield_name).xstartswith)).apply ("-")).if
                                  xfield_name.write (((unsupported)).apply ((xfield_name)) ((((unsupported)).apply (1))))
                                ((xfield_name).eq "pk").if
                                  (((unsupported)).apply ((((unsupported)).apply)))
                                (((unsupported)).apply ((xFieldDoesNotExist)))
                                  bogusForceDataize.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                                  (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E033"))))
                                  (((unsupported)).apply ((((unsupported)).apply)))
                x_check_readonly_fields.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((xobj).xreadonly_fields).eq (((unsupported)).apply)).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xreadonly_fields)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("readonly_fields") ((xobj)) ("admin.E034"))))
                            (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_readonly_fields_item)).apply ((xobj)) ((xfield_name)) (("readonly_fields[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply (((xobj).xreadonly_fields)))))))))))
                x_check_readonly_fields_item.write
                  [xself xobj xfield_name xlabel]
                    seq > @
                      (((xcallable)).apply ((xfield_name))).if
                        (((unsupported)).apply ((((unsupported)).apply)))
                        (((xhasattr)).apply ((xobj)) ((xfield_name))).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          (((xhasattr)).apply (((xobj).xmodel)) ((xfield_name))).if
                            (((unsupported)).apply ((((unsupported)).apply)))
                            (((unsupported)).apply ((xFieldDoesNotExist)))
                              bogusForceDataize.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' is not a callable, an attribute of '%s', or an attribute of '%s'.".mod (((unsupported)).apply ((xlabel)) ((((xobj).x__class__).x__name__)) (((((xobj).xmodel).x_meta).xlabel))))) (((xobj).x__class__)) ("admin.E035"))))))
                              (((unsupported)).apply ((((unsupported)).apply)))
            (((unsupported)).apply ((xBaseModelAdminChecks)))
              seq
                xcheck.write
                  [xself xadmin_obj]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_save_as)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_save_on_top)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_inlines)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_list_display)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_list_display_links)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_list_filter)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_list_select_related)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_list_per_page)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_list_max_show_all)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_list_editable)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_search_fields)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_date_hierarchy)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_action_permission_methods)).apply ((xadmin_obj)))))) ((((unsupported)).apply (((((xself).x_check_actions_uniqueness)).apply ((xadmin_obj)))))))))
                x_check_save_as.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xsave_as)) ((xbool))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a boolean") ("save_as") ((xobj)) ("admin.E101"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_save_on_top.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xsave_on_top)) ((xbool))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a boolean") ("save_on_top") ((xobj)) ("admin.E102"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_inlines.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xinlines)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("inlines") ((xobj)) ("admin.E103"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_inlines_item)).apply ((xobj)) ((xitem)) (("inlines[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xitem)))) ((((xenumerate)).apply (((xobj).xinlines)))))))))))
                x_check_inlines_item.write
                  [xself xobj xinline xlabel]
                    memory > xinline_label
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((xAttributeError)))
                          xinline_label.write ((((xinline).x__module__).add ".").add ((xinline).x__name__))
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' must inherit from 'InlineModelAdmin'.".mod (xobj))) (((xobj).x__class__)) ("admin.E104"))))))
                        (((unsupported)).apply)
                        ((((x_issubclass)).apply ((xinline)) ((xInlineModelAdmin))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' must inherit from 'InlineModelAdmin'.".mod (xinline_label))) (((xobj).x__class__)) ("admin.E104"))))))
                          (((xinline).xmodel).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s' must have a 'model' attribute.".mod (xinline_label))) (((xobj).x__class__)) ("admin.E105"))))))
                            ((((x_issubclass)).apply (((xinline).xmodel)) (((xmodels).xModel))).not).if
                              (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a Model") (("%s.model".mod (xinline_label))) ((xobj)) ("admin.E106"))))
                              (((unsupported)).apply (((((((xinline)).apply (((xobj).xmodel)) (((xobj).xadmin_site))).xcheck)).apply)))
                x_check_list_display.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xlist_display)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("list_display") ((xobj)) ("admin.E107"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_list_display_item)).apply ((xobj)) ((xitem)) (("list_display[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xitem)))) ((((xenumerate)).apply (((xobj).xlist_display)))))))))))
                x_check_list_display_item.write
                  [xself xobj xitem xlabel]
                    memory > xfield
                    seq > @
                      seq
                        (((xcallable)).apply ((xitem))).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          (((xhasattr)).apply ((xobj)) ((xitem))).if
                            (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply ((xFieldDoesNotExist)))
                          xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xitem)))
                          (((unsupported)).apply ((xAttributeError)))
                            xfield.write (((xgetattr)).apply (((xobj).xmodel)) ((xitem)))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which is not a callable, an attribute of '%s', or an attribute or method on '%s'.".mod (((unsupported)).apply ((xlabel)) ((xitem)) ((((xobj).x__class__).x__name__)) (((((xobj).xmodel).x_meta).xlabel))))) (((xobj).x__class__)) ("admin.E108"))))))
                        (((xisinstance)).apply ((xfield)) (((xmodels).xManyToManyField))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' must not be a ManyToManyField.".mod (xlabel))) (((xobj).x__class__)) ("admin.E109"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_list_display_links.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xobj).xlist_display_links)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xlist_display_links)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list, a tuple, or None") ("list_display_links") ((xobj)) ("admin.E110"))))
                            (((unsupported)).apply ((((xobj).xget_list_display).x__func__)) (((xModelAdmin).xget_list_display))).if
                              (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_list_display_links_item)).apply ((xobj)) ((xfield_name)) (("list_display_links[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xfield_name)))) ((((xenumerate)).apply (((xobj).xlist_display_links)))))))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_list_display_links_item.write
                  [xself xobj xfield_name xlabel]
                    seq > @
                      (((unsupported)).apply ((xfield_name)) (((xobj).xlist_display))).if
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which is not defined in 'list_display'.".mod (((unsupported)).apply ((xlabel)) ((xfield_name))))) (((xobj).x__class__)) ("admin.E111"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_list_filter.write
                  [xself xobj]
                    seq > @
                      ((((xisinstance)).apply (((xobj).xlist_filter)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                        (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("list_filter") ((xobj)) ("admin.E112"))))
                        (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_list_filter_item)).apply ((xobj)) ((xitem)) (("list_filter[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xitem)))) ((((xenumerate)).apply (((xobj).xlist_filter)))))))))))
                x_check_list_filter_item.write
                  [xself xobj xitem xlabel]
                    memory > xfield
                    seq > @
                      seq
                        (((unsupported)).apply)
                        seq
                          (((unsupported)).apply)
                          (((unsupported)).apply)
                        ((((xcallable)).apply ((xitem))).and ((((xisinstance)).apply ((xitem)) (((xmodels).xField))).not)).if
                          ((((x_issubclass)).apply ((xitem)) ((xListFilter))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_inherit_from)) ("ListFilter") ((xlabel)) ((xobj)) ("admin.E113"))))
                            (((xissubclass)).apply ((xitem)) ((xFieldListFilter))).if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' must not inherit from 'FieldListFilter'.".mod (xlabel))) (((xobj).x__class__)) ("admin.E114"))))))
                              (((unsupported)).apply ((((unsupported)).apply)))
                          (((xisinstance)).apply ((xitem)) ((((unsupported)).apply ((xtuple)) ((xlist))))).if
                            seq
                              (((unsupported)).apply ((((unsupported)).apply ((xfield)) ((xlist_filter_class)))) ((xitem)))
                              ((((x_issubclass)).apply ((xlist_filter_class)) ((xFieldListFilter))).not).if
                                (((unsupported)).apply ((((unsupported)).apply ((xmust_inherit_from)) ("FieldListFilter") (("%s[1]".mod (xlabel))) ((xobj)) ("admin.E115"))))
                                (((unsupported)).apply ((((unsupported)).apply)))
                            seq
                              xfield.write (xitem)
                              (((unsupported)).apply ((((unsupported)).apply ((xNotRelationField)) ((xFieldDoesNotExist)))))
                                bogusForceDataize.write (((xget_fields_from_path)).apply (((xobj).xmodel)) ((xfield)))
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which does not refer to a Field.".mod (((unsupported)).apply ((xlabel)) ((xfield))))) (((xobj).x__class__)) ("admin.E116"))))))
                                (((unsupported)).apply ((((unsupported)).apply)))
                x_check_list_select_related.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xlist_select_related)) ((((unsupported)).apply ((xbool)) ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a boolean, tuple or list") ("list_select_related") ((xobj)) ("admin.E117"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_list_per_page.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xlist_per_page)) ((xint))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("an integer") ("list_per_page") ((xobj)) ("admin.E118"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_list_max_show_all.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xlist_max_show_all)) ((xint))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("an integer") ("list_max_show_all") ((xobj)) ("admin.E119"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_list_editable.write
                  [xself xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xisinstance)).apply (((xobj).xlist_editable)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("list_editable") ((xobj)) ("admin.E120"))))
                          (((unsupported)).apply ((((xlist)).apply (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply (((((xself).x_check_list_editable_item)).apply ((xobj)) ((xitem)) (("list_editable[%d]".mod (xindex))))) ((((unsupported)).apply ((xindex)) ((xitem)))) ((((xenumerate)).apply (((xobj).xlist_editable)))))))))))
                x_check_list_editable_item.write
                  [xself xobj xfield_name xlabel]
                    memory > xfield
                    seq > @
                      (((unsupported)).apply ((xFieldDoesNotExist)))
                        xfield.write ((((((xobj).xmodel).x_meta).xget_field)).apply ((xfield_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xrefer_to_missing_field)) ((xfield_name)) ((xlabel)) ((xobj)) ("admin.E121"))))
                        (((unsupported)).apply ((xfield_name)) (((xobj).xlist_display))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which is not contained in 'list_display'.".mod (((unsupported)).apply ((xlabel)) ((xfield_name))))) (((xobj).x__class__)) ("admin.E122"))))))
                          (((xobj).xlist_display_links).and (((unsupported)).apply ((xfield_name)) (((xobj).xlist_display_links)))).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' cannot be in both 'list_editable' and 'list_display_links'.".mod (xfield_name))) (((xobj).x__class__)) ("admin.E123"))))))
                            ((((((unsupported)).apply (((xobj).xlist_display)) (0)).eq (xfield_name)).and (((xobj).xlist_display_links).not)).and (((unsupported)).apply (((xobj).xlist_display_links)) ("None: is there a None literal in the EO language?"))).if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to the first field in 'list_display' ('%s'), which cannot be used unless 'list_display_links' is set.".mod (((unsupported)).apply ((xlabel)) ((((unsupported)).apply (((xobj).xlist_display)) (0)))))) (((xobj).x__class__)) ("admin.E124"))))))
                              (((xfield).xeditable).not).if
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which is not editable through the admin.".mod (((unsupported)).apply ((xlabel)) ((xfield_name))))) (((xobj).x__class__)) ("admin.E125"))))))
                                (((unsupported)).apply ((((unsupported)).apply)))
                x_check_search_fields.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xsearch_fields)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a list or tuple") ("search_fields") ((xobj)) ("admin.E126"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_date_hierarchy.write
                  [xself xobj]
                    memory > xfield
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xobj).xdate_hierarchy)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          (((unsupported)).apply ((((unsupported)).apply ((xNotRelationField)) ((xFieldDoesNotExist)))))
                            xfield.write (((unsupported)).apply ((((xget_fields_from_path)).apply (((xobj).xmodel)) (((xobj).xdate_hierarchy)))) ((1.neg)))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of 'date_hierarchy' refers to '%s', which does not refer to a Field.".mod ((xobj).xdate_hierarchy))) (((xobj).x__class__)) ("admin.E127"))))))
                            ((((xisinstance)).apply ((xfield)) ((((unsupported)).apply (((xmodels).xDateField)) (((xmodels).xDateTimeField))))).not).if
                              (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("a DateField or DateTimeField") ("date_hierarchy") ((xobj)) ("admin.E128"))))
                              (((unsupported)).apply ((((unsupported)).apply)))
                x_check_action_permission_methods.write
                  [xself xobj]
                    memory > xerrors
                    memory > xactions
                    memory > xmethod_name
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xactions.write ((((xobj).x_get_base_actions)).apply)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xfunc)) ((xname)) ((x_)))) ((xactions)))
                          seq
                            ((((xhasattr)).apply ((xfunc)) ("allowed_permissions")).not).if
                              (((unsupported)).apply)
                            (((unsupported)).apply ((xpermission)) (((xfunc).xallowed_permissions)))
                              seq
                                xmethod_name.write ("has_%s_permission".mod (xpermission))
                                ((((xhasattr)).apply ((xobj)) ((xmethod_name))).not).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("%s must define a %s() method for the %s action.".mod (((unsupported)).apply ((((xobj).x__class__).x__name__)) ((xmethod_name)) (((xfunc).x__name__))))) (((xobj).x__class__)) ("admin.E129"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_actions_uniqueness.write
                  [xself xobj]
                    memory > xerrors
                    memory > xnames
                    seq > @
                      seq
                        unsupported
                        xerrors.write (((unsupported)).apply)
                        xnames.write ((((xcollections).xCounter)).apply ((((unsupported)).apply ((xname)) ((((unsupported)).apply ((x_)) ((xname)) ((x_)))) (((((xobj).x_get_base_actions)).apply)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xcount)))) (((((xnames).xitems)).apply)))
                          ((xcount).greater 1).if
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("__name__ attributes of actions defined in %s must be unique. Name %r is not unique.".mod (((unsupported)).apply ((((xobj).x__class__).x__name__)) ((xname))))) (((xobj).x__class__)) ("admin.E130"))))
                        (((unsupported)).apply ((xerrors)))
            (((unsupported)).apply ((xBaseModelAdminChecks)))
              seq
                xcheck.write
                  [xself xinline_obj]
                    memory > xparent_model
                    seq > @
                      (((unsupported)).apply)
                        xparent_model.write ((xinline_obj).xparent_model)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((xinline_obj)))))) ((((unsupported)).apply (((((xself).x_check_relation)).apply ((xinline_obj)) ((xparent_model)))))) ((((unsupported)).apply (((((xself).x_check_exclude_of_parent_model)).apply ((xinline_obj)) ((xparent_model)))))) ((((unsupported)).apply (((((xself).x_check_extra)).apply ((xinline_obj)))))) ((((unsupported)).apply (((((xself).x_check_max_num)).apply ((xinline_obj)))))) ((((unsupported)).apply (((((xself).x_check_min_num)).apply ((xinline_obj)))))) ((((unsupported)).apply (((((xself).x_check_formset)).apply ((xinline_obj)))))))))
                x_check_exclude_of_parent_model.write
                  [xself xobj xparent_model]
                    memory > xerrors
                    memory > xfk
                    seq > @
                      seq
                        xerrors.write ((((((xsuper)).apply).x_check_exclude)).apply ((xobj)))
                        (xerrors).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        ((((xself).x_check_relation)).apply ((xobj)) ((xparent_model))).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply (((xobj).xexclude)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xfk.write (((unsupported)).apply ((x_get_foreign_key)) ((xparent_model)) (((xobj).xmodel)) (((xobj).xfk_name)))
                        (((unsupported)).apply (((xfk).xname)) (((xobj).xexclude))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("Cannot exclude the field '%s', because it is the foreign key to the parent model '%s'.".mod (((unsupported)).apply (((xfk).xname)) ((((xparent_model).x_meta).xlabel))))) (((xobj).x__class__)) ("admin.E201"))))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_relation.write
                  [xself xobj xparent_model]
                    seq > @
                      (((unsupported)).apply ((xValueError)))
                        (((unsupported)).apply ((x_get_foreign_key)) ((xparent_model)) (((xobj).xmodel)) (((xobj).xfk_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ((((unsupported)).apply (((xe).xargs)) (0))) (((xobj).x__class__)) ("admin.E202"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_extra.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((xisinstance)).apply (((xobj).xextra)) ((xint))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("an integer") ("extra") ((xobj)) ("admin.E203"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
                x_check_max_num.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xobj).xmax_num)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xmax_num)) ((xint))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("an integer") ("max_num") ((xobj)) ("admin.E204"))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_min_num.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xobj).xmin_num)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                          ((((xisinstance)).apply (((xobj).xmin_num)) ((xint))).not).if
                            (((unsupported)).apply ((((unsupported)).apply ((xmust_be)) ("an integer") ("min_num") ((xobj)) ("admin.E205"))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_formset.write
                  [xself xobj]
                    seq > @
                      seq
                        unsupported
                        ((((x_issubclass)).apply (((xobj).xformset)) ((xBaseModelFormSet))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xmust_inherit_from)) ("BaseModelFormSet") ("formset") ((xobj)) ("admin.E206"))))
                          (((unsupported)).apply ((((unsupported)).apply)))
            xmust_be.write
              [xtype xoption xobj xid]
                seq > @
                  (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' must be %s.".mod (((unsupported)).apply ((xoption)) ((xtype))))) (((xobj).x__class__)) ((xid)))))))
            xmust_inherit_from.write
              [xparent xoption xobj xid]
                seq > @
                  (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' must inherit from '%s'.".mod (((unsupported)).apply ((xoption)) ((xparent))))) (((xobj).x__class__)) ((xid)))))))
            xrefer_to_missing_field.write
              [xfield xoption xobj xid]
                seq > @
                  (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The value of '%s' refers to '%s', which is not a field of '%s'.".mod (((unsupported)).apply ((xoption)) ((xfield)) (((((xobj).xmodel).x_meta).xlabel))))) (((xobj).x__class__)) ((xid)))))))