memory > xreplaced
memory > xstr
memory > xKeyError
memory > xnames
memory > xsorted
memory > xn
memory > xapp
memory > xDEFAULT_DB_ALIAS
memory > xmodel_list
memory > xmessage
memory > xlist
memory > xmigration_obj
memory > xemit_pre_migrate_signal
memory > ximport_module
memory > xapps
memory > xAmbiguityError
memory > xrouter
memory > xTruncator
memory > xProjectState
memory > xerr
memory > xany
memory > xBaseCommand
memory > xset
memory > xrepr
memory > xconnections
memory > xhasattr
memory > xmodule_has_submodule
memory > xtime
memory > xcursor
memory > xModelState
memory > xbackwards
memory > xsys
memory > xLookupError
memory > xeditor
memory > xis_error
memory > xMigrationAutodetector
memory > xmigration_key
memory > xoperation
memory > xapp_config
memory > xname
memory > xMigrationExecutor
memory > xfilter
memory > xmodel_state
memory > xoptions
memory > xmodel
memory > xCommandError
memory > xapp_name
memory > xemit_post_migrate_signal
memory > xkey
memory > xa
[] > migrate
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xmigration_progress_callback
        memory > xdescribe_operation
        memory > xhandle
        memory > xadd_arguments
        memory > xhelp
        memory > xsync_apps
        memory > xrequires_system_checks
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply ((xBaseCommand)))
              seq
                xhelp.write "Updates database schema. Manages both apps with migrations and those without."
                xrequires_system_checks.write (((unsupported)).apply)
                xadd_arguments.write
                  [xself xparser]
                    seq > @
                      seq
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--skip-checks") ("store_true") ("Skip system checks."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("app_label") ("?") ("App label of an application to synchronize the state."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("migration_name") ("?") ("Database state will be brought to the state after that migration. Use the name \"zero\" to unapply all migrations."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--noinput") ("--no-input") ("store_false") ("interactive") ("Tells Django to NOT prompt the user for input of any kind."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--database") ((xDEFAULT_DB_ALIAS)) ("Nominates a database to synchronize. Defaults to the \"default\" database."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--fake") ("store_true") ("Mark migrations as run without actually running them."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--fake-initial") ("store_true") ("Detect if tables already exist and fake-apply initial migrations if so. Make sure that the current database schema matches your initial migration before using this flag. Django will only check for an existing table name."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--plan") ("store_true") ("Shows a list of the migration actions that will be performed."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--run-syncdb") ("store_true") ("Creates tables for apps without migrations."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--check") ("store_true") ("check_unapplied") ("Exits with a non-zero status if unapplied migrations exist."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--prune") ("store_true") ("prune") ("Delete nonexistent migrations from the django_migrations table."))
                xhandle.write
                  [xself]
                    memory > xstyle
                    memory > xtargets
                    memory > xfake_initial
                    memory > xexecutor
                    memory > xexit_dry
                    memory > xsquashed_migrations_with_deleted_replaced_migrations
                    memory > xchanges
                    memory > xtarget
                    memory > xconflicts
                    memory > xdatabase
                    memory > xrun_syncdb
                    memory > xpost_migrate_apps
                    memory > xautodetector
                    memory > xtarget_app_labels_only
                    memory > xname_str
                    memory > xplan
                    memory > xapp_label
                    memory > xmodel_keys
                    memory > xto_prune
                    memory > xconnection
                    memory > xpost_migrate_state
                    memory > xmigration
                    memory > xincomplete_migration
                    memory > xfake
                    memory > xmodel_key
                    memory > xmigration_name
                    memory > xpre_migrate_apps
                    memory > xpre_migrate_state
                    seq > @
                      (((unsupported)).apply)
                        xdatabase.write (((unsupported)).apply ((xoptions)) ("database"))
                        ((((unsupported)).apply ((xoptions)) ("skip_checks")).not).if
                          (((unsupported)).apply (((xself).xcheck)) ((((unsupported)).apply ((xdatabase)))))
                        (((unsupported)).apply (((xself).xverbosity)) ((((unsupported)).apply ((xoptions)) ("verbosity"))))
                        (((unsupported)).apply (((xself).xinteractive)) ((((unsupported)).apply ((xoptions)) ("interactive"))))
                        (((unsupported)).apply ((xapp_config)) (((xapps).xget_app_configs)))
                          (((xmodule_has_submodule)).apply (((xapp_config).xmodule)) ("management")).if
                            bogusForceDataize.write (((ximport_module)).apply (".management") (((xapp_config).xname)))
                        xconnection.write (((unsupported)).apply ((xconnections)) ((xdatabase)))
                        unsupported
                        xexecutor.write (((xMigrationExecutor)).apply ((xconnection)) (((xself).xmigration_progress_callback)))
                        bogusForceDataize.write (((((xexecutor).xloader).xcheck_consistent_history)).apply ((xconnection)))
                        xconflicts.write (((xexecutor).xloader).xdetect_conflicts)
                        (xconflicts).if
                          seq
                            xname_str.write ((("; ".xjoin)).apply ((((unsupported)).apply (("%s in %s".mod (((unsupported)).apply ((((", ".xjoin)).apply ((xnames)))) ((xapp))))) ((((unsupported)).apply ((xapp)) ((xnames)))) (((xconflicts).xitems)))))
                            (((unsupported)).apply ((((xCommandError)).apply (("Conflicting migrations detected; multiple leaf nodes in the migration graph: (%s).nTo fix them run 'python manage.py makemigrations --merge'".mod (xname_str))))))
                        xrun_syncdb.write (((unsupported)).apply ((xoptions)) ("run_syncdb"))
                        xtarget_app_labels_only.write TRUE
                        (((unsupported)).apply ((xoptions)) ("app_label")).if
                          seq
                            xapp_label.write (((unsupported)).apply ((xoptions)) ("app_label"))
                            (((unsupported)).apply ((xLookupError)))
                              bogusForceDataize.write ((((xapps).xget_app_config)).apply ((xapp_label)))
                              (((unsupported)).apply ((((xCommandError)).apply ((((xstr)).apply ((xerr)))))))
                            (xrun_syncdb).if
                              (((unsupported)).apply ((xapp_label)) ((((xexecutor).xloader).xmigrated_apps))).if
                                (((unsupported)).apply ((((xCommandError)).apply (("Can't use run_syncdb with app '%s' as it has migrations.".mod (xapp_label))))))
                              (((unsupported)).apply ((xapp_label)) ((((xexecutor).xloader).xmigrated_apps))).if
                                (((unsupported)).apply ((((xCommandError)).apply (("App '%s' does not have migrations.".mod (xapp_label))))))
                        ((((unsupported)).apply ((xoptions)) ("app_label")).and (((unsupported)).apply ((xoptions)) ("migration_name"))).if
                          seq
                            xmigration_name.write (((unsupported)).apply ((xoptions)) ("migration_name"))
                            ((xmigration_name).eq "zero").if
                              xtargets.write (((unsupported)).apply ((((unsupported)).apply ((xapp_label)) ("None: is there a None literal in the EO language?"))))
                              seq
                                (((unsupported)).apply ((xAmbiguityError)) ((xKeyError)))
                                  xmigration.write (((((xexecutor).xloader).xget_migration_by_prefix)).apply ((xapp_label)) ((xmigration_name)))
                                  (((unsupported)).apply ((((xCommandError)).apply (("More than one migration matches '%s' in app '%s'. Please be more specific.".mod (((unsupported)).apply ((xmigration_name)) ((xapp_label))))))))
                                  (((unsupported)).apply ((((xCommandError)).apply (("Cannot find a migration matching '%s' from app '%s'.".mod (((unsupported)).apply ((xmigration_name)) ((xapp_label))))))))
                                xtarget.write (((unsupported)).apply ((xapp_label)) (((xmigration).xname)))
                                ((((unsupported)).apply ((xtarget)) (((((xexecutor).xloader).xgraph).xnodes))).and (((unsupported)).apply ((xtarget)) ((((xexecutor).xloader).xreplacements)))).if
                                  seq
                                    xincomplete_migration.write (((unsupported)).apply ((((xexecutor).xloader).xreplacements)) ((xtarget)))
                                    xtarget.write (((unsupported)).apply (((xincomplete_migration).xreplaces)) ((1.neg)))
                                xtargets.write (((unsupported)).apply ((xtarget)))
                            xtarget_app_labels_only.write FALSE
                          (((unsupported)).apply ((xoptions)) ("app_label")).if
                            xtargets.write (((unsupported)).apply ((xkey)) ((xkey)) (((((xexecutor).xloader).xgraph).xleaf_nodes)) (((((unsupported)).apply ((xkey)) (0)).eq (xapp_label))))
                            xtargets.write ((((xexecutor).xloader).xgraph).xleaf_nodes)
                        (((unsupported)).apply ((xoptions)) ("prune")).if
                          seq
                            ((((unsupported)).apply ((xoptions)) ("app_label")).not).if
                              (((unsupported)).apply ((((xCommandError)).apply ("Migrations can be pruned only when an app is specified."))))
                            (((xself).xverbosity).greater 0).if
                              bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("Pruning migrations:") ((((xself).xstyle).xMIGRATE_HEADING)))
                            xto_prune.write ((((xset)).apply ((((xexecutor).xloader).xapplied_migrations))).sub (((xset)).apply ((((xexecutor).xloader).xdisk_migrations))))
                            xsquashed_migrations_with_deleted_replaced_migrations.write (((unsupported)).apply ((xmigration_key)) ((((unsupported)).apply ((xmigration_key)) ((xmigration_obj)))) (((((xexecutor).xloader).xreplacements).xitems)) ((((xany)).apply ((((unsupported)).apply ((((unsupported)).apply ((xreplaced)) ((xto_prune)))) ((xreplaced)) (((xmigration_obj).xreplaces)))))))
                            (xsquashed_migrations_with_deleted_replaced_migrations).if
                              seq
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xNOTICE)).apply ("  Cannot use --prune because the following squashed migrations have their 'replaces' attributes and may not be recorded as applied:"))))
                                (((unsupported)).apply ((xmigration)) ((xsquashed_migrations_with_deleted_replaced_migrations)))
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply ((xapp)) ((xname)))) ((xmigration)))
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("    {app}.{name}"))
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xNOTICE)).apply ("  Re-run 'manage.py migrate' if they are not marked as applied, and remove 'replaces' attributes in their Migration classes."))))
                              seq
                                xto_prune.write (((xsorted)).apply ((((unsupported)).apply ((xmigration)) ((xmigration)) ((xto_prune)) (((((unsupported)).apply ((xmigration)) (0)).eq (xapp_label))))))
                                (xto_prune).if
                                  (((unsupported)).apply ((xmigration)) ((xto_prune)))
                                    seq
                                      (((unsupported)).apply ((((unsupported)).apply ((xapp)) ((xname)))) ((xmigration)))
                                      (((xself).xverbosity).greater 0).if
                                        (((unsupported)).apply ((((xself).xstdout).xwrite)) ((((((xself).xstyle).xMIGRATE_LABEL)).apply ("  Pruning {app}.{name}"))) (""))
                                      bogusForceDataize.write (((((xexecutor).xrecorder).xrecord_unapplied)).apply ((xapp)) ((xname)))
                                      (((xself).xverbosity).greater 0).if
                                        bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xSUCCESS)).apply (" OK"))))
                                  (((xself).xverbosity).greater 0).if
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("  No migrations to prune."))
                        xplan.write ((((xexecutor).xmigration_plan)).apply ((xtargets)))
                        xexit_dry.write ((xplan).and (((unsupported)).apply ((xoptions)) ("check_unapplied")))
                        (((unsupported)).apply ((xoptions)) ("plan")).if
                          seq
                            bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("Planned operations:") ((((xself).xstyle).xMIGRATE_LABEL)))
                            ((xplan).not).if
                              bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("  No planned migration operations."))
                            (((unsupported)).apply ((((unsupported)).apply ((xmigration)) ((xbackwards)))) ((xplan)))
                              seq
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((xstr)).apply ((xmigration)))) ((((xself).xstyle).xMIGRATE_HEADING)))
                                (((unsupported)).apply ((xoperation)) (((xmigration).xoperations)))
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply ((xmessage)) ((xis_error)))) (((((xself).xdescribe_operation)).apply ((xoperation)) ((xbackwards)))))
                                    xstyle.write ((xis_error).if (((xself).xstyle).xWARNING) "None: is there a None literal in the EO language?")
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("    ".add (xmessage))) ((xstyle)))
                            (xexit_dry).if
                              bogusForceDataize.write ((((xsys).xexit)).apply (1))
                            (((unsupported)).apply)
                        (xexit_dry).if
                          bogusForceDataize.write ((((xsys).xexit)).apply (1))
                        (((unsupported)).apply ((xoptions)) ("prune")).if
                          (((unsupported)).apply)
                        xrun_syncdb.write ((((unsupported)).apply ((xoptions)) ("run_syncdb")).and (((xexecutor).xloader).xunmigrated_apps))
                        (((xself).xverbosity).geq 1).if
                          seq
                            bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xMIGRATE_HEADING)).apply ("Operations to perform:"))))
                            (xrun_syncdb).if
                              (((unsupported)).apply ((xoptions)) ("app_label")).if
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xMIGRATE_LABEL)).apply (("  Synchronize unmigrated app: %s".mod (xapp_label))))))
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (((((((xself).xstyle).xMIGRATE_LABEL)).apply ("  Synchronize unmigrated apps: ")).add (((", ".xjoin)).apply ((((xsorted)).apply ((((xexecutor).xloader).xunmigrated_apps))))))))
                            (xtarget_app_labels_only).if
                              bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (((((((xself).xstyle).xMIGRATE_LABEL)).apply ("  Apply all migrations: ")).add ((((", ".xjoin)).apply ((((xsorted)).apply ((((unsupported)).apply ((xa)) ((((unsupported)).apply ((xa)) ((xn)))) ((xtargets))))))).or "(none)"))))
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xtargets)) (0))) (1))) ("None: is there a None literal in the EO language?")).if
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (((((((xself).xstyle).xMIGRATE_LABEL)).apply ("  Unapply all migrations: ")).add (((xstr)).apply ((((unsupported)).apply ((((unsupported)).apply ((xtargets)) (0))) (0)))))))
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (((((((xself).xstyle).xMIGRATE_LABEL)).apply ("  Target specific migration: ")).add ("%s, from %s".mod (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xtargets)) (0))) (1))) ((((unsupported)).apply ((((unsupported)).apply ((xtargets)) (0))) (0))))))))
                        xpre_migrate_state.write (((unsupported)).apply (((xexecutor).x_create_project_state)) (TRUE))
                        xpre_migrate_apps.write ((xpre_migrate_state).xapps)
                        (((unsupported)).apply ((xemit_pre_migrate_signal)) (((xself).xverbosity)) (((xself).xinteractive)) (((xconnection).xalias)) (((xself).xstdout)) ((xpre_migrate_apps)) ((xplan)))
                        (xrun_syncdb).if
                          seq
                            (((xself).xverbosity).geq 1).if
                              bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xMIGRATE_HEADING)).apply ("Synchronizing apps without migrations:"))))
                            (((unsupported)).apply ((xoptions)) ("app_label")).if
                              bogusForceDataize.write ((((xself).xsync_apps)).apply ((xconnection)) ((((unsupported)).apply ((xapp_label)))))
                              bogusForceDataize.write ((((xself).xsync_apps)).apply ((xconnection)) ((((xexecutor).xloader).xunmigrated_apps)))
                        (((xself).xverbosity).geq 1).if
                          bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xMIGRATE_HEADING)).apply ("Running migrations:"))))
                        ((xplan).not).if
                          seq
                            (((xself).xverbosity).geq 1).if
                              seq
                                bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("  No migrations to apply."))
                                xautodetector.write (((xMigrationAutodetector)).apply ((((xexecutor).xloader).xproject_state)) (((((xProjectState).xfrom_apps)).apply ((xapps)))))
                                xchanges.write (((unsupported)).apply (((xautodetector).xchanges)) ((((xexecutor).xloader).xgraph)))
                                (xchanges).if
                                  seq
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xNOTICE)).apply (("  Your models in app(s): %s have changes that are not yet reflected in a migration, and so won't be applied.".mod (((", ".xjoin)).apply ((((unsupported)).apply ((((xrepr)).apply ((xapp)))) ((xapp)) ((((xsorted)).apply ((xchanges))))))))))))
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xNOTICE)).apply ("  Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them."))))
                            xfake.write FALSE
                            xfake_initial.write FALSE
                          seq
                            xfake.write (((unsupported)).apply ((xoptions)) ("fake"))
                            xfake_initial.write (((unsupported)).apply ((xoptions)) ("fake_initial"))
                        xpost_migrate_state.write (((unsupported)).apply (((xexecutor).xmigrate)) ((xtargets)) ((xplan)) (((xpre_migrate_state).xclone)) ((xfake)) ((xfake_initial)))
                        unsupported
                        xpost_migrate_apps.write ((xpost_migrate_state).xapps)
                        (((unsupported)).apply (((xpost_migrate_apps).xbulk_update)))
                          seq
                            xmodel_keys.write (((unsupported)).apply)
                            (((unsupported)).apply ((xmodel_state)) (((xpost_migrate_apps).xreal_models)))
                              seq
                                xmodel_key.write (((unsupported)).apply (((xmodel_state).xapp_label)) (((xmodel_state).xname_lower)))
                                bogusForceDataize.write ((((xmodel_keys).xappend)).apply ((xmodel_key)))
                                bogusForceDataize.write ((((xpost_migrate_apps).xunregister_model)).apply ((((unsupported)).apply ((xmodel_key)))))
                        bogusForceDataize.write ((((xpost_migrate_apps).xrender_multiple)).apply ((((unsupported)).apply (((((xModelState).xfrom_model)).apply (((((xapps).xget_model)).apply ((((unsupported)).apply ((xmodel)))))))) ((xmodel)) ((xmodel_keys)))))
                        (((unsupported)).apply ((xemit_post_migrate_signal)) (((xself).xverbosity)) (((xself).xinteractive)) (((xconnection).xalias)) (((xself).xstdout)) ((xpost_migrate_apps)) ((xplan)))
                xmigration_progress_callback.write
                  [xself xaction xmigration xfake]
                    memory > xelapsed
                    memory > xcompute_time
                    seq > @
                      (((unsupported)).apply)
                        (((xself).xverbosity).geq 1).if
                          seq
                            xcompute_time.write (((xself).xverbosity).greater 1)
                            ((xaction).eq "apply_start").if
                              seq
                                (xcompute_time).if
                                  (((unsupported)).apply (((xself).xstart)) (((xtime).xmonotonic)))
                                (((unsupported)).apply ((((xself).xstdout).xwrite)) (("  Applying %s...".mod (xmigration))) (""))
                                unsupported
                              ((xaction).eq "apply_success").if
                                seq
                                  xelapsed.write ((xcompute_time).if (" (%.3fs)".mod (((xtime).xmonotonic).sub ((xself).xstart))) "")
                                  (xfake).if
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xSUCCESS)).apply ((" FAKED".add (xelapsed))))))
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xSUCCESS)).apply ((" OK".add (xelapsed))))))
                                ((xaction).eq "unapply_start").if
                                  seq
                                    (xcompute_time).if
                                      (((unsupported)).apply (((xself).xstart)) (((xtime).xmonotonic)))
                                    (((unsupported)).apply ((((xself).xstdout).xwrite)) (("  Unapplying %s...".mod (xmigration))) (""))
                                    unsupported
                                  ((xaction).eq "unapply_success").if
                                    seq
                                      xelapsed.write ((xcompute_time).if (" (%.3fs)".mod (((xtime).xmonotonic).sub ((xself).xstart))) "")
                                      (xfake).if
                                        bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xSUCCESS)).apply ((" FAKED".add (xelapsed))))))
                                        bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xSUCCESS)).apply ((" OK".add (xelapsed))))))
                                    ((xaction).eq "render_start").if
                                      seq
                                        (xcompute_time).if
                                          (((unsupported)).apply (((xself).xstart)) (((xtime).xmonotonic)))
                                        (((unsupported)).apply ((((xself).xstdout).xwrite)) ("  Rendering model states...") (""))
                                        unsupported
                                      ((xaction).eq "render_success").if
                                        seq
                                          xelapsed.write ((xcompute_time).if (" (%.3fs)".mod (((xtime).xmonotonic).sub ((xself).xstart))) "")
                                          bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((((((xself).xstyle).xSUCCESS)).apply ((" DONE".add (xelapsed))))))
                xsync_apps.write
                  [xself xconnection xapp_labels]
                    memory > xmanifest
                    memory > xtables
                    memory > xmodel_installed
                    memory > xall_models
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xconnection).xcursor)) ((xcursor)))
                          xtables.write (((((xconnection).xintrospection).xtable_names)).apply ((xcursor)))
                        xall_models.write (((unsupported)).apply ((((unsupported)).apply (((xapp_config).xlabel)) ((((unsupported)).apply (((xrouter).xget_migratable_models)) ((xapp_config)) (((xconnection).xalias)) (FALSE))))) ((xapp_config)) (((xapps).xget_app_configs)) (((((unsupported)).apply (((xapp_config).xmodels_module)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply (((xapp_config).xlabel)) ((xapp_labels))))))
                        xmodel_installed.write
                          [xmodel]
                            memory > xconverter
                            memory > xopts
                            seq > @
                              seq
                                xopts.write ((xmodel).x_meta)
                                xconverter.write (((xconnection).xintrospection).xidentifier_converter)
                                (((unsupported)).apply ((((((unsupported)).apply ((((xconverter)).apply (((xopts).xdb_table)))) ((xtables))).or (((xopts).xauto_created).and (((unsupported)).apply ((((xconverter)).apply (((((xopts).xauto_created).x_meta).xdb_table)))) ((xtables))))).not)))
                        xmanifest.write (((unsupported)).apply ((xapp_name)) ((((xlist)).apply ((((xfilter)).apply ((xmodel_installed)) ((xmodel_list)))))) ((((unsupported)).apply ((xapp_name)) ((xmodel_list)))) ((xall_models)))
                        (((xself).xverbosity).geq 1).if
                          bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("  Creating tables..."))
                        (((unsupported)).apply (((xconnection).xschema_editor)) ((xeditor)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xapp_name)) ((xmodel_list)))) (((xmanifest).xitems)))
                              (((unsupported)).apply ((xmodel)) ((xmodel_list)))
                                seq
                                  ((((((xmodel).x_meta).xcan_migrate)).apply ((xconnection))).not).if
                                    (((unsupported)).apply)
                                  (((xself).xverbosity).geq 3).if
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("    Processing %s.%s model".mod (((unsupported)).apply ((xapp_name)) ((((xmodel).x_meta).xobject_name))))))
                                  (((xself).xverbosity).geq 1).if
                                    bogusForceDataize.write (((((xself).xstdout).xwrite)).apply (("    Creating table %s".mod (((xmodel).x_meta).xdb_table))))
                                  bogusForceDataize.write ((((xeditor).xcreate_model)).apply ((xmodel)))
                            (((xself).xverbosity).geq 1).if
                              bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ("    Running deferred SQL..."))
                xdescribe_operation.write
                  [xoperation xbackwards]
                    memory > xprefix
                    memory > xcode
                    memory > xaction
                    memory > xis_error
                    memory > xtruncated
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xprefix.write ""
                        xis_error.write FALSE
                        (((xhasattr)).apply ((xoperation)) ("code")).if
                          seq
                            xcode.write ((xbackwards).if ((xoperation).xreverse_code) ((xoperation).xcode))
                            xaction.write ((xcode).if (((xcode).x__doc__).or "") "None: is there a None literal in the EO language?")
                          (((xhasattr)).apply ((xoperation)) ("sql")).if
                            xaction.write ((xbackwards).if ((xoperation).xreverse_sql) ((xoperation).xsql))
                            seq
                              xaction.write ""
                              (xbackwards).if
                                xprefix.write "Undo "
                        (((unsupported)).apply ((xaction)) ("None: is there a None literal in the EO language?")).if
                          xaction.write ((((((xstr)).apply ((xaction))).xreplace)).apply ("n") (""))
                          (xbackwards).if
                            seq
                              xaction.write "IRREVERSIBLE"
                              xis_error.write TRUE
                        (xaction).if
                          xaction.write (" -> ".add (xaction))
                        xtruncated.write (((xTruncator)).apply ((xaction)))
                        (((unsupported)).apply ((((unsupported)).apply ((((xprefix).add ((xoperation).xdescribe)).add ((((xtruncated).xchars)).apply (40)))) ((xis_error)))))