memory > xcopy
memory > xparent
memory > xValueError
memory > xQ
memory > xFieldError
memory > xLOOKUP_SEP
memory > xset
memory > xhasattr
memory > xTransform
memory > xsuper
memory > xgetattr
memory > xLookup
memory > xn
memory > xkwargs
memory > xTypeError
memory > xd
memory > xinspect
memory > xjoins
memory > xrange
memory > xNotImplementedError
memory > x_
memory > xtree
memory > xnamedtuple
memory > xreversed
memory > xtype
memory > xissubclass
memory > xtuple
memory > xNotImplemented
memory > xsorted
memory > xFilteredRelation
memory > xargs
memory > xsubclass
memory > xisinstance
memory > xlen
memory > xclause
[] > query_utils
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xAND
        memory > x__eq__
        memory > x__xor__
        memory > x__invert__
        memory > xdefault
        memory > xOR
        memory > xXOR
        memory > x_get_lookup
        memory > xdeconstruct
        memory > xregister_lookup
        memory > xresolve_expression
        memory > xrefs_expression
        memory > x__and__
        memory > xget_transform
        memory > x_unregister_lookup
        memory > x_combine
        memory > xget_lookup
        memory > xcheck_rel_lookup_compatibility
        memory > xget_lookups
        memory > xPathInfo
        memory > x_check_parent_chain
        memory > xclone
        memory > xmerge_dicts
        memory > xas_sql
        memory > xselect_related_descend
        memory > x__or__
        memory > x__get__
        memory > xsubclasses
        memory > x_clear_cached_lookups
        memory > x__init__
        memory > xconditional
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            xPathInfo.write (((xnamedtuple)).apply ("PathInfo") ("from_opts to_opts target_fields join_field m2m direct filtered_relation"))
            xsubclasses.write
              [xcls]
                seq > @
                  seq
                    (((unsupported)).apply ((xcls)))
                    (((unsupported)).apply ((xsubclass)) (((((xcls).x__subclasses__)).apply)))
                      (((unsupported)).apply ((((xsubclasses)).apply ((xsubclass)))))
            (((unsupported)).apply (((xtree).xNode)))
              seq
                (((unsupported)).apply)
                xAND.write "AND"
                xOR.write "OR"
                xXOR.write "XOR"
                xdefault.write (xAND)
                xconditional.write TRUE
                x__init__.write
                  [xself x_connector x_negated]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xsuper)).apply).x__init__)) ((((unsupported)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((((xsorted)).apply (((((xkwargs).xitems)).apply)))))))) ((x_connector)) ((x_negated)))
                x_combine.write
                  [xself xother xconn]
                    memory > xobj
                    seq > @
                      seq
                        (((((xisinstance)).apply ((xother)) ((xQ))).or (((unsupported)).apply ((((xgetattr)).apply ((xother)) ("conditional") (FALSE))) (TRUE))).not).if
                          (((unsupported)).apply ((((xTypeError)).apply ((xother)))))
                        ((xself).not).if
                          (((unsupported)).apply (((((xhasattr)).apply ((xother)) ("copy")).if ((((xother).xcopy)).apply) ((((xcopy).xcopy)).apply ((xother))))))
                          ((((xisinstance)).apply ((xother)) ((xQ))).and ((xother).not)).if
                            seq
                              (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xargs)) ((xkwargs)))) (((((xself).xdeconstruct)).apply)))
                              (((unsupported)).apply ((((((xtype)).apply ((xself)))).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                        xobj.write (((((xtype)).apply ((xself)))).apply)
                        (((unsupported)).apply (((xobj).xconnector)) ((xconn)))
                        bogusForceDataize.write ((((xobj).xadd)).apply ((xself)) ((xconn)))
                        bogusForceDataize.write ((((xobj).xadd)).apply ((xother)) ((xconn)))
                        (((unsupported)).apply ((xobj)))
                x__or__.write
                  [xself xother]
                    seq > @
                      (((unsupported)).apply (((((xself).x_combine)).apply ((xother)) (((xself).xOR)))))
                x__and__.write
                  [xself xother]
                    seq > @
                      (((unsupported)).apply (((((xself).x_combine)).apply ((xother)) (((xself).xAND)))))
                x__xor__.write
                  [xself xother]
                    seq > @
                      (((unsupported)).apply (((((xself).x_combine)).apply ((xother)) (((xself).xXOR)))))
                x__invert__.write
                  [xself]
                    memory > xobj
                    seq > @
                      seq
                        xobj.write (((((xtype)).apply ((xself)))).apply)
                        bogusForceDataize.write ((((xobj).xadd)).apply ((xself)) (((xself).xAND)))
                        bogusForceDataize.write ((((xobj).xnegate)).apply)
                        (((unsupported)).apply ((xobj)))
                xresolve_expression.write
                  [xself xquery xallow_joins xreuse xsummarize xfor_save]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xclause)) ((xjoins)))) ((((unsupported)).apply (((xquery).x_add_q)) ((xself)) ((xreuse)) ((xallow_joins)) (FALSE) (FALSE))))
                        bogusForceDataize.write ((((xquery).xpromote_joins)).apply ((xjoins)))
                        (((unsupported)).apply ((xclause)))
                xdeconstruct.write
                  [xself]
                    memory > xargs
                    memory > xkwargs
                    memory > xpath
                    seq > @
                      seq
                        xpath.write ("%s.%s".mod (((unsupported)).apply ((((xself).x__class__).x__module__)) ((((xself).x__class__).x__name__))))
                        ((((xpath).xstartswith)).apply ("django.db.models.query_utils")).if
                          xpath.write ((((xpath).xreplace)).apply ("django.db.models.query_utils") ("django.db.models"))
                        xargs.write (((xtuple)).apply (((xself).xchildren)))
                        xkwargs.write (((unsupported)).apply)
                        (((xself).xconnector).neq ((xself).xdefault)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("_connector"))) (((xself).xconnector)))
                        ((xself).xnegated).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("_negated"))) (TRUE))
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xargs)) ((xkwargs)))))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                x__init__.write
                  [xself xfield]
                    seq > @
                      (((unsupported)).apply (((xself).xfield)) ((xfield)))
                x__get__.write
                  [xself xinstance xcls]
                    memory > xval
                    memory > xfield_name
                    memory > xdata
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xinstance)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xself)))
                        xdata.write ((xinstance).x__dict__)
                        xfield_name.write (((xself).xfield).xattname)
                        (((unsupported)).apply ((xfield_name)) ((xdata))).if
                          seq
                            xval.write ((((xself).x_check_parent_chain)).apply ((xinstance)))
                            (((unsupported)).apply ((xval)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply (((xinstance).xrefresh_from_db)) ((((unsupported)).apply ((xfield_name)))))
                              (((unsupported)).apply ((((unsupported)).apply ((xdata)) ((xfield_name)))) ((xval)))
                        (((unsupported)).apply ((((unsupported)).apply ((xdata)) ((xfield_name)))))
                x_check_parent_chain.write
                  [xself xinstance]
                    memory > xlink_field
                    memory > xopts
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xopts.write ((xinstance).x_meta)
                        xlink_field.write ((((xopts).xget_ancestor_link)).apply ((((xself).xfield).xmodel)))
                        ((((xself).xfield).xprimary_key).and (((xself).xfield).neq (xlink_field))).if
                          (((unsupported)).apply ((((xgetattr)).apply ((xinstance)) (((xlink_field).xattname)))))
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
            (((unsupported)).apply)
              seq
                x_get_lookup.write
                  [xcls xlookup_name]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((((((xcls).xget_lookups)).apply).xget)).apply ((xlookup_name)) ("None: is there a None literal in the EO language?"))))
                xget_lookups.write
                  [xcls]
                    memory > xclass_lookups
                    seq > @
                      (((unsupported)).apply)
                        xclass_lookups.write (((unsupported)).apply ((((((xparent).x__dict__).xget)).apply ("class_lookups") ((((unsupported)).apply)))) ((xparent)) (((((xinspect).xgetmro)).apply ((xcls)))))
                        (((unsupported)).apply (((((xcls).xmerge_dicts)).apply ((xclass_lookups)))))
                xget_lookup.write
                  [xself xlookup_name]
                    memory > xfound
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xfound.write ((((xself).x_get_lookup)).apply ((xlookup_name)))
                        ((((unsupported)).apply ((xfound)) ("None: is there a None literal in the EO language?")).and (((xhasattr)).apply ((xself)) ("output_field"))).if
                          (((unsupported)).apply ((((((xself).xoutput_field).xget_lookup)).apply ((xlookup_name)))))
                        ((((unsupported)).apply ((xfound)) ("None: is there a None literal in the EO language?")).and ((((xissubclass)).apply ((xfound)) ((xLookup))).not)).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xfound)))
                xget_transform.write
                  [xself xlookup_name]
                    memory > xfound
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xfound.write ((((xself).x_get_lookup)).apply ((xlookup_name)))
                        ((((unsupported)).apply ((xfound)) ("None: is there a None literal in the EO language?")).and (((xhasattr)).apply ((xself)) ("output_field"))).if
                          (((unsupported)).apply ((((((xself).xoutput_field).xget_transform)).apply ((xlookup_name)))))
                        ((((unsupported)).apply ((xfound)) ("None: is there a None literal in the EO language?")).and ((((xissubclass)).apply ((xfound)) ((xTransform))).not)).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xfound)))
                xmerge_dicts.write
                  [xdicts]
                    memory > xmerged
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xmerged.write (((unsupported)).apply)
                        (((unsupported)).apply ((xd)) ((((xreversed)).apply ((xdicts)))))
                          bogusForceDataize.write ((((xmerged).xupdate)).apply ((xd)))
                        (((unsupported)).apply ((xmerged)))
                x_clear_cached_lookups.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xsubclass)) ((((xsubclasses)).apply ((xcls)))))
                          bogusForceDataize.write (((((xsubclass).xget_lookups).xcache_clear)).apply)
                xregister_lookup.write
                  [xcls xlookup xlookup_name]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xlookup_name)) ("None: is there a None literal in the EO language?")).if
                          xlookup_name.write ((xlookup).xlookup_name)
                        (((unsupported)).apply ("class_lookups") (((xcls).x__dict__))).if
                          (((unsupported)).apply (((xcls).xclass_lookups)) ((((unsupported)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply (((xcls).xclass_lookups)) ((xlookup_name)))) ((xlookup)))
                        bogusForceDataize.write ((((xcls).x_clear_cached_lookups)).apply)
                        (((unsupported)).apply ((xlookup)))
                x_unregister_lookup.write
                  [xcls xlookup xlookup_name]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xlookup_name)) ("None: is there a None literal in the EO language?")).if
                          xlookup_name.write ((xlookup).xlookup_name)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xcls).xclass_lookups)) ((xlookup_name)))))))))
            xselect_related_descend.write
              [xfield xrestricted xrequested xload_fields xreverse]
                memory > xmsg
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((xfield).xremote_field).not).if
                      (((unsupported)).apply (FALSE))
                    ((((xfield).xremote_field).xparent_link).and ((xreverse).not)).if
                      (((unsupported)).apply (FALSE))
                    (xrestricted).if
                      seq
                        ((xreverse).and (((unsupported)).apply (((((xfield).xrelated_query_name)).apply)) ((xrequested)))).if
                          (((unsupported)).apply (FALSE))
                        (((xreverse).not).and (((unsupported)).apply (((xfield).xname)) ((xrequested)))).if
                          (((unsupported)).apply (FALSE))
                    (((xrestricted).not).and ((xfield).xnull)).if
                      (((unsupported)).apply (FALSE))
                    (xload_fields).if
                      (((unsupported)).apply (((xfield).xattname)) ((xload_fields))).if
                        ((xrestricted).and (((unsupported)).apply (((xfield).xname)) ((xrequested)))).if
                          seq
                            xmsg.write ("Field %s.%s cannot be both deferred and traversed using select_related at the same time.".mod (((unsupported)).apply (((((xfield).xmodel).x_meta).xobject_name)) (((xfield).xname))))
                            (((unsupported)).apply ((((xFieldError)).apply ((xmsg)))))
                    (((unsupported)).apply (TRUE))
            xrefs_expression.write
              [xlookup_parts xannotations]
                memory > xlevel_n_lookup
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xn)) ((((xrange)).apply (1) (((((xlen)).apply ((xlookup_parts))).add 1)))))
                      seq
                        xlevel_n_lookup.write ((((xLOOKUP_SEP).xjoin)).apply ((((unsupported)).apply ((xlookup_parts)) ((((unsupported)).apply (0) ((xn)))))))
                        ((((unsupported)).apply ((xlevel_n_lookup)) ((xannotations))).and (((unsupported)).apply ((xannotations)) ((xlevel_n_lookup)))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xannotations)) ((xlevel_n_lookup)))) ((((unsupported)).apply ((xlookup_parts)) ((((unsupported)).apply ((xn)))))))))
                    (((unsupported)).apply ((((unsupported)).apply (FALSE) ((((unsupported)).apply)))))
            xcheck_rel_lookup_compatibility.write
              [xmodel xtarget_opts xfield]
                memory > xcheck
                seq > @
                  seq
                    (((unsupported)).apply)
                    xcheck.write
                      [xopts]
                        seq > @
                          (((unsupported)).apply (((((((xmodel).x_meta).xconcrete_model).eq ((xopts).xconcrete_model)).or (((unsupported)).apply (((xopts).xconcrete_model)) ((((((xmodel).x_meta).xget_parent_list)).apply)))).or (((unsupported)).apply ((xmodel)) (((((xopts).xget_parent_list)).apply))))))
                    (((unsupported)).apply (((((xcheck)).apply ((xtarget_opts))).or ((((xgetattr)).apply ((xfield)) ("primary_key") (FALSE)).and (((xcheck)).apply ((((xfield).xmodel).x_meta)))))))
            (((unsupported)).apply)
              seq
                unsupported
                x__init__.write
                  [xself xrelation_name xcondition]
                    seq > @
                      (((unsupported)).apply)
                        ((xrelation_name).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("relation_name cannot be empty."))))
                        (((unsupported)).apply (((xself).xrelation_name)) ((xrelation_name)))
                        (((unsupported)).apply (((xself).xalias)) ("None: is there a None literal in the EO language?"))
                        ((((xisinstance)).apply ((xcondition)) ((xQ))).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("condition argument must be a Q() instance."))))
                        (((unsupported)).apply (((xself).xcondition)) ((xcondition)))
                        (((unsupported)).apply (((xself).xpath)) ((((unsupported)).apply)))
                x__eq__.write
                  [xself xother]
                    seq > @
                      seq
                        ((((xisinstance)).apply ((xother)) (((xself).x__class__))).not).if
                          (((unsupported)).apply ((xNotImplemented)))
                        (((unsupported)).apply ((((((xself).xrelation_name).eq ((xother).xrelation_name)).and (((xself).xalias).eq ((xother).xalias))).and (((xself).xcondition).eq ((xother).xcondition)))))
                xclone.write
                  [xself]
                    memory > xclone
                    seq > @
                      seq
                        xclone.write (((unsupported)).apply ((xFilteredRelation)) (((xself).xrelation_name)) (((xself).xcondition)))
                        (((unsupported)).apply (((xclone).xalias)) (((xself).xalias)))
                        (((unsupported)).apply (((xclone).xpath)) ((((unsupported)).apply (((xself).xpath)) ((((unsupported)).apply)))))
                        (((unsupported)).apply ((xclone)))
                xresolve_expression.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xNotImplementedError)).apply ("FilteredRelation.resolve_expression() is unused."))))
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xwhere
                    memory > xquery
                    seq > @
                      seq
                        xquery.write ((xcompiler).xquery)
                        xwhere.write (((unsupported)).apply (((xquery).xbuild_filtered_relation_q)) (((xself).xcondition)) ((((xset)).apply (((xself).xpath)))))
                        (((unsupported)).apply (((((xcompiler).xcompile)).apply ((xwhere)))))