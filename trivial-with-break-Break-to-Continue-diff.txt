1,120c1,34
< +package org.eolang
< +alias goto org.eolang.gray.goto
< +alias stdout org.eolang.io.stdout
< +alias cage org.eolang.gray.cage
< +junit
< 
< [unused] > trivial-with-break
<   [] > apply
<     [stackUp] > @
<       [x] > mkCopy
<         x' > copy
<         copy.< > @
<       [] > newUID
<         memory > cur
<         seq > apply
<           cur.write (cur.is-empty.if 5 (cur.add 1))
<           cur
<       [] > raiseEmpty
<         [] > xclass
<           4 > xid
<       [res] > return
<         res > result
<         [] > xclass
<           3 > xid
<       [] > break
<         [] > xclass
<           2 > xid
<       [] > continue
<         [] > xclass
<           1 > xid
<       [] > raiseNothing
<         [] > xclass
<           0 > xid
<       cage > xcurrent-exception
<       cage > tmp
<       cage > assertMe
<       cage > xtestFib1
<       seq > @
<         stdout "trivial-with-break\n"
<         write.
<           xtestFib1
<           []
<             [] > apply
<               [stackUp] > @
<                 cage > tmp
<                 cage > e1
<                 cage > xf2
<                 cage > e0
<                 cage > xf1
<                 cage > e4
<                 cage > e3
<                 cage > xf0
<                 cage > e2
<                 cage > xii
<                 seq > @
<                   stdout "xtestFib1\n"
<                   (xf0).write (0)
<                   (xf1).write (1)
<                   (xii).write (0)
<                   write.
<                     xcurrent-exception
<                     goto
<                       [stackUp]
<                         seq > @
<                           TRUE.while
<                             [unused]
<                               seq > @
<                                 [] > tmp1
<                                   memory > dddata
<                                   dddata.write (((xii).less 110)) > @
<                                 (e3).write (tmp1.dddata)
<                                 ((e3).not).if
<                                   seq
<                                     stackUp.forward break
<                                     TRUE
<                                   seq
<                                     TRUE
<                                 [] > tmp2
<                                   memory > dddata
<                                   dddata.write (((xf0).add (xf1))) > @
<                                 (e0).write (tmp2.dddata)
<                                 mkCopy (e0) > tmp3
<                                 (xf2).write (tmp3.copy)
<                                 [] > tmp4
<                                   memory > dddata
<                                   dddata.write (((xii).add 1)) > @
<                                 (e1).write (tmp4.dddata)
<                                 mkCopy (e1) > tmp5
<                                 (xii).write (tmp5.copy)
<                                 mkCopy (xf1) > tmp6
<                                 (xf0).write (tmp6.copy)
<                                 mkCopy (xf2) > tmp7
<                                 (xf1).write (tmp7.copy)
<                                 [] > tmp8
<                                   memory > dddata
<                                   dddata.write (((xii).eq 9)) > @
<                                 (e2).write (tmp8.dddata)
<                                 (e2).if
<                                   seq
<                                     stackUp.forward break
<                                     TRUE
<                                   seq
<                                     TRUE
<                                 TRUE
<                           stackUp.forward raiseNothing
<                   if.
<                     xcurrent-exception.xclass.xid.neq (break.xclass.xid)
<                     stackUp.forward xcurrent-exception
<                     0
<                   [] > tmp9
<                     memory > dddata
<                     dddata.write ((34.eq (xf0))) > @
<                   (e4).write (tmp9.dddata)
<                   stackUp.forward (return (e4))
<                   123
<         tmp.write (goto ((((xtestFib1)).apply).@))
<         (tmp.xclass.xid.neq (return.xclass.xid)).if (stackUp.forward tmp) 0
<         (assertMe).write (tmp.result)
<         stackUp.forward (return (assertMe))
<   (goto (apply.@)).result > @
\ No newline at end of file
---
> [] > trivial-with-break
>   [args...] > unsupported
>   [args...] > xunsupported
>   memory > bogusForceDataize
>   memory > xbogusForceDataize
>   memory > xhack
>   seq > @
>     xhack.write
>       []
>         memory > xtestFib1
>         seq > @
>           xtestFib1.write
>             []
>               memory > xf2
>               memory > xf1
>               memory > xf0
>               memory > xii
>               seq > @
>                 seq
>                   xf0.write 0
>                   xf1.write 1
>                   xii.write 0
>                   while.
>                     ((xii).less 110)
>                     [unused]
>                       seq > @
>                         seq
>                           xf2.write ((xf0).add (xf1))
>                           xii.write ((xii).add 1)
>                           xf0.write (xf1)
>                           xf1.write (xf2)
>                           ((xii).eq 9).if
>                             (((unsupported)).apply)
>                   (((unsupported)).apply ((34.eq (xf0))))
\ No newline at end of file