memory > xAttributeError
memory > xcat
memory > xto_locale
memory > xSafeData
memory > xrange
memory > xaccept_lang
memory > xRuntimeWarning
memory > xi
memory > xsys
memory > xfloat
memory > xgetattr
memory > xk
memory > xlang
memory > xDjangoTranslation
memory > x_lazy_re_compile
memory > xlocaledir
memory > xunused
memory > xwarnings
memory > xapps
memory > xKeyError
memory > xAppRegistryNotReady
memory > xpath
memory > xreversed
memory > xany
memory > xtype
memory > xLANG_INFO
memory > xsettings
memory > xint
memory > xre
memory > xTranslationCatalog
memory > xcode
memory > xLocal
memory > xhasattr
memory > xtuple
memory > xmark_safe
memory > xOSError
memory > xLookupError
memory > xos
memory > xfirst
memory > xsupported_code
memory > xapp_config
memory > xzip
memory > xn
memory > xobject
memory > xisinstance
memory > xlen
memory > xdict
[] > trans_real
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xget_language_bidi
        memory > xkeys
        memory > x_active
        memory > xget_languages
        memory > x__setitem__
        memory > xupdate
        memory > xparse_accept_lang_header
        memory > xnpgettext
        memory > xdeactivate_all
        memory > xaccept_language_re
        memory > xmerge
        memory > x__repr__
        memory > xtranslation
        memory > xget
        memory > xto_language
        memory > xcatalog
        memory > xreset_cache
        memory > x_translations
        memory > x_new_gnu_trans
        memory > x__contains__
        memory > xget_language_from_path
        memory > xngettext
        memory > x_init_translation_catalog
        memory > xCONTEXT_SEPARATOR
        memory > xdo_ntranslate
        memory > x__getitem__
        memory > x_add_local_translations
        memory > xcheck_for_language
        memory > xgettext_noop
        memory > xgettext_module
        memory > xplural
        memory > xactivate
        memory > xlanguage_code_prefix_re
        memory > xgettext
        memory > x_add_installed_apps_translations
        memory > xpgettext
        memory > xall_locale_paths
        memory > xget_language_from_request
        memory > xitems
        memory > xlanguage
        memory > x_default
        memory > xget_supported_language_variant
        memory > x__init__
        memory > xdomain
        memory > xdeactivate
        memory > xget_language
        memory > xlanguage_code_re
        memory > x_add_fallback
        seq > @
          seq
            unsupported
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            x_translations.write (((unsupported)).apply)
            x_active.write (((xLocal)).apply)
            x_default.write "None: is there a None literal in the EO language?"
            xCONTEXT_SEPARATOR.write "x04"
            xaccept_language_re.write (((x_lazy_re_compile)).apply ((((unsupported)).apply)) (((xre).xVERBOSE)))
            xlanguage_code_re.write (((x_lazy_re_compile)).apply ("^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$") (((xre).xIGNORECASE)))
            xlanguage_code_prefix_re.write (((x_lazy_re_compile)).apply ("^/(w-([@-]w-){0,2})(/|$)"))
            xreset_cache.write
              [xsetting]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xsetting)) ((((unsupported)).apply ("LANGUAGES") ("LANGUAGE_CODE")))).if
                      seq
                        bogusForceDataize.write ((((xcheck_for_language).xcache_clear)).apply)
                        bogusForceDataize.write ((((xget_languages).xcache_clear)).apply)
                        bogusForceDataize.write ((((xget_supported_language_variant).xcache_clear)).apply)
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                x__init__.write
                  [xself xtrans]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_catalogs)) (((xtrans).if (((unsupported)).apply ((((((xtrans).x_catalog).xcopy)).apply))) (((unsupported)).apply ((((unsupported)).apply))))))
                        (((unsupported)).apply (((xself).x_plurals)) (((xtrans).if (((unsupported)).apply (((xtrans).xplural))) (((unsupported)).apply ((((unsupported)).apply ((((xint)).apply (((xn).neq 1))))))))))
                x__getitem__.write
                  [xself xkey]
                    seq > @
                      seq
                        (((unsupported)).apply ((xcat)) (((xself).x_catalogs)))
                          (((unsupported)).apply ((xKeyError)))
                            (((unsupported)).apply ((((unsupported)).apply ((xcat)) ((xkey)))))
                        (((unsupported)).apply ((((xKeyError)).apply ((xkey)))))
                x__setitem__.write
                  [xself xkey xvalue]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xself).x_catalogs)) (0))) ((xkey)))) ((xvalue)))
                x__contains__.write
                  [xself xkey]
                    seq > @
                      (((unsupported)).apply ((((xany)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xcat)))) ((xcat)) (((xself).x_catalogs)))))))
                xitems.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((xcat)) (((xself).x_catalogs)))
                        (((unsupported)).apply (((((xcat).xitems)).apply)))
                xkeys.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((xcat)) (((xself).x_catalogs)))
                        (((unsupported)).apply (((((xcat).xkeys)).apply)))
                xupdate.write
                  [xself xtrans]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ((xcat)) ((xplural)))) ((((xzip)).apply (((xself).x_catalogs)) (((xself).x_plurals)))))
                        ((((xtrans).xplural).x__code__).eq ((xplural).x__code__)).if
                          seq
                            bogusForceDataize.write ((((xcat).xupdate)).apply (((xtrans).x_catalog)))
                            (((unsupported)).apply)
                        seq
                          bogusForceDataize.write (((((xself).x_catalogs).xinsert)).apply (0) ((((((xtrans).x_catalog).xcopy)).apply)))
                          bogusForceDataize.write (((((xself).x_plurals).xinsert)).apply (0) (((xtrans).xplural)))
                xget.write
                  [xself xkey xdefault]
                    memory > xmissing
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xmissing.write (((xobject)).apply)
                        (((unsupported)).apply ((xcat)) (((xself).x_catalogs)))
                          seq
                            xresult.write ((((xcat).xget)).apply ((xkey)) ((xmissing)))
                            (((unsupported)).apply ((xresult)) ((xmissing))).if
                              (((unsupported)).apply ((xresult)))
                        (((unsupported)).apply ((xdefault)))
                xplural.write
                  [xself xmsgid xnum]
                    memory > xtmsg
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xcat)) ((xplural)))) ((((xzip)).apply (((xself).x_catalogs)) (((xself).x_plurals)))))
                          seq
                            xtmsg.write ((((xcat).xget)).apply ((((unsupported)).apply ((xmsgid)) ((((xplural)).apply ((xnum)))))))
                            (((unsupported)).apply ((xtmsg)) ("None: is there a None literal in the EO language?")).if
                              (((unsupported)).apply ((xtmsg)))
                        (((unsupported)).apply ((xKeyError)))
            (((unsupported)).apply (((xgettext_module).xGNUTranslations)))
              seq
                (((unsupported)).apply)
                xdomain.write "django"
                x__init__.write
                  [xself xlanguage xdomain xlocaledirs]
                    memory > xtranslation
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        bogusForceDataize.write (((((xgettext_module).xGNUTranslations).x__init__)).apply ((xself)))
                        (((unsupported)).apply ((xdomain)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xdomain)) ((xdomain)))
                        (((unsupported)).apply (((xself).x__language)) ((xlanguage)))
                        (((unsupported)).apply (((xself).x__to_language)) ((((xto_language)).apply ((xlanguage)))))
                        (((unsupported)).apply (((xself).x__locale)) ((((xto_locale)).apply ((xlanguage)))))
                        (((unsupported)).apply (((xself).x_catalog)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xplural)) ((((unsupported)).apply ((((xint)).apply (((xn).neq 1)))))))
                        (((xself).xdomain).eq "django").if
                          seq
                            (((unsupported)).apply ((xlocaledirs)) ("None: is there a None literal in the EO language?")).if
                              seq
                                bogusForceDataize.write ((((xwarnings).xwarn)).apply ("localedirs is ignored when domain is 'django'.") ((xRuntimeWarning)))
                                xlocaledirs.write "None: is there a None literal in the EO language?"
                            bogusForceDataize.write ((((xself).x_init_translation_catalog)).apply)
                        (xlocaledirs).if
                          (((unsupported)).apply ((xlocaledir)) ((xlocaledirs)))
                            seq
                              xtranslation.write ((((xself).x_new_gnu_trans)).apply ((xlocaledir)))
                              bogusForceDataize.write ((((xself).xmerge)).apply ((xtranslation)))
                          bogusForceDataize.write ((((xself).x_add_installed_apps_translations)).apply)
                        bogusForceDataize.write ((((xself).x_add_local_translations)).apply)
                        (((((xself).x__language).eq ((xsettings).xLANGUAGE_CODE)).and (((xself).xdomain).eq "django")).and (((unsupported)).apply (((xself).x_catalog)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((((xOSError)).apply (("No translation files found for default language %s.".mod ((xsettings).xLANGUAGE_CODE))))))
                        bogusForceDataize.write ((((xself).x_add_fallback)).apply ((xlocaledirs)))
                        (((unsupported)).apply (((xself).x_catalog)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).x_catalog)) ((((xTranslationCatalog)).apply)))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<DjangoTranslation lang:%s>".mod ((xself).x__language))))
                x_new_gnu_trans.write
                  [xself xlocaledir xuse_null_fallback]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xgettext_module).xtranslation)) (((xself).xdomain)) ((xlocaledir)) ((((unsupported)).apply (((xself).x__locale)))) ((xuse_null_fallback)))))
                x_init_translation_catalog.write
                  [xself]
                    memory > xsettingsfile
                    memory > xtranslation
                    memory > xlocaledir
                    seq > @
                      seq
                        unsupported
                        xsettingsfile.write ((((unsupported)).apply (((xsys).xmodules)) (((xsettings).x__module__))).x__file__)
                        xlocaledir.write (((((xos).xpath).xjoin)).apply ((((((xos).xpath).xdirname)).apply ((xsettingsfile)))) ("locale"))
                        xtranslation.write ((((xself).x_new_gnu_trans)).apply ((xlocaledir)))
                        bogusForceDataize.write ((((xself).xmerge)).apply ((xtranslation)))
                x_add_installed_apps_translations.write
                  [xself]
                    memory > xtranslation
                    memory > xapp_configs
                    memory > xlocaledir
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((xAppRegistryNotReady)))
                          xapp_configs.write (((xreversed)).apply (((((xapps).xget_app_configs)).apply)))
                          (((unsupported)).apply ((((xAppRegistryNotReady)).apply ("The translation infrastructure cannot be initialized before the apps registry is ready. Check that you don't make non-lazy gettext calls at import time."))))
                        (((unsupported)).apply ((xapp_config)) ((xapp_configs)))
                          seq
                            xlocaledir.write (((((xos).xpath).xjoin)).apply (((xapp_config).xpath)) ("locale"))
                            (((((xos).xpath).xexists)).apply ((xlocaledir))).if
                              seq
                                xtranslation.write ((((xself).x_new_gnu_trans)).apply ((xlocaledir)))
                                bogusForceDataize.write ((((xself).xmerge)).apply ((xtranslation)))
                x_add_local_translations.write
                  [xself]
                    memory > xtranslation
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((xlocaledir)) ((((xreversed)).apply (((xsettings).xLOCALE_PATHS)))))
                          seq
                            xtranslation.write ((((xself).x_new_gnu_trans)).apply ((xlocaledir)))
                            bogusForceDataize.write ((((xself).xmerge)).apply ((xtranslation)))
                x_add_fallback.write
                  [xself xlocaledirs]
                    memory > xdefault_translation
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        ((((xself).x__language).eq ((xsettings).xLANGUAGE_CODE)).or (((((xself).x__language).xstartswith)).apply ("en"))).if
                          (((unsupported)).apply)
                        (((xself).xdomain).eq "django").if
                          xdefault_translation.write (((xtranslation)).apply (((xsettings).xLANGUAGE_CODE)))
                          xdefault_translation.write (((unsupported)).apply ((xDjangoTranslation)) (((xsettings).xLANGUAGE_CODE)) (((xself).xdomain)) ((xlocaledirs)))
                        bogusForceDataize.write ((((xself).xadd_fallback)).apply ((xdefault_translation)))
                xmerge.write
                  [xself xother]
                    seq > @
                      seq
                        unsupported
                        ((((xgetattr)).apply ((xother)) ("_catalog") ("None: is there a None literal in the EO language?")).not).if
                          (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_catalog)) ("None: is there a None literal in the EO language?")).if
                          seq
                            (((unsupported)).apply (((xself).xplural)) (((xother).xplural)))
                            (((unsupported)).apply (((xself).x_info)) ((((((xother).x_info).xcopy)).apply)))
                            (((unsupported)).apply (((xself).x_catalog)) ((((xTranslationCatalog)).apply ((xother)))))
                          bogusForceDataize.write (((((xself).x_catalog).xupdate)).apply ((xother)))
                        ((xother).x_fallback).if
                          bogusForceDataize.write ((((xself).xadd_fallback)).apply (((xother).x_fallback)))
                xlanguage.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xself).x__language)))
                xto_language.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xself).x__to_language)))
                xngettext.write
                  [xself xmsgid1 xmsgid2 xn]
                    memory > xtmsg
                    seq > @
                      seq
                        (((unsupported)).apply ((xKeyError)))
                          xtmsg.write (((((xself).x_catalog).xplural)).apply ((xmsgid1)) ((xn)))
                          seq
                            ((xself).x_fallback).if
                              (((unsupported)).apply ((((((xself).x_fallback).xngettext)).apply ((xmsgid1)) ((xmsgid2)) ((xn)))))
                            ((xn).eq 1).if
                              xtmsg.write (xmsgid1)
                              xtmsg.write (xmsgid2)
                        (((unsupported)).apply ((xtmsg)))
            xtranslation.write
              [xlanguage]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xlanguage)) ((x_translations))).if
                      (((unsupported)).apply ((((unsupported)).apply ((x_translations)) ((xlanguage)))) ((((xDjangoTranslation)).apply ((xlanguage)))))
                    (((unsupported)).apply ((((unsupported)).apply ((x_translations)) ((xlanguage)))))
            xactivate.write
              [xlanguage]
                seq > @
                  seq
                    (((unsupported)).apply)
                    ((xlanguage).not).if
                      (((unsupported)).apply)
                    (((unsupported)).apply (((x_active).xvalue)) ((((xtranslation)).apply ((xlanguage)))))
            xdeactivate.write
              []
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((xhasattr)).apply ((x_active)) ("value")).if
                      (((unsupported)).apply ((((unsupported)).apply (((x_active).xvalue)))))
            xdeactivate_all.write
              []
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply (((x_active).xvalue)) (((((xgettext_module).xNullTranslations)).apply)))
                    (((unsupported)).apply ((((x_active).xvalue).xto_language)) ((((unsupported)).apply ("None: is there a None literal in the EO language?"))))
            xget_language.write
              []
                memory > xt
                seq > @
                  seq
                    unsupported
                    xt.write (((xgetattr)).apply ((x_active)) ("value") ("None: is there a None literal in the EO language?"))
                    (((unsupported)).apply ((xt)) ("None: is there a None literal in the EO language?")).if
                      (((unsupported)).apply ((xAttributeError)))
                        (((unsupported)).apply (((((xt).xto_language)).apply)))
                    (((unsupported)).apply (((xsettings).xLANGUAGE_CODE)))
            xget_language_bidi.write
              []
                memory > xbase_lang
                memory > xlang
                seq > @
                  seq
                    (((unsupported)).apply)
                    xlang.write (((xget_language)).apply)
                    (((unsupported)).apply ((xlang)) ("None: is there a None literal in the EO language?")).if
                      (((unsupported)).apply (FALSE))
                      seq
                        xbase_lang.write (((unsupported)).apply (((((((xget_language)).apply).xsplit)).apply ("-"))) (0))
                        (((unsupported)).apply ((((unsupported)).apply ((xbase_lang)) (((xsettings).xLANGUAGES_BIDI)))))
            xcatalog.write
              []
                memory > xt
                memory > x_default
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply)
                    xt.write (((xgetattr)).apply ((x_active)) ("value") ("None: is there a None literal in the EO language?"))
                    (((unsupported)).apply ((xt)) ("None: is there a None literal in the EO language?")).if
                      (((unsupported)).apply ((xt)))
                    (((unsupported)).apply ((x_default)) ("None: is there a None literal in the EO language?")).if
                      x_default.write (((xtranslation)).apply (((xsettings).xLANGUAGE_CODE)))
                    (((unsupported)).apply ((x_default)))
            xgettext.write
              [xmessage]
                memory > x_default
                memory > xresult
                memory > xtranslation_object
                memory > xeol_message
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply)
                    xeol_message.write (((((((xmessage).xreplace)).apply ("rn") ("n")).xreplace)).apply ("r") ("n"))
                    (xeol_message).if
                      seq
                        x_default.write ((x_default).or (((xtranslation)).apply (((xsettings).xLANGUAGE_CODE))))
                        xtranslation_object.write (((xgetattr)).apply ((x_active)) ("value") ((x_default)))
                        xresult.write ((((xtranslation_object).xgettext)).apply ((xeol_message)))
                      xresult.write (((((xtype)).apply ((xmessage)))).apply (""))
                    (((xisinstance)).apply ((xmessage)) ((xSafeData))).if
                      (((unsupported)).apply ((((xmark_safe)).apply ((xresult)))))
                    (((unsupported)).apply ((xresult)))
            xpgettext.write
              [xcontext xmessage]
                memory > xresult
                memory > xmsg_with_ctxt
                seq > @
                  seq
                    xmsg_with_ctxt.write ("%s%s%s".mod (((unsupported)).apply ((xcontext)) ((xCONTEXT_SEPARATOR)) ((xmessage))))
                    xresult.write (((xgettext)).apply ((xmsg_with_ctxt)))
                    (((unsupported)).apply ((xCONTEXT_SEPARATOR)) ((xresult))).if
                      xresult.write (xmessage)
                      (((xisinstance)).apply ((xmessage)) ((xSafeData))).if
                        xresult.write (((xmark_safe)).apply ((xresult)))
                    (((unsupported)).apply ((xresult)))
            xgettext_noop.write
              [xmessage]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((xmessage)))
            xdo_ntranslate.write
              [xsingular xplural xnumber xtranslation_function]
                memory > xt
                memory > x_default
                seq > @
                  seq
                    (((unsupported)).apply)
                    xt.write (((xgetattr)).apply ((x_active)) ("value") ("None: is there a None literal in the EO language?"))
                    (((unsupported)).apply ((xt)) ("None: is there a None literal in the EO language?")).if
                      (((unsupported)).apply ((((((xgetattr)).apply ((xt)) ((xtranslation_function)))).apply ((xsingular)) ((xplural)) ((xnumber)))))
                    (((unsupported)).apply ((x_default)) ("None: is there a None literal in the EO language?")).if
                      x_default.write (((xtranslation)).apply (((xsettings).xLANGUAGE_CODE)))
                    (((unsupported)).apply ((((((xgetattr)).apply ((x_default)) ((xtranslation_function)))).apply ((xsingular)) ((xplural)) ((xnumber)))))
            xngettext.write
              [xsingular xplural xnumber]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((xdo_ntranslate)).apply ((xsingular)) ((xplural)) ((xnumber)) ("ngettext"))))
            xnpgettext.write
              [xcontext xsingular xplural xnumber]
                memory > xresult
                memory > xmsgs_with_ctxt
                seq > @
                  seq
                    xmsgs_with_ctxt.write (((unsupported)).apply (("%s%s%s".mod (((unsupported)).apply ((xcontext)) ((xCONTEXT_SEPARATOR)) ((xsingular))))) (("%s%s%s".mod (((unsupported)).apply ((xcontext)) ((xCONTEXT_SEPARATOR)) ((xplural))))) ((xnumber)))
                    xresult.write (((xngettext)).apply ((((unsupported)).apply ((xmsgs_with_ctxt)))))
                    (((unsupported)).apply ((xCONTEXT_SEPARATOR)) ((xresult))).if
                      xresult.write (((xngettext)).apply ((xsingular)) ((xplural)) ((xnumber)))
                    (((unsupported)).apply ((xresult)))
            xall_locale_paths.write
              []
                memory > xapp_paths
                memory > xglobalpath
                memory > xlocale_path
                seq > @
                  seq
                    (((unsupported)).apply)
                    xglobalpath.write (((((xos).xpath).xjoin)).apply ((((((xos).xpath).xdirname)).apply (((((unsupported)).apply (((xsys).xmodules)) (((xsettings).x__module__))).x__file__)))) ("locale"))
                    xapp_paths.write (((unsupported)).apply)
                    (((unsupported)).apply ((xapp_config)) (((((xapps).xget_app_configs)).apply)))
                      seq
                        xlocale_path.write (((((xos).xpath).xjoin)).apply (((xapp_config).xpath)) ("locale"))
                        (((((xos).xpath).xexists)).apply ((xlocale_path))).if
                          bogusForceDataize.write ((((xapp_paths).xappend)).apply ((xlocale_path)))
                    (((unsupported)).apply ((((unsupported)).apply ((xglobalpath)) ((((unsupported)).apply (((xsettings).xLOCALE_PATHS)))) ((((unsupported)).apply ((xapp_paths)))))))
            xcheck_for_language.write
              [xlang_code]
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    ((((unsupported)).apply ((xlang_code)) ("None: is there a None literal in the EO language?")).or (((((xlanguage_code_re).xsearch)).apply ((xlang_code))).not)).if
                      (((unsupported)).apply (FALSE))
                    (((unsupported)).apply ((((xany)).apply ((((unsupported)).apply ((((unsupported)).apply (((((xgettext_module).xfind)).apply ("django") ((xpath)) ((((unsupported)).apply ((((xto_locale)).apply ((xlang_code)))))))) ("None: is there a None literal in the EO language?"))) ((xpath)) ((((xall_locale_paths)).apply)))))))
            xget_languages.write
              []
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((xdict)).apply (((xsettings).xLANGUAGES)))))
            xget_supported_language_variant.write
              [xlang_code xstrict]
                memory > xpossible_lang_codes
                memory > xi
                memory > xgeneric_lang_code
                memory > xsupported_lang_codes
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (xlang_code).if
                      seq
                        xpossible_lang_codes.write (((unsupported)).apply ((xlang_code)))
                        (((unsupported)).apply ((xKeyError)))
                          bogusForceDataize.write ((((xpossible_lang_codes).xextend)).apply ((((unsupported)).apply ((((unsupported)).apply ((xLANG_INFO)) ((xlang_code)))) ("fallback"))))
                        xi.write "None: is there a None literal in the EO language?"
                        while.
                          ((((unsupported)).apply (((((xlang_code).xrfind)).apply ("-") (0) ((xi))))).greater (1.neg))
                          [unused]
                            seq > @
                              bogusForceDataize.write ((((xpossible_lang_codes).xappend)).apply ((((unsupported)).apply ((xlang_code)) ((((unsupported)).apply ((xi)))))))
                        xgeneric_lang_code.write (((unsupported)).apply ((xpossible_lang_codes)) ((1.neg)))
                        xsupported_lang_codes.write (((xget_languages)).apply)
                        (((unsupported)).apply ((xcode)) ((xpossible_lang_codes)))
                          ((((unsupported)).apply ((xcode)) ((xsupported_lang_codes))).and (((xcheck_for_language)).apply ((xcode)))).if
                            (((unsupported)).apply ((xcode)))
                        ((xstrict).not).if
                          (((unsupported)).apply ((xsupported_code)) ((xsupported_lang_codes)))
                            ((((xsupported_code).xstartswith)).apply (((xgeneric_lang_code).sub "-"))).if
                              (((unsupported)).apply ((xsupported_code)))
                    (((unsupported)).apply ((((xLookupError)).apply ((xlang_code)))))
            xget_language_from_path.write
              [xpath xstrict]
                memory > xregex_match
                memory > xlang_code
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xregex_match.write ((((xlanguage_code_prefix_re).xmatch)).apply ((xpath)))
                    ((xregex_match).not).if
                      (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                    xlang_code.write (((unsupported)).apply ((xregex_match)) (1))
                    (((unsupported)).apply ((xLookupError)))
                      (((unsupported)).apply ((((unsupported)).apply ((xget_supported_language_variant)) ((xlang_code)) ((xstrict)))))
                      (((unsupported)).apply ("None: is there a None literal in the EO language?"))
            xget_language_from_request.write
              [xrequest xcheck_path]
                memory > xaccept
                memory > xlang_code
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    (xcheck_path).if
                      seq
                        xlang_code.write (((xget_language_from_path)).apply (((xrequest).xpath_info)))
                        (((unsupported)).apply ((xlang_code)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xlang_code)))
                    xlang_code.write (((((xrequest).xCOOKIES).xget)).apply (((xsettings).xLANGUAGE_COOKIE_NAME)))
                    (((((unsupported)).apply ((xlang_code)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xlang_code)) ((((xget_languages)).apply)))).and (((xcheck_for_language)).apply ((xlang_code)))).if
                      (((unsupported)).apply ((xlang_code)))
                    (((unsupported)).apply ((xLookupError)))
                      (((unsupported)).apply ((((xget_supported_language_variant)).apply ((xlang_code)))))
                    xaccept.write (((((xrequest).xMETA).xget)).apply ("HTTP_ACCEPT_LANGUAGE") (""))
                    (((unsupported)).apply ((((unsupported)).apply ((xaccept_lang)) ((xunused)))) ((((xparse_accept_lang_header)).apply ((xaccept)))))
                      seq
                        ((xaccept_lang).eq "*").if
                          (((unsupported)).apply)
                        (((((xlanguage_code_re).xsearch)).apply ((xaccept_lang))).not).if
                          (((unsupported)).apply)
                        (((unsupported)).apply ((xLookupError)))
                          (((unsupported)).apply ((((xget_supported_language_variant)).apply ((xaccept_lang)))))
                          (((unsupported)).apply)
                    (((unsupported)).apply ((xLookupError)))
                      (((unsupported)).apply ((((xget_supported_language_variant)).apply (((xsettings).xLANGUAGE_CODE)))))
                      (((unsupported)).apply (((xsettings).xLANGUAGE_CODE)))
            xparse_accept_lang_header.write
              [xlang_string]
                memory > xpieces
                memory > xresult
                memory > xpriority
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xresult.write (((unsupported)).apply)
                    xpieces.write ((((xaccept_language_re).xsplit)).apply (((((xlang_string).xlower)).apply)))
                    (((unsupported)).apply ((xpieces)) ((1.neg))).if
                      (((unsupported)).apply ((((unsupported)).apply)))
                    (((unsupported)).apply ((xi)) ((((xrange)).apply (0) (((((xlen)).apply ((xpieces))).sub 1)) (3))))
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xfirst)) ((xlang)) ((xpriority)))) ((((unsupported)).apply ((xpieces)) ((((unsupported)).apply ((xi)) (((xi).sub 3)))))))
                        (xfirst).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        (xpriority).if
                          xpriority.write (((xfloat)).apply ((xpriority)))
                          xpriority.write 1.0
                        bogusForceDataize.write ((((xresult).xappend)).apply ((((unsupported)).apply ((xlang)) ((xpriority)))))
                    (((unsupported)).apply (((xresult).xsort)) ((((unsupported)).apply ((((unsupported)).apply ((xk)) (1))))) (TRUE))
                    (((unsupported)).apply ((((xtuple)).apply ((xresult)))))