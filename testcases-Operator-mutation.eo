memory > xdifflib
memory > xgetattr
memory > xcm
memory > xnetloc
memory > xinspect
memory > xthreading
memory > xcopy
memory > xDEFAULT_DB_ALIAS
memory > xThreadedWSGIServer
memory > x_AssertTemplateNotUsedContext
memory > xAttributeError
memory > x_DatabaseFailure
memory > xvalidate_host
memory > xall
memory > xparse_qsl
memory > xlist
memory > xQueryDict
memory > xurlunparse
memory > xenumerate
memory > xWSGIHandler
memory > xget_close_matches
memory > xContextList
memory > xClient
memory > xfeature
memory > x_MediaFilesHandler
memory > xValueError
memory > xdeepcopy
memory > xfrozenset
memory > xstr
memory > xconn
memory > xurlparse
memory > xwarnings
memory > xcontext
memory > xerrors
memory > xapps
memory > xValidationError
memory > xAssertionError
memory > xurlencode
memory > xt
memory > xcall_command
memory > xno_style
memory > xWSGIRequestHandler
memory > xget_path_info
memory > xvalue
memory > xsplit_domain_port
memory > xCharField
memory > xtemplate_names
memory > x_
memory > xalias
memory > xconnection
memory > xbase
memory > xscheme
memory > x_StaticFilesHandler
memory > x_DebugResult
memory > xoutput
memory > xopen
memory > xreversed
memory > xany
memory > xtype
memory > xcallable
memory > xpath
memory > xasync_to_sync
memory > xset
memory > xHttpResponseBase
memory > xrepr
memory > xint
memory > xException
memory > xconnections
memory > xcontext_mgr_template
memory > xhasattr
memory > xCounter
memory > xcursor
memory > xTransactionTestCase
memory > xi
memory > xparams
memory > xsuper
memory > xRemovedInDjango50Warning
memory > x_AssertTemplateUsedContext
memory > xsys
memory > xoverride_settings
memory > xissubclass
memory > xFSFilesHandler
memory > xbytes
memory > xquery
memory > xHttp404
memory > xCaptureQueriesContext
memory > xdb_name
memory > xsorted
memory > xparse_html
memory > xunquote
memory > x_AssertNumQueriesContext
memory > xmail
memory > xtext_repr
memory > xargs
memory > xurl2pathname
memory > xPY310
memory > xfeatures
memory > xsql
memory > xoperation
memory > xinput
memory > xcontext_manager
memory > xe
memory > xposixpath
memory > xsetattr
memory > xLiveServerThread
memory > xreason
memory > xname
memory > xunittest
memory > xconditions
memory > xcallback
memory > xHTMLParseError
memory > xQuietWSGIRequestHandler
memory > xcondition
memory > xmap
memory > xCheckCondition
memory > xdomain
memory > xjson
memory > xcompare_xml
memory > xurlsplit
memory > xsetting_changed
memory > xDatabaseOperationForbidden
memory > xreal_count
memory > xImproperlyConfigured
memory > xAsyncClient
memory > xtemplate_rendered
memory > xTestData
memory > xkwargs
memory > xisinstance
memory > xtransaction
memory > xurljoin
memory > xlocks
memory > xlen
memory > xsafe_repr
memory > xSimpleTestCase
memory > xemit_post_migrate_signal
memory > xTypeError
memory > xasyncio
memory > xfragment
memory > xlogging
[] > testcases
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xassertHTMLNotEqual
        memory > x_check_test_client_response
        memory > xtearDownClass
        memory > x_should_reload_connections
        memory > x_validate_databases
        memory > xdatabases
        memory > x_pre_setup
        memory > xasync_client_class
        memory > xon_template_render
        memory > x__repr__
        memory > xserialized_rollback
        memory > x__call__
        memory > xcaptureOnCommitCallbacks
        memory > xserver_thread_class
        memory > xassertTemplateUsed
        memory > x_create_server_thread
        memory > xallowed_host
        memory > xassertJSONNotEqual
        memory > x_assertFooMessage
        memory > xfile_path
        memory > xdebug
        memory > x_start_server_thread
        memory > xmodify_settings
        memory > xassert_and_parse_html
        memory > xassertRedirects
        memory > x_create_server
        memory > xget_memo
        memory > xassertNumQueries
        memory > x_fixture_teardown
        memory > xassertNoLogs
        memory > x_databases_names
        memory > xserve
        memory > x_setup_and_call
        memory > xconnections_support_transactions
        memory > xlog_message
        memory > xskipIfDBFeature
        memory > xassertFieldOutput
        memory > xsetUpTestData
        memory > xtest
        memory > xassertHTMLEqual
        memory > x_assert_contains
        memory > xget_response
        memory > x_overridden_settings
        memory > xfixtures
        memory > xsetUpClass
        memory > xget_base_dir
        memory > x_assert_form_error
        memory > xassertXMLEqual
        memory > x_remove_databases_failures
        memory > x__init_subclass__
        memory > xlockfile
        memory > xterminate
        memory > x_terminate_thread
        memory > xclient_class
        memory > xassertXMLNotEqual
        memory > x__exit__
        memory > xassertTemplateNotUsed
        memory > xsettings
        memory > xget_base_url
        memory > xassertQuerysetEqual
        memory > xassertJSONEqual
        memory > x_enter_atomics
        memory > x_databases_support_transactions
        memory > xhost
        memory > xlive_server_url
        memory > xassertContains
        memory > x__enter__
        memory > x_assert_template_used
        memory > x_disallowed_database_msg
        memory > xto_list
        memory > xassertNotContains
        memory > x_rollback_atomics
        memory > xmemo_attr
        memory > x_should_check_constraints
        memory > x_should_handle
        memory > x__get__
        memory > x__all__
        memory > xassertInHTML
        memory > xrun
        memory > x_fixture_setup
        memory > xassertURLEqual
        memory > x_disallowed_connection_methods
        memory > x_post_teardown
        memory > xassertFormError
        memory > xassertWarnsMessage
        memory > x__init__
        memory > xserver_class
        memory > x_deferredSkip
        memory > x_make_connections_override
        memory > xskipUnlessAnyDBFeature
        memory > x_modified_settings
        memory > xport
        memory > xskipUnlessDBFeature
        memory > x_add_databases_failures
        memory > xadd_condition
        memory > xassertFormsetError
        memory > xpatch_signature
        memory > xassertRaisesMessage
        memory > xstatic_handler
        memory > x_get_template_used
        memory > xavailable_apps
        memory > xreset_sequences
        memory > x_assert_raises_or_warns_cm
        memory > x_reset_sequences
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x__all__.write (((unsupported)).apply ("TestCase") ("TransactionTestCase") ("SimpleTestCase") ("skipIfDBFeature") ("skipUnlessDBFeature"))
            xto_list.write
              [xvalue]
                seq > @
                  seq
                    unsupported
                    ((((xisinstance)).apply ((xvalue)) ((xlist))).not).if
                      xvalue.write (((unsupported)).apply ((xvalue)))
                    (((unsupported)).apply ((xvalue)))
            xassert_and_parse_html.write
              [xself xhtml xuser_msg xmsg]
                memory > xstandardMsg
                memory > xdom
                seq > @
                  seq
                    (((unsupported)).apply ((xHTMLParseError)))
                      xdom.write (((xparse_html)).apply ((xhtml)))
                      seq
                        xstandardMsg.write ("%sn%s".mod (((unsupported)).apply ((xmsg)) ((xe))))
                        bogusForceDataize.write ((((xself).xfail)).apply (((((xself).x_formatMessage)).apply ((xuser_msg)) ((xstandardMsg)))))
                    (((unsupported)).apply ((xdom)))
            (((unsupported)).apply ((xCaptureQueriesContext)))
              seq
                x__init__.write
                  [xself xtest_case xnum xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xtest_case)) ((xtest_case)))
                        (((unsupported)).apply (((xself).xnum)) ((xnum)))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xconnection)))
                x__exit__.write
                  [xself xexc_type xexc_value xtraceback]
                    memory > xexecuted
                    seq > @
                      seq
                        bogusForceDataize.write ((((((xsuper)).apply).x__exit__)).apply ((xexc_type)) ((xexc_value)) ((xtraceback)))
                        (((unsupported)).apply ((xexc_type)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply)
                        xexecuted.write (((xlen)).apply ((xself)))
                        bogusForceDataize.write (((((xself).xtest_case).xassertEqual)).apply ((xexecuted)) (((xself).xnum)) (("%d queries executed, %d expectednCaptured queries were:n%s".mod (((unsupported)).apply ((xexecuted)) (((xself).xnum)) (((("n".xjoin)).apply ((((unsupported)).apply (("%d. %s".mod (((unsupported)).apply ((xi)) ((((unsupported)).apply ((xquery)) ("sql")))))) ((((unsupported)).apply ((xi)) ((xquery)))) ((((unsupported)).apply ((xenumerate)) (((xself).xcaptured_queries)) (1)))))))))))
            (((unsupported)).apply)
              seq
                x__init__.write
                  [xself xtest_case xtemplate_name xmsg_prefix xcount]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xtest_case)) ((xtest_case)))
                        (((unsupported)).apply (((xself).xtemplate_name)) ((xtemplate_name)))
                        (((unsupported)).apply (((xself).xmsg_prefix)) ((xmsg_prefix)))
                        (((unsupported)).apply (((xself).xcount)) ((xcount)))
                        (((unsupported)).apply (((xself).xrendered_templates)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xrendered_template_names)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xcontext)) ((((xContextList)).apply)))
                xon_template_render.write
                  [xself xsender xsignal xtemplate xcontext]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write (((((xself).xrendered_templates).xappend)).apply ((xtemplate)))
                        bogusForceDataize.write (((((xself).xrendered_template_names).xappend)).apply (((xtemplate).xname)))
                        bogusForceDataize.write (((((xself).xcontext).xappend)).apply ((((xcopy)).apply ((xcontext)))))
                xtest.write
                  [xself]
                    seq > @
                      bogusForceDataize.write (((((xself).xtest_case).x_assert_template_used)).apply (((xself).xtemplate_name)) (((xself).xrendered_template_names)) (((xself).xmsg_prefix)) (((xself).xcount)))
                x__enter__.write
                  [xself]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xtemplate_rendered).xconnect)).apply (((xself).xon_template_render)))
                        (((unsupported)).apply ((xself)))
                x__exit__.write
                  [xself xexc_type xexc_value xtraceback]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xtemplate_rendered).xdisconnect)).apply (((xself).xon_template_render)))
                        (((unsupported)).apply ((xexc_type)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xtest)).apply)
            (((unsupported)).apply ((x_AssertTemplateUsedContext)))
              xtest.write
                [xself]
                  seq > @
                    bogusForceDataize.write (((((xself).xtest_case).xassertFalse)).apply ((((unsupported)).apply (((xself).xtemplate_name)) (((xself).xrendered_template_names)))) ("{self.msg_prefix}Template '{self.template_name}' was used unexpectedly in rendering the response"))
            (((unsupported)).apply ((xAssertionError)))
            (((unsupported)).apply)
              seq
                x__init__.write
                  [xself xwrapped xmessage]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xwrapped)) ((xwrapped)))
                        (((unsupported)).apply (((xself).xmessage)) ((xmessage)))
                x__call__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xDatabaseOperationForbidden)).apply (((xself).xmessage)))))
            (((unsupported)).apply)
              seq
                xassertFormError.write
                  [xself xresponse xform xfield xerrors xmsg_prefix]
                    memory > xfound_form
                    memory > xcontexts
                    memory > xwarning_msg
                    memory > xfull_msg_prefix
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xwarning_msg.write "Passing response to assertFormError() is deprecated. Use the form object directly: assertFormError(response.context[{form!r}], {field!r}, ...)"
                        (((unsupported)).apply (((xwarnings).xwarn)) ((xwarning_msg)) ((xRemovedInDjango50Warning)) (2))
                        xfull_msg_prefix.write ((xmsg_prefix).if "{msg_prefix}: " "")
                        xcontexts.write ((((unsupported)).apply (((xresponse).xcontext)) ("None: is there a None literal in the EO language?")).if (((xto_list)).apply (((xresponse).xcontext))) (((unsupported)).apply))
                        ((xcontexts).not).if
                          bogusForceDataize.write ((((xself).xfail)).apply ("{full_msg_prefix}Response did not use any contexts to render the response"))
                        xfound_form.write FALSE
                        (((unsupported)).apply ((((unsupported)).apply ((xi)) ((xcontext)))) ((((xenumerate)).apply ((xcontexts)))))
                          seq
                            (((unsupported)).apply ((xform)) ((xcontext))).if
                              (((unsupported)).apply)
                            xfound_form.write TRUE
                            (((unsupported)).apply (((xself).xassertFormError)) ((((unsupported)).apply ((xcontext)) ((xform)))) ((xfield)) ((xerrors)) ((xmsg_prefix)))
                        ((xfound_form).not).if
                          bogusForceDataize.write ((((xself).xfail)).apply ("{full_msg_prefix}The form '{form}' was not used to render the response"))
                xassertFormsetError.write
                  [xself xresponse xformset xform_index xfield xerrors xmsg_prefix]
                    memory > xcontexts
                    memory > xfound_formset
                    memory > xwarning_msg
                    memory > xfull_msg_prefix
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xwarning_msg.write "Passing response to assertFormsetError() is deprecated. Use the formset object directly: assertFormsetError(response.context[{formset!r}], {form_index!r}, ...)"
                        (((unsupported)).apply (((xwarnings).xwarn)) ((xwarning_msg)) ((xRemovedInDjango50Warning)) (2))
                        xfull_msg_prefix.write ((xmsg_prefix).if "{msg_prefix}: " "")
                        xcontexts.write ((((unsupported)).apply (((xresponse).xcontext)) ("None: is there a None literal in the EO language?")).if (((xto_list)).apply (((xresponse).xcontext))) (((unsupported)).apply))
                        ((xcontexts).not).if
                          bogusForceDataize.write ((((xself).xfail)).apply ("{full_msg_prefix}Response did not use any contexts to render the response"))
                        xfound_formset.write FALSE
                        (((unsupported)).apply ((((unsupported)).apply ((xi)) ((xcontext)))) ((((xenumerate)).apply ((xcontexts)))))
                          seq
                            ((((unsupported)).apply ((xformset)) ((xcontext))).or ((((xhasattr)).apply ((((unsupported)).apply ((xcontext)) ((xformset)))) ("forms")).not)).if
                              (((unsupported)).apply)
                            xfound_formset.write TRUE
                            bogusForceDataize.write ((((xself).xassertFormsetError)).apply ((((unsupported)).apply ((xcontext)) ((xformset)))) ((xform_index)) ((xfield)) ((xerrors)) ((xmsg_prefix)))
                        ((xfound_formset).not).if
                          bogusForceDataize.write ((((xself).xfail)).apply ("{full_msg_prefix}The formset '{formset}' was not used to render the response"))
                xpatch_signature.write
                  [xcls xnew_method]
                    memory > xpatched_method
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xpatched_method.write
                          [xself]
                            memory > xold_signature
                            memory > xnew_bound_args
                            memory > xold_bound_args
                            memory > xnew_signature
                            memory > xold_method
                            seq > @
                              (((unsupported)).apply)
                                xold_method.write (((xgetattr)).apply ((xcls)) (((xnew_method).x__name__)))
                                xold_signature.write ((((xinspect).xsignature)).apply ((xold_method)))
                                (((unsupported)).apply ((xTypeError)))
                                  xold_bound_args.write ((((xold_signature).xbind)).apply ((xself)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                                  (((unsupported)).apply ((((xnew_method)).apply ((xself)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                                xnew_signature.write ((((xinspect).xsignature)).apply ((xnew_method)))
                                (((unsupported)).apply ((xTypeError)))
                                  xnew_bound_args.write ((((xnew_signature).xbind)).apply ((xself)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                                  (((unsupported)).apply ((((xold_method)).apply ((xself)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                                (((unsupported)).apply (((((unsupported)).apply (((xold_bound_args).xargs)) (1)).eq (((unsupported)).apply (((xnew_bound_args).xargs)) (1)))))
                                (((xhasattr)).apply ((((unsupported)).apply (((xold_bound_args).xargs)) (1))) ("context")).if
                                  (((unsupported)).apply ((((xold_method)).apply ((xself)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                                  (((xisinstance)).apply ((((unsupported)).apply (((xold_bound_args).xargs)) (1))) ((xHttpResponseBase))).if
                                    (((unsupported)).apply ((((xValueError)).apply ("{old_method.__name__}() is only usable on responses fetched using the Django test Client."))))
                                    (((unsupported)).apply ((((xnew_method)).apply ((xself)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                        (((unsupported)).apply ((xpatched_method)))
            (((unsupported)).apply (((xunittest).xTestCase)))
              seq
                xclient_class.write (xClient)
                xasync_client_class.write (xAsyncClient)
                x_overridden_settings.write "None: is there a None literal in the EO language?"
                x_modified_settings.write "None: is there a None literal in the EO language?"
                xdatabases.write (((xset)).apply)
                x_disallowed_database_msg.write "Database %(operation)s to %(alias)r are not allowed in SimpleTestCase subclasses. Either subclass TestCase or TransactionTestCase to ensure proper test isolation or add %(alias)r to %(test)s.databases to silence this failure."
                x_disallowed_connection_methods.write (((unsupported)).apply ((((unsupported)).apply ("connect") ("connections"))) ((((unsupported)).apply ("temporary_connection") ("connections"))) ((((unsupported)).apply ("cursor") ("queries"))) ((((unsupported)).apply ("chunked_cursor") ("queries"))))
                xsetUpClass.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).xsetUpClass)).apply)
                        ((xcls).x_overridden_settings).if
                          seq
                            (((unsupported)).apply (((xcls).x_cls_overridden_context)) ((((xoverride_settings)).apply ((((unsupported)).apply (((xcls).x_overridden_settings)))))))
                            bogusForceDataize.write (((((xcls).x_cls_overridden_context).xenable)).apply)
                            bogusForceDataize.write ((((xcls).xaddClassCleanup)).apply ((((xcls).x_cls_overridden_context).xdisable)))
                        ((xcls).x_modified_settings).if
                          seq
                            (((unsupported)).apply (((xcls).x_cls_modified_context)) ((((xmodify_settings)).apply (((xcls).x_modified_settings)))))
                            bogusForceDataize.write (((((xcls).x_cls_modified_context).xenable)).apply)
                            bogusForceDataize.write ((((xcls).xaddClassCleanup)).apply ((((xcls).x_cls_modified_context).xdisable)))
                        bogusForceDataize.write ((((xcls).x_add_databases_failures)).apply)
                        bogusForceDataize.write ((((xcls).xaddClassCleanup)).apply (((xcls).x_remove_databases_failures)))
                x_validate_databases.write
                  [xcls]
                    memory > xmessage
                    memory > xclose_matches
                    seq > @
                      (((unsupported)).apply)
                        (((xcls).xdatabases).eq "__all__").if
                          (((unsupported)).apply ((((xfrozenset)).apply ((xconnections)))))
                        (((unsupported)).apply ((xalias)) (((xcls).xdatabases)))
                          (((unsupported)).apply ((xalias)) ((xconnections))).if
                            seq
                              xmessage.write ("%s.%s.databases refers to %r which is not defined in settings.DATABASES.".mod (((unsupported)).apply (((xcls).x__module__)) (((xcls).x__qualname__)) ((xalias))))
                              xclose_matches.write (((xget_close_matches)).apply ((xalias)) ((((xlist)).apply ((xconnections)))))
                              (xclose_matches).if
                                (((unsupported)).apply ((xmessage)) ((" Did you mean %r?".mod (((unsupported)).apply ((xclose_matches)) (0)))))
                              (((unsupported)).apply ((((xImproperlyConfigured)).apply ((xmessage)))))
                        (((unsupported)).apply ((((xfrozenset)).apply (((xcls).xdatabases)))))
                x_add_databases_failures.write
                  [xcls]
                    memory > xmessage
                    memory > xmethod
                    memory > xconnection
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xcls).xdatabases)) (((((xcls).x_validate_databases)).apply)))
                        (((unsupported)).apply ((xalias)) ((xconnections)))
                          seq
                            (((unsupported)).apply ((xalias)) (((xcls).xdatabases))).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xalias)))
                            (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xoperation)))) (((xcls).x_disallowed_connection_methods)))
                              seq
                                xmessage.write (((xcls).x_disallowed_database_msg).mod (((unsupported)).apply ("test") (("%s.%s".mod (((unsupported)).apply (((xcls).x__module__)) (((xcls).x__qualname__))))) ("alias") ((xalias)) ("operation") ((xoperation))))
                                xmethod.write (((xgetattr)).apply ((xconnection)) ((xname)))
                                bogusForceDataize.write (((xsetattr)).apply ((xconnection)) ((xname)) ((((x_DatabaseFailure)).apply ((xmethod)) ((xmessage)))))
                x_remove_databases_failures.write
                  [xcls]
                    memory > xmethod
                    memory > xconnection
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xalias)) ((xconnections)))
                          seq
                            (((unsupported)).apply ((xalias)) (((xcls).xdatabases))).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xalias)))
                            (((unsupported)).apply ((((unsupported)).apply ((xname)) ((x_)))) (((xcls).x_disallowed_connection_methods)))
                              seq
                                xmethod.write (((xgetattr)).apply ((xconnection)) ((xname)))
                                bogusForceDataize.write (((xsetattr)).apply ((xconnection)) ((xname)) (((xmethod).xwrapped)))
                x__call__.write
                  [xself xresult]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).x_setup_and_call)).apply ((xresult)))
                xdebug.write
                  [xself]
                    memory > xdebug_result
                    seq > @
                      seq
                        unsupported
                        xdebug_result.write (((x_DebugResult)).apply)
                        (((unsupported)).apply (((xself).x_setup_and_call)) ((xdebug_result)) (TRUE))
                x_setup_and_call.write
                  [xself xresult xdebug]
                    memory > xtestMethod
                    memory > xskipped
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xtestMethod.write (((xgetattr)).apply ((xself)) (((xself).x_testMethodName)))
                        xskipped.write ((((xgetattr)).apply (((xself).x__class__)) ("__unittest_skip__") (FALSE)).or (((xgetattr)).apply ((xtestMethod)) ("__unittest_skip__") (FALSE)))
                        ((((xasyncio).xiscoroutinefunction)).apply ((xtestMethod))).if
                          bogusForceDataize.write (((xsetattr)).apply ((xself)) (((xself).x_testMethodName)) ((((xasync_to_sync)).apply ((xtestMethod)))))
                        ((xskipped).not).if
                          (((unsupported)).apply ((xException)))
                            bogusForceDataize.write ((((xself).x_pre_setup)).apply)
                            seq
                              (xdebug).if
                                (((unsupported)).apply)
                              bogusForceDataize.write ((((xresult).xaddError)).apply ((xself)) (((((xsys).xexc_info)).apply)))
                              (((unsupported)).apply)
                        (xdebug).if
                          bogusForceDataize.write ((((((xsuper)).apply).xdebug)).apply)
                          bogusForceDataize.write ((((((xsuper)).apply).x__call__)).apply ((xresult)))
                        ((xskipped).not).if
                          (((unsupported)).apply ((xException)))
                            bogusForceDataize.write ((((xself).x_post_teardown)).apply)
                            seq
                              (xdebug).if
                                (((unsupported)).apply)
                              bogusForceDataize.write ((((xresult).xaddError)).apply ((xself)) (((((xsys).xexc_info)).apply)))
                              (((unsupported)).apply)
                x_pre_setup.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xclient)) (((((xself).xclient_class)).apply)))
                        (((unsupported)).apply (((xself).xasync_client)) (((((xself).xasync_client_class)).apply)))
                        (((unsupported)).apply (((xmail).xoutbox)) ((((unsupported)).apply)))
                x_post_teardown.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                xsettings.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xoverride_settings)).apply ((((unsupported)).apply ((xkwargs)))))))
                xmodify_settings.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xmodify_settings)).apply ((((unsupported)).apply ((xkwargs)))))))
                xassertRedirects.write
                  [xself xresponse xexpected_url xstatus_code xtarget_status_code xmsg_prefix xfetch_redirect_response]
                    memory > xextra
                    memory > xpath
                    memory > xredirect_response
                    memory > xurl
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (xmsg_prefix).if
                          (((unsupported)).apply ((xmsg_prefix)) (": "))
                        (((xhasattr)).apply ((xresponse)) ("redirect_chain")).if
                          seq
                            bogusForceDataize.write ((((xself).xassertTrue)).apply (((xresponse).xredirect_chain)) (((xmsg_prefix).sub ("Response didn't redirect as expected: Response code was %d (expected %d)".mod (((unsupported)).apply (((xresponse).xstatus_code)) ((xstatus_code)))))))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ((((unsupported)).apply ((((unsupported)).apply (((xresponse).xredirect_chain)) (0))) (1))) ((xstatus_code)) (((xmsg_prefix).sub ("Initial response didn't redirect as expected: Response code was %d (expected %d)".mod (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xresponse).xredirect_chain)) (0))) (1))) ((xstatus_code)))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xurl)) ((xstatus_code)))) ((((unsupported)).apply (((xresponse).xredirect_chain)) ((1.neg)))))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply (((xresponse).xstatus_code)) ((xtarget_status_code)) (((xmsg_prefix).sub ("Response didn't redirect as expected: Final Response code was %d (expected %d)".mod (((unsupported)).apply (((xresponse).xstatus_code)) ((xtarget_status_code)))))))
                          seq
                            bogusForceDataize.write ((((xself).xassertEqual)).apply (((xresponse).xstatus_code)) ((xstatus_code)) (((xmsg_prefix).sub ("Response didn't redirect as expected: Response code was %d (expected %d)".mod (((unsupported)).apply (((xresponse).xstatus_code)) ((xstatus_code)))))))
                            xurl.write ((xresponse).xurl)
                            (((unsupported)).apply ((((unsupported)).apply ((xscheme)) ((xnetloc)) ((xpath)) ((xquery)) ((xfragment)))) ((((xurlsplit)).apply ((xurl)))))
                            (((((xpath).xstartswith)).apply ("/")).not).if
                              seq
                                xurl.write (((xurljoin)).apply ((((unsupported)).apply (((xresponse).xrequest)) ("PATH_INFO"))) ((xurl)))
                                xpath.write (((xurljoin)).apply ((((unsupported)).apply (((xresponse).xrequest)) ("PATH_INFO"))) ((xpath)))
                            (xfetch_redirect_response).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xdomain)) ((xport)))) ((((xsplit_domain_port)).apply ((xnetloc)))))
                                ((xdomain).and ((((xvalidate_host)).apply ((xdomain)) (((xsettings).xALLOWED_HOSTS))).not)).if
                                  (((unsupported)).apply ((((xValueError)).apply (("The test client is unable to fetch remote URLs (got %s). If the host is served by Django, add '%s' to ALLOWED_HOSTS. Otherwise, use assertRedirects(..., fetch_redirect_response=False).".mod (((unsupported)).apply ((xurl)) ((xdomain))))))))
                                xextra.write ((((xresponse).xclient).xextra).or (((unsupported)).apply))
                                xredirect_response.write (((unsupported)).apply ((((xresponse).xclient).xget)) ((xpath)) ((((xQueryDict)).apply ((xquery)))) (((xscheme).eq "https")) ((((unsupported)).apply ((xextra)))))
                                bogusForceDataize.write ((((xself).xassertEqual)).apply (((xredirect_response).xstatus_code)) ((xtarget_status_code)) (((xmsg_prefix).sub ("Couldn't retrieve redirection page '%s': response code was %d (expected %d)".mod (((unsupported)).apply ((xpath)) (((xredirect_response).xstatus_code)) ((xtarget_status_code)))))))
                        bogusForceDataize.write ((((xself).xassertURLEqual)).apply ((xurl)) ((xexpected_url)) (((xmsg_prefix).sub ("Response redirected to '%s', expected '%s'".mod (((unsupported)).apply ((xurl)) ((xexpected_url)))))))
                xassertURLEqual.write
                  [xself xurl1 xurl2 xmsg_prefix]
                    memory > xnormalize
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xnormalize.write
                          [xurl]
                            memory > xquery_parts
                            seq > @
                              seq
                                unsupported
                                xurl.write (((xstr)).apply ((xurl)))
                                (((unsupported)).apply ((((unsupported)).apply ((xscheme)) ((xnetloc)) ((xpath)) ((xparams)) ((xquery)) ((xfragment)))) ((((xurlparse)).apply ((xurl)))))
                                xquery_parts.write (((xsorted)).apply ((((xparse_qsl)).apply ((xquery)))))
                                (((unsupported)).apply ((((xurlunparse)).apply ((((unsupported)).apply ((xscheme)) ((xnetloc)) ((xpath)) ((xparams)) ((((xurlencode)).apply ((xquery_parts)))) ((xfragment)))))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xnormalize)).apply ((xurl1)))) ((((xnormalize)).apply ((xurl2)))) (((xmsg_prefix).sub ("Expected '%s' to equal '%s'.".mod (((unsupported)).apply ((xurl1)) ((xurl2)))))))
                x_assert_contains.write
                  [xself xresponse xtext xstatus_code xmsg_prefix xhtml]
                    memory > xtext_repr
                    memory > xcontent
                    memory > xreal_count
                    seq > @
                      seq
                        (((((xhasattr)).apply ((xresponse)) ("render")).and (((xcallable)).apply (((xresponse).xrender)))).and (((xresponse).xis_rendered).not)).if
                          bogusForceDataize.write ((((xresponse).xrender)).apply)
                        (xmsg_prefix).if
                          (((unsupported)).apply ((xmsg_prefix)) (": "))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xresponse).xstatus_code)) ((xstatus_code)) (((xmsg_prefix).sub ("Couldn't retrieve content: Response code was %d (expected %d)".mod (((unsupported)).apply (((xresponse).xstatus_code)) ((xstatus_code)))))))
                        ((xresponse).xstreaming).if
                          xcontent.write ((("".xjoin)).apply (((xresponse).xstreaming_content)))
                          xcontent.write ((xresponse).xcontent)
                        (((((xisinstance)).apply ((xtext)) ((xbytes))).not).or (xhtml)).if
                          seq
                            xtext.write (((xstr)).apply ((xtext)))
                            xcontent.write ((((xcontent).xdecode)).apply (((xresponse).xcharset)))
                            xtext_repr.write ("'%s'".mod (xtext))
                          xtext_repr.write (((xrepr)).apply ((xtext)))
                        (xhtml).if
                          seq
                            xcontent.write (((xassert_and_parse_html)).apply ((xself)) ((xcontent)) ("None: is there a None literal in the EO language?") ("Response's content is not valid HTML:"))
                            xtext.write (((xassert_and_parse_html)).apply ((xself)) ((xtext)) ("None: is there a None literal in the EO language?") ("Second argument is not valid HTML:"))
                        xreal_count.write ((((xcontent).xcount)).apply ((xtext)))
                        (((unsupported)).apply ((((unsupported)).apply ((xtext_repr)) ((xreal_count)) ((xmsg_prefix)))))
                xassertContains.write
                  [xself xresponse xtext xcount xstatus_code xmsg_prefix xhtml]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xtext_repr)) ((xreal_count)) ((xmsg_prefix)))) (((((xself).x_assert_contains)).apply ((xresponse)) ((xtext)) ((xstatus_code)) ((xmsg_prefix)) ((xhtml)))))
                        (((unsupported)).apply ((xcount)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xself).xassertEqual)).apply ((xreal_count)) ((xcount)) (((xmsg_prefix).sub ("Found %d instances of %s in response (expected %d)".mod (((unsupported)).apply ((xreal_count)) ((xtext_repr)) ((xcount)))))))
                          bogusForceDataize.write ((((xself).xassertTrue)).apply (((xreal_count).neq 0)) (((xmsg_prefix).sub ("Couldn't find %s in response".mod (xtext_repr)))))
                xassertNotContains.write
                  [xself xresponse xtext xstatus_code xmsg_prefix xhtml]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xtext_repr)) ((xreal_count)) ((xmsg_prefix)))) (((((xself).x_assert_contains)).apply ((xresponse)) ((xtext)) ((xstatus_code)) ((xmsg_prefix)) ((xhtml)))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xreal_count)) (0) (((xmsg_prefix).sub ("Response should not contain %s".mod (xtext_repr)))))
                x_check_test_client_response.write
                  [xself xresponse xattribute xmethod_name]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xhasattr)).apply ((xresponse)) ((xattribute))).not).if
                          (((unsupported)).apply ((((xValueError)).apply ("{method_name}() is only usable on responses fetched using the Django test Client."))))
                x_assert_form_error.write
                  [xself xform xfield xerrors xmsg_prefix xform_repr]
                    memory > xfield_errors
                    memory > xfailure_message
                    seq > @
                      seq
                        (((xform).xis_bound).not).if
                          bogusForceDataize.write ((((xself).xfail)).apply ("{msg_prefix}The {form_repr} is not bound, it will never have any errors."))
                        ((((unsupported)).apply ((xfield)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xfield)) (((xform).xfields)))).if
                          bogusForceDataize.write ((((xself).xfail)).apply ("{msg_prefix}The {form_repr} does not contain the field {field!r}."))
                        (((unsupported)).apply ((xfield)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xfield_errors.write ((((xform).xnon_field_errors)).apply)
                            xfailure_message.write "The non-field errors of {form_repr} don't match."
                          seq
                            xfield_errors.write (((((xform).xerrors).xget)).apply ((xfield)) ((((unsupported)).apply)))
                            xfailure_message.write "The errors of field {field!r} on {form_repr} don't match."
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xfield_errors)) ((xerrors)) (((xmsg_prefix).sub (xfailure_message))))
                xassertFormError.write
                  [xself xform xfield xerrors xmsg_prefix]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xerrors)) ("None: is there a None literal in the EO language?")).if
                          seq
                            (((unsupported)).apply (((xwarnings).xwarn)) ("Passing errors=None to assertFormError() is deprecated, use errors=[] instead.") ((xRemovedInDjango50Warning)) (2))
                            xerrors.write (((unsupported)).apply)
                        (xmsg_prefix).if
                          (((unsupported)).apply ((xmsg_prefix)) (": "))
                        xerrors.write (((xto_list)).apply ((xerrors)))
                        bogusForceDataize.write ((((xself).x_assert_form_error)).apply ((xform)) ((xfield)) ((xerrors)) ((xmsg_prefix)) ("form {form!r}"))
                xassertFormsetError.write
                  [xself xformset xform_index xfield xerrors xmsg_prefix]
                    memory > xform_or_forms
                    memory > xform_count
                    memory > xform_repr
                    memory > xfailure_message
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xerrors)) ("None: is there a None literal in the EO language?")).if
                          seq
                            (((unsupported)).apply (((xwarnings).xwarn)) ("Passing errors=None to assertFormsetError() is deprecated, use errors=[] instead.") ((xRemovedInDjango50Warning)) (2))
                            xerrors.write (((unsupported)).apply)
                        ((((unsupported)).apply ((xform_index)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xfield)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((((xValueError)).apply ("You must use field=None with form_index=None."))))
                        (xmsg_prefix).if
                          (((unsupported)).apply ((xmsg_prefix)) (": "))
                        xerrors.write (((xto_list)).apply ((xerrors)))
                        (((xformset).xis_bound).not).if
                          bogusForceDataize.write ((((xself).xfail)).apply ("{msg_prefix}The formset {formset!r} is not bound, it will never have any errors."))
                        ((((unsupported)).apply ((xform_index)) ("None: is there a None literal in the EO language?")).and ((xform_index).geq ((((xformset).xtotal_form_count)).apply))).if
                          seq
                            xform_count.write ((((xformset).xtotal_form_count)).apply)
                            xform_or_forms.write (((xform_count).greater 1).if "forms" "form")
                            bogusForceDataize.write ((((xself).xfail)).apply ("{msg_prefix}The formset {formset!r} only has {form_count} {form_or_forms}."))
                        (((unsupported)).apply ((xform_index)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xform_repr.write "form {form_index} of formset {formset!r}"
                            bogusForceDataize.write ((((xself).x_assert_form_error)).apply ((((unsupported)).apply (((xformset).xforms)) ((xform_index)))) ((xfield)) ((xerrors)) ((xmsg_prefix)) ((xform_repr)))
                          seq
                            xfailure_message.write "The non-form errors of formset {formset!r} don't match."
                            bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xformset).xnon_form_errors)).apply)) ((xerrors)) (((xmsg_prefix).sub (xfailure_message))))
                x_get_template_used.write
                  [xself xresponse xtemplate_name xmsg_prefix xmethod_name]
                    memory > xtemplate_names
                    seq > @
                      seq
                        ((((unsupported)).apply ((xresponse)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xtemplate_name)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((((xTypeError)).apply ("response and/or template_name argument must be provided"))))
                        (xmsg_prefix).if
                          (((unsupported)).apply ((xmsg_prefix)) (": "))
                        ((((unsupported)).apply ((xtemplate_name)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xresponse)) ("None: is there a None literal in the EO language?"))).if
                          bogusForceDataize.write ((((xself).x_check_test_client_response)).apply ((xresponse)) ("templates") ((xmethod_name)))
                        (((((xhasattr)).apply ((xresponse)) ("templates")).not).or ((((unsupported)).apply ((xresponse)) ("None: is there a None literal in the EO language?")).and (xtemplate_name))).if
                          seq
                            (xresponse).if
                              seq
                                xtemplate_name.write (xresponse)
                                xresponse.write "None: is there a None literal in the EO language?"
                            (((unsupported)).apply ((((unsupported)).apply ((xtemplate_name)) ("None: is there a None literal in the EO language?") ((xmsg_prefix)))))
                        xtemplate_names.write (((unsupported)).apply (((xt).xname)) ((xt)) (((xresponse).xtemplates)) ((((unsupported)).apply (((xt).xname)) ("None: is there a None literal in the EO language?"))))
                        (((unsupported)).apply ((((unsupported)).apply ("None: is there a None literal in the EO language?") ((xtemplate_names)) ((xmsg_prefix)))))
                x_assert_template_used.write
                  [xself xtemplate_name xtemplate_names xmsg_prefix xcount]
                    seq > @
                      seq
                        ((xtemplate_names).not).if
                          bogusForceDataize.write ((((xself).xfail)).apply (((xmsg_prefix).sub "No templates used to render the response")))
                        bogusForceDataize.write ((((xself).xassertTrue)).apply ((((unsupported)).apply ((xtemplate_name)) ((xtemplate_names)))) (((xmsg_prefix).sub ("Template '%s' was not a template used to render the response. Actual template(s) used: %s".mod (((unsupported)).apply ((xtemplate_name)) ((((", ".xjoin)).apply ((xtemplate_names)))))))))
                        (((unsupported)).apply ((xcount)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xtemplate_names).xcount)).apply ((xtemplate_name)))) ((xcount)) (((xmsg_prefix).sub ("Template '%s' was expected to be rendered %d time(s) but was actually rendered %d time(s).".mod (((unsupported)).apply ((xtemplate_name)) ((xcount)) (((((xtemplate_names).xcount)).apply ((xtemplate_name)))))))))
                xassertTemplateUsed.write
                  [xself xresponse xtemplate_name xmsg_prefix xcount]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext_mgr_template)) ((xtemplate_names)) ((xmsg_prefix)))) (((((xself).x_get_template_used)).apply ((xresponse)) ((xtemplate_name)) ((xmsg_prefix)) ("assertTemplateUsed"))))
                        (xcontext_mgr_template).if
                          (((unsupported)).apply ((((x_AssertTemplateUsedContext)).apply ((xself)) ((xcontext_mgr_template)) ((xmsg_prefix)) ((xcount)))))
                        bogusForceDataize.write ((((xself).x_assert_template_used)).apply ((xtemplate_name)) ((xtemplate_names)) ((xmsg_prefix)) ((xcount)))
                xassertTemplateNotUsed.write
                  [xself xresponse xtemplate_name xmsg_prefix]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xcontext_mgr_template)) ((xtemplate_names)) ((xmsg_prefix)))) (((((xself).x_get_template_used)).apply ((xresponse)) ((xtemplate_name)) ((xmsg_prefix)) ("assertTemplateNotUsed"))))
                        (xcontext_mgr_template).if
                          (((unsupported)).apply ((((x_AssertTemplateNotUsedContext)).apply ((xself)) ((xcontext_mgr_template)) ((xmsg_prefix)))))
                        bogusForceDataize.write ((((xself).xassertFalse)).apply ((((unsupported)).apply ((xtemplate_name)) ((xtemplate_names)))) (((xmsg_prefix).sub ("Template '%s' was used unexpectedly in rendering the response".mod (xtemplate_name)))))
                x_assert_raises_or_warns_cm.write
                  [xself xfunc xcm_attr xexpected_exception xexpected_message]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xfunc)).apply ((xexpected_exception)))) ((xcm)))
                          (((unsupported)).apply ((xcm)))
                        bogusForceDataize.write ((((xself).xassertIn)).apply ((xexpected_message)) ((((xstr)).apply ((((xgetattr)).apply ((xcm)) ((xcm_attr)))))))
                x_assertFooMessage.write
                  [xself xfunc xcm_attr xexpected_exception xexpected_message]
                    memory > xcm
                    memory > xcallable_obj
                    seq > @
                      (((unsupported)).apply)
                        xcallable_obj.write "None: is there a None literal in the EO language?"
                        (xargs).if
                          (((unsupported)).apply ((((unsupported)).apply ((xcallable_obj)) ((((unsupported)).apply ((xargs)))))) ((xargs)))
                        xcm.write ((((xself).x_assert_raises_or_warns_cm)).apply ((xfunc)) ((xcm_attr)) ((xexpected_exception)) ((xexpected_message)))
                        (((unsupported)).apply ((xcallable_obj)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xcm)))
                        (((unsupported)).apply ((xcm)))
                          bogusForceDataize.write (((xcallable_obj)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                xassertRaisesMessage.write
                  [xself xexpected_exception xexpected_message]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_assertFooMessage)).apply (((xself).xassertRaises)) ("exception") ((xexpected_exception)) ((xexpected_message)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                xassertWarnsMessage.write
                  [xself xexpected_warning xexpected_message]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_assertFooMessage)).apply (((xself).xassertWarns)) ("warning") ((xexpected_warning)) ((xexpected_message)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                ((xPY310).not).if
                  xassertNoLogs.write
                    [xself xlogger xlevel]
                      memory > xmsg
                      memory > xexpected_msg
                      seq > @
                        (((unsupported)).apply)
                          (((unsupported)).apply)
                          (((xisinstance)).apply ((xlevel)) ((xint))).if
                            xlevel.write ((((xlogging).xgetLevelName)).apply ((xlevel)))
                            (((unsupported)).apply ((xlevel)) ("None: is there a None literal in the EO language?")).if
                              xlevel.write "INFO"
                          (((unsupported)).apply ((xAssertionError)))
                            (((unsupported)).apply (((((xself).xassertLogs)).apply ((xlogger)) ((xlevel)))) ((xcm)))
                              (((unsupported)).apply)
                            seq
                              xmsg.write (((unsupported)).apply (((xe).xargs)) (0))
                              xexpected_msg.write "no logs of level {level} or higher triggered on {logger}"
                              ((xmsg).neq (xexpected_msg)).if
                                (((unsupported)).apply ((xe)))
                            bogusForceDataize.write ((((xself).xfail)).apply ("Unexpected logs found: {cm.output!r}"))
                xassertFieldOutput.write
                  [xself xfieldclass xvalid xinvalid xfield_args xfield_kwargs xempty_value]
                    memory > xoptional
                    memory > xerror_required
                    memory > xrequired
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xfield_args)) ("None: is there a None literal in the EO language?")).if
                          xfield_args.write (((unsupported)).apply)
                        (((unsupported)).apply ((xfield_kwargs)) ("None: is there a None literal in the EO language?")).if
                          xfield_kwargs.write (((unsupported)).apply)
                        xrequired.write (((xfieldclass)).apply ((((unsupported)).apply ((xfield_args)))) ((((unsupported)).apply ((xfield_kwargs)))))
                        xoptional.write (((xfieldclass)).apply ((((unsupported)).apply ((xfield_args)))) ((((unsupported)).apply ((((unsupported)).apply ((xfield_kwargs)) ("required") (FALSE))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xinput)) ((xoutput)))) (((((xvalid).xitems)).apply)))
                          seq
                            bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xrequired).xclean)).apply ((xinput)))) ((xoutput)))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xoptional).xclean)).apply ((xinput)))) ((xoutput)))
                        (((unsupported)).apply ((((unsupported)).apply ((xinput)) ((xerrors)))) (((((xinvalid).xitems)).apply)))
                          seq
                            (((unsupported)).apply (((((xself).xassertRaises)).apply ((xValidationError)))) ((xcontext_manager)))
                              bogusForceDataize.write ((((xrequired).xclean)).apply ((xinput)))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcontext_manager).xexception).xmessages)) ((xerrors)))
                            (((unsupported)).apply (((((xself).xassertRaises)).apply ((xValidationError)))) ((xcontext_manager)))
                              bogusForceDataize.write ((((xoptional).xclean)).apply ((xinput)))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcontext_manager).xexception).xmessages)) ((xerrors)))
                        xerror_required.write (((unsupported)).apply ((((unsupported)).apply (((xrequired).xerror_messages)) ("required"))))
                        (((unsupported)).apply ((xe)) (((xrequired).xempty_values)))
                          seq
                            (((unsupported)).apply (((((xself).xassertRaises)).apply ((xValidationError)))) ((xcontext_manager)))
                              bogusForceDataize.write ((((xrequired).xclean)).apply ((xe)))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcontext_manager).xexception).xmessages)) ((xerror_required)))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply (((((xoptional).xclean)).apply ((xe)))) ((xempty_value)))
                        (((xissubclass)).apply ((xfieldclass)) ((xCharField))).if
                          seq
                            bogusForceDataize.write ((((xfield_kwargs).xupdate)).apply ((((unsupported)).apply ("min_length") (2) ("max_length") (20))))
                            bogusForceDataize.write ((((xself).xassertIsInstance)).apply ((((xfieldclass)).apply ((((unsupported)).apply ((xfield_args)))) ((((unsupported)).apply ((xfield_kwargs)))))) ((xfieldclass)))
                xassertHTMLEqual.write
                  [xself xhtml1 xhtml2 xmsg]
                    memory > xdom2
                    memory > xstandardMsg
                    memory > xdiff
                    memory > xdom1
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xdom1.write (((xassert_and_parse_html)).apply ((xself)) ((xhtml1)) ((xmsg)) ("First argument is not valid HTML:"))
                        xdom2.write (((xassert_and_parse_html)).apply ((xself)) ((xhtml2)) ((xmsg)) ("Second argument is not valid HTML:"))
                        ((xdom1).neq (xdom2)).if
                          seq
                            xstandardMsg.write ("%s != %s".mod (((unsupported)).apply ((((xsafe_repr)).apply ((xdom1)) (TRUE))) ((((xsafe_repr)).apply ((xdom2)) (TRUE)))))
                            xdiff.write ("n".sub ((("n".xjoin)).apply (((((xdifflib).xndiff)).apply (((((((xstr)).apply ((xdom1))).xsplitlines)).apply)) (((((((xstr)).apply ((xdom2))).xsplitlines)).apply))))))
                            xstandardMsg.write ((((xself).x_truncateMessage)).apply ((xstandardMsg)) ((xdiff)))
                            bogusForceDataize.write ((((xself).xfail)).apply (((((xself).x_formatMessage)).apply ((xmsg)) ((xstandardMsg)))))
                xassertHTMLNotEqual.write
                  [xself xhtml1 xhtml2 xmsg]
                    memory > xdom2
                    memory > xstandardMsg
                    memory > xdom1
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xdom1.write (((xassert_and_parse_html)).apply ((xself)) ((xhtml1)) ((xmsg)) ("First argument is not valid HTML:"))
                        xdom2.write (((xassert_and_parse_html)).apply ((xself)) ((xhtml2)) ((xmsg)) ("Second argument is not valid HTML:"))
                        ((xdom1).eq (xdom2)).if
                          seq
                            xstandardMsg.write ("%s == %s".mod (((unsupported)).apply ((((xsafe_repr)).apply ((xdom1)) (TRUE))) ((((xsafe_repr)).apply ((xdom2)) (TRUE)))))
                            bogusForceDataize.write ((((xself).xfail)).apply (((((xself).x_formatMessage)).apply ((xmsg)) ((xstandardMsg)))))
                xassertInHTML.write
                  [xself xneedle xhaystack xcount xmsg_prefix]
                    memory > xreal_count
                    seq > @
                      (((unsupported)).apply)
                        xneedle.write (((xassert_and_parse_html)).apply ((xself)) ((xneedle)) ("None: is there a None literal in the EO language?") ("First argument is not valid HTML:"))
                        xhaystack.write (((xassert_and_parse_html)).apply ((xself)) ((xhaystack)) ("None: is there a None literal in the EO language?") ("Second argument is not valid HTML:"))
                        xreal_count.write ((((xhaystack).xcount)).apply ((xneedle)))
                        (((unsupported)).apply ((xcount)) ("None: is there a None literal in the EO language?")).if
                          bogusForceDataize.write ((((xself).xassertEqual)).apply ((xreal_count)) ((xcount)) (((xmsg_prefix).sub ("Found %d instances of '%s' in response (expected %d)".mod (((unsupported)).apply ((xreal_count)) ((xneedle)) ((xcount)))))))
                          bogusForceDataize.write ((((xself).xassertTrue)).apply (((xreal_count).neq 0)) (((xmsg_prefix).sub ("Couldn't find '%s' in response".mod (xneedle)))))
                xassertJSONEqual.write
                  [xself xraw xexpected_data xmsg]
                    memory > xdata
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xjson).xJSONDecodeError)))
                          xdata.write ((((xjson).xloads)).apply ((xraw)))
                          bogusForceDataize.write ((((xself).xfail)).apply (("First argument is not valid JSON: %r".mod (xraw))))
                        (((xisinstance)).apply ((xexpected_data)) ((xstr))).if
                          (((unsupported)).apply ((xValueError)))
                            xexpected_data.write ((((xjson).xloads)).apply ((xexpected_data)))
                            bogusForceDataize.write ((((xself).xfail)).apply (("Second argument is not valid JSON: %r".mod (xexpected_data))))
                        (((unsupported)).apply (((xself).xassertEqual)) ((xdata)) ((xexpected_data)) ((xmsg)))
                xassertJSONNotEqual.write
                  [xself xraw xexpected_data xmsg]
                    memory > xdata
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xjson).xJSONDecodeError)))
                          xdata.write ((((xjson).xloads)).apply ((xraw)))
                          bogusForceDataize.write ((((xself).xfail)).apply (("First argument is not valid JSON: %r".mod (xraw))))
                        (((xisinstance)).apply ((xexpected_data)) ((xstr))).if
                          (((unsupported)).apply (((xjson).xJSONDecodeError)))
                            xexpected_data.write ((((xjson).xloads)).apply ((xexpected_data)))
                            bogusForceDataize.write ((((xself).xfail)).apply (("Second argument is not valid JSON: %r".mod (xexpected_data))))
                        (((unsupported)).apply (((xself).xassertNotEqual)) ((xdata)) ((xexpected_data)) ((xmsg)))
                xassertXMLEqual.write
                  [xself xxml1 xxml2 xmsg]
                    memory > xresult
                    memory > xstandardMsg
                    memory > xdiff
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xException)))
                          xresult.write (((xcompare_xml)).apply ((xxml1)) ((xxml2)))
                          seq
                            xstandardMsg.write ("First or second argument is not valid XMLn%s".mod (xe))
                            bogusForceDataize.write ((((xself).xfail)).apply (((((xself).x_formatMessage)).apply ((xmsg)) ((xstandardMsg)))))
                          ((xresult).not).if
                            seq
                              xstandardMsg.write ("%s != %s".mod (((unsupported)).apply ((((xsafe_repr)).apply ((xxml1)) (TRUE))) ((((xsafe_repr)).apply ((xxml2)) (TRUE)))))
                              xdiff.write ("n".sub ((("n".xjoin)).apply (((((xdifflib).xndiff)).apply (((((xxml1).xsplitlines)).apply)) (((((xxml2).xsplitlines)).apply))))))
                              xstandardMsg.write ((((xself).x_truncateMessage)).apply ((xstandardMsg)) ((xdiff)))
                              bogusForceDataize.write ((((xself).xfail)).apply (((((xself).x_formatMessage)).apply ((xmsg)) ((xstandardMsg)))))
                xassertXMLNotEqual.write
                  [xself xxml1 xxml2 xmsg]
                    memory > xresult
                    memory > xstandardMsg
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xException)))
                          xresult.write (((xcompare_xml)).apply ((xxml1)) ((xxml2)))
                          seq
                            xstandardMsg.write ("First or second argument is not valid XMLn%s".mod (xe))
                            bogusForceDataize.write ((((xself).xfail)).apply (((((xself).x_formatMessage)).apply ((xmsg)) ((xstandardMsg)))))
                          (xresult).if
                            seq
                              xstandardMsg.write ("%s == %s".mod (((unsupported)).apply ((((xsafe_repr)).apply ((xxml1)) (TRUE))) ((((xsafe_repr)).apply ((xxml2)) (TRUE)))))
                              bogusForceDataize.write ((((xself).xfail)).apply (((((xself).x_formatMessage)).apply ((xmsg)) ((xstandardMsg)))))
            (((unsupported)).apply ((xSimpleTestCase)))
              seq
                xreset_sequences.write FALSE
                xavailable_apps.write "None: is there a None literal in the EO language?"
                xfixtures.write "None: is there a None literal in the EO language?"
                xdatabases.write (((unsupported)).apply ((xDEFAULT_DB_ALIAS)))
                x_disallowed_database_msg.write "Database %(operation)s to %(alias)r are not allowed in this test. Add %(alias)r to %(test)s.databases to ensure proper test isolation and silence this failure."
                xserialized_rollback.write FALSE
                x_pre_setup.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x_pre_setup)).apply)
                        (((unsupported)).apply (((xself).xavailable_apps)) ("None: is there a None literal in the EO language?")).if
                          seq
                            bogusForceDataize.write ((((xapps).xset_available_apps)).apply (((xself).xavailable_apps)))
                            (((unsupported)).apply (((xsetting_changed).xsend)) ((((xsettings).x_wrapped).x__class__)) ("INSTALLED_APPS") (((xself).xavailable_apps)) (TRUE))
                            (((unsupported)).apply ((xdb_name)) ((((unsupported)).apply (((xself).x_databases_names)) (FALSE))))
                              (((unsupported)).apply ((xemit_post_migrate_signal)) (0) (FALSE) ((xdb_name)))
                        (((unsupported)).apply ((xException)))
                          bogusForceDataize.write ((((xself).x_fixture_setup)).apply)
                          seq
                            (((unsupported)).apply (((xself).xavailable_apps)) ("None: is there a None literal in the EO language?")).if
                              seq
                                bogusForceDataize.write ((((xapps).xunset_available_apps)).apply)
                                (((unsupported)).apply (((xsetting_changed).xsend)) ((((xsettings).x_wrapped).x__class__)) ("INSTALLED_APPS") (((xsettings).xINSTALLED_APPS)) (FALSE))
                            (((unsupported)).apply)
                        (((unsupported)).apply ((xdb_name)) ((((unsupported)).apply (((xself).x_databases_names)) (FALSE))))
                          bogusForceDataize.write (((((((unsupported)).apply ((xconnections)) ((xdb_name))).xqueries_log).xclear)).apply)
                x_databases_names.write
                  [xcls xinclude_mirrors]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((xalias)) ((xconnections)) (((((unsupported)).apply ((xalias)) (((xcls).xdatabases))).and ((xinclude_mirrors).or ((((unsupported)).apply ((((unsupported)).apply (((((unsupported)).apply ((xconnections)) ((xalias))).xsettings_dict)) ("TEST"))) ("MIRROR")).not)))))))
                x_reset_sequences.write
                  [xself xdb_name]
                    memory > xsql_list
                    memory > xconn
                    seq > @
                      seq
                        xconn.write (((unsupported)).apply ((xconnections)) ((xdb_name)))
                        (((xconn).xfeatures).xsupports_sequence_reset).if
                          seq
                            xsql_list.write (((((xconn).xops).xsequence_reset_by_name_sql)).apply ((((xno_style)).apply)) ((((((xconn).xintrospection).xsequence_list)).apply)))
                            (xsql_list).if
                              (((unsupported)).apply ((((unsupported)).apply (((xtransaction).xatomic)) ((xdb_name)))))
                                (((unsupported)).apply (((((xconn).xcursor)).apply)) ((xcursor)))
                                  (((unsupported)).apply ((xsql)) ((xsql_list)))
                                    bogusForceDataize.write ((((xcursor).xexecute)).apply ((xsql)))
                x_fixture_setup.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((xdb_name)) ((((unsupported)).apply (((xself).x_databases_names)) (FALSE))))
                        seq
                          ((xself).xreset_sequences).if
                            bogusForceDataize.write ((((xself).x_reset_sequences)).apply ((xdb_name)))
                          (((xself).xserialized_rollback).and (((xhasattr)).apply ((((unsupported)).apply ((xconnections)) ((xdb_name)))) ("_test_serialized_contents"))).if
                            seq
                              (((unsupported)).apply (((xself).xavailable_apps)) ("None: is there a None literal in the EO language?")).if
                                bogusForceDataize.write ((((xapps).xunset_available_apps)).apply)
                              bogusForceDataize.write (((((((unsupported)).apply ((xconnections)) ((xdb_name))).xcreation).xdeserialize_db_from_string)).apply (((((unsupported)).apply ((xconnections)) ((xdb_name))).x_test_serialized_contents)))
                              (((unsupported)).apply (((xself).xavailable_apps)) ("None: is there a None literal in the EO language?")).if
                                bogusForceDataize.write ((((xapps).xset_available_apps)).apply (((xself).xavailable_apps)))
                          ((xself).xfixtures).if
                            bogusForceDataize.write (((xcall_command)).apply ("loaddata") ((((unsupported)).apply (((xself).xfixtures)))) ((((unsupported)).apply ((((unsupported)).apply ("verbosity") (0) ("database") ((xdb_name)))))))
                x_should_reload_connections.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (TRUE))
                x_post_teardown.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply)
                          seq
                            bogusForceDataize.write ((((xself).x_fixture_teardown)).apply)
                            bogusForceDataize.write ((((((xsuper)).apply).x_post_teardown)).apply)
                            ((((xself).x_should_reload_connections)).apply).if
                              (((unsupported)).apply ((xconn)) ((((unsupported)).apply (((xconnections).xall)) (TRUE))))
                                bogusForceDataize.write ((((xconn).xclose)).apply)
                          (((unsupported)).apply (((xself).xavailable_apps)) ("None: is there a None literal in the EO language?")).if
                            seq
                              bogusForceDataize.write ((((xapps).xunset_available_apps)).apply)
                              (((unsupported)).apply (((xsetting_changed).xsend)) ((((xsettings).x_wrapped).x__class__)) ("INSTALLED_APPS") (((xsettings).xINSTALLED_APPS)) (FALSE))
                x_fixture_teardown.write
                  [xself]
                    memory > xinhibit_post_migrate
                    seq > @
                      (((unsupported)).apply ((xdb_name)) ((((unsupported)).apply (((xself).x_databases_names)) (FALSE))))
                        seq
                          xinhibit_post_migrate.write ((((unsupported)).apply (((xself).xavailable_apps)) ("None: is there a None literal in the EO language?")).or (((xself).xserialized_rollback).and (((xhasattr)).apply ((((unsupported)).apply ((xconnections)) ((xdb_name)))) ("_test_serialized_contents"))))
                          (((unsupported)).apply ((xcall_command)) ("flush") (0) (FALSE) ((xdb_name)) (FALSE) ((((unsupported)).apply (((xself).xavailable_apps)) ("None: is there a None literal in the EO language?"))) ((xinhibit_post_migrate)))
                xassertQuerysetEqual.write
                  [xself xqs xvalues xtransform xordered xmsg]
                    memory > xitems
                    seq > @
                      (((unsupported)).apply)
                        xvalues.write (((xlist)).apply ((xvalues)))
                        xitems.write (xqs)
                        (((unsupported)).apply ((xtransform)) ("None: is there a None literal in the EO language?")).if
                          xitems.write (((xmap)).apply ((xtransform)) ((xitems)))
                        ((xordered).not).if
                          (((unsupported)).apply ((((unsupported)).apply (((xself).xassertDictEqual)) ((((xCounter)).apply ((xitems)))) ((((xCounter)).apply ((xvalues)))) ((xmsg)))))
                        ((((((xlen)).apply ((xvalues))).greater 1).and (((xhasattr)).apply ((xqs)) ("ordered"))).and (((xqs).xordered).not)).if
                          (((unsupported)).apply ((((xValueError)).apply ("Trying to compare non-ordered queryset against more than one ordered value."))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xassertEqual)) ((((xlist)).apply ((xitems)))) ((xvalues)) ((xmsg)))))
                xassertNumQueries.write
                  [xself xnum xfunc xusing]
                    memory > xconn
                    memory > xcontext
                    seq > @
                      (((unsupported)).apply)
                        xconn.write (((unsupported)).apply ((xconnections)) ((xusing)))
                        xcontext.write (((x_AssertNumQueriesContext)).apply ((xself)) ((xnum)) ((xconn)))
                        (((unsupported)).apply ((xfunc)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xcontext)))
                        (((unsupported)).apply ((xcontext)))
                          bogusForceDataize.write (((xfunc)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
            xconnections_support_transactions.write
              [xaliases]
                memory > xconns
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xconns.write ((((unsupported)).apply ((xaliases)) ("None: is there a None literal in the EO language?")).if ((((xconnections).xall)).apply) (((unsupported)).apply ((((unsupported)).apply ((xconnections)) ((xalias)))) ((xalias)) ((xaliases))))
                    (((unsupported)).apply ((((xall)).apply ((((unsupported)).apply ((((xconn).xfeatures).xsupports_transactions)) ((xconn)) ((xconns)))))))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xmemo_attr.write "_testdata_memo"
                x__init__.write
                  [xself xname xdata]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xname)) ((xname)))
                        (((unsupported)).apply (((xself).xdata)) ((xdata)))
                xget_memo.write
                  [xself xtestcase]
                    memory > xmemo
                    seq > @
                      seq
                        (((unsupported)).apply ((xAttributeError)))
                          xmemo.write (((xgetattr)).apply ((xtestcase)) (((xself).xmemo_attr)))
                          seq
                            xmemo.write (((unsupported)).apply)
                            bogusForceDataize.write (((xsetattr)).apply ((xtestcase)) (((xself).xmemo_attr)) ((xmemo)))
                        (((unsupported)).apply ((xmemo)))
                x__get__.write
                  [xself xinstance xowner]
                    memory > xmemo
                    memory > xdata
                    seq > @
                      seq
                        (((unsupported)).apply ((xinstance)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xdata)))
                        xmemo.write ((((xself).xget_memo)).apply ((xinstance)))
                        xdata.write (((xdeepcopy)).apply (((xself).xdata)) ((xmemo)))
                        bogusForceDataize.write (((xsetattr)).apply ((xinstance)) (((xself).xname)) ((xdata)))
                        (((unsupported)).apply ((xdata)))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<TestData: name=%r, data=%r>".mod (((unsupported)).apply (((xself).xname)) (((xself).xdata))))))
            (((unsupported)).apply ((xTransactionTestCase)))
              seq
                (((unsupported)).apply)
                x_enter_atomics.write
                  [xcls]
                    memory > xatomic
                    memory > xatomics
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xatomics.write (((unsupported)).apply)
                        (((unsupported)).apply ((xdb_name)) (((((xcls).x_databases_names)).apply)))
                          seq
                            xatomic.write (((unsupported)).apply (((xtransaction).xatomic)) ((xdb_name)))
                            (((unsupported)).apply (((xatomic).x_from_testcase)) (TRUE))
                            bogusForceDataize.write ((((xatomic).x__enter__)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xatomics)) ((xdb_name)))) ((xatomic)))
                        (((unsupported)).apply ((xatomics)))
                x_rollback_atomics.write
                  [xcls xatomics]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        (((unsupported)).apply ((xdb_name)) ((((xreversed)).apply (((((xcls).x_databases_names)).apply)))))
                          seq
                            (((unsupported)).apply (((xtransaction).xset_rollback)) (TRUE) ((xdb_name)))
                            bogusForceDataize.write ((((((unsupported)).apply ((xatomics)) ((xdb_name))).x__exit__)).apply ("None: is there a None literal in the EO language?") ("None: is there a None literal in the EO language?") ("None: is there a None literal in the EO language?"))
                x_databases_support_transactions.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xconnections_support_transactions)).apply (((xcls).xdatabases)))))
                xsetUpClass.write
                  [xcls]
                    memory > xpre_attrs
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).xsetUpClass)).apply)
                        (((((xcls).x_databases_support_transactions)).apply).not).if
                          (((unsupported)).apply)
                        (((unsupported)).apply (((xcls).xcls_atomics)) (((((xcls).x_enter_atomics)).apply)))
                        ((xcls).xfixtures).if
                          (((unsupported)).apply ((xdb_name)) ((((unsupported)).apply (((xcls).x_databases_names)) (FALSE))))
                            (((unsupported)).apply ((xException)))
                              bogusForceDataize.write (((xcall_command)).apply ("loaddata") ((((unsupported)).apply (((xcls).xfixtures)))) ((((unsupported)).apply ((((unsupported)).apply ("verbosity") (0) ("database") ((xdb_name)))))))
                              seq
                                bogusForceDataize.write ((((xcls).x_rollback_atomics)).apply (((xcls).xcls_atomics)))
                                (((unsupported)).apply)
                        xpre_attrs.write (((((xcls).x__dict__).xcopy)).apply)
                        (((unsupported)).apply ((xException)))
                          bogusForceDataize.write ((((xcls).xsetUpTestData)).apply)
                          seq
                            bogusForceDataize.write ((((xcls).x_rollback_atomics)).apply (((xcls).xcls_atomics)))
                            (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xvalue)))) ((((((xcls).x__dict__).xitems)).apply)))
                          (((unsupported)).apply ((xvalue)) (((((xpre_attrs).xget)).apply ((xname))))).if
                            bogusForceDataize.write (((xsetattr)).apply ((xcls)) ((xname)) ((((xTestData)).apply ((xname)) ((xvalue)))))
                xtearDownClass.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        ((((xcls).x_databases_support_transactions)).apply).if
                          seq
                            bogusForceDataize.write ((((xcls).x_rollback_atomics)).apply (((xcls).xcls_atomics)))
                            (((unsupported)).apply ((xconn)) ((((unsupported)).apply (((xconnections).xall)) (TRUE))))
                              bogusForceDataize.write ((((xconn).xclose)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).xtearDownClass)).apply)
                xsetUpTestData.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                x_should_reload_connections.write
                  [xself]
                    seq > @
                      seq
                        ((((xself).x_databases_support_transactions)).apply).if
                          (((unsupported)).apply (FALSE))
                        (((unsupported)).apply (((((((xsuper)).apply).x_should_reload_connections)).apply)))
                x_fixture_setup.write
                  [xself]
                    seq > @
                      seq
                        (((((xself).x_databases_support_transactions)).apply).not).if
                          seq
                            bogusForceDataize.write ((((xself).xsetUpTestData)).apply)
                            (((unsupported)).apply (((((((xsuper)).apply).x_fixture_setup)).apply)))
                        ((xself).xreset_sequences).if
                          (((unsupported)).apply ((((xTypeError)).apply ("reset_sequences cannot be used on TestCase instances"))))
                        (((unsupported)).apply (((xself).xatomics)) (((((xself).x_enter_atomics)).apply)))
                x_fixture_teardown.write
                  [xself]
                    seq > @
                      seq
                        (((((xself).x_databases_support_transactions)).apply).not).if
                          (((unsupported)).apply (((((((xsuper)).apply).x_fixture_teardown)).apply)))
                        (((unsupported)).apply)
                          (((unsupported)).apply ((xdb_name)) ((((xreversed)).apply (((((xself).x_databases_names)).apply)))))
                            ((((xself).x_should_check_constraints)).apply ((((unsupported)).apply ((xconnections)) ((xdb_name))))).if
                              bogusForceDataize.write ((((((unsupported)).apply ((xconnections)) ((xdb_name))).xcheck_constraints)).apply)
                          bogusForceDataize.write ((((xself).x_rollback_atomics)).apply (((xself).xatomics)))
                x_should_check_constraints.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((((xconnection).xfeatures).xcan_defer_constraint_checks).and (((xconnection).xneeds_rollback).not)).and ((((xconnection).xis_usable)).apply))))
                xcaptureOnCommitCallbacks.write
                  [xcls xusing xexecute]
                    memory > xcallback_count
                    memory > xstart_count
                    memory > xcallbacks
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xcallbacks.write (((unsupported)).apply)
                        xstart_count.write (((xlen)).apply (((((unsupported)).apply ((xconnections)) ((xusing))).xrun_on_commit)))
                        (((unsupported)).apply)
                          (((unsupported)).apply ((xcallbacks)))
                          while.
                            TRUE
                            [unused]
                              seq > @
                                seq
                                  xcallback_count.write (((xlen)).apply (((((unsupported)).apply ((xconnections)) ((xusing))).xrun_on_commit)))
                                  (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xcallback)))) ((((unsupported)).apply (((((unsupported)).apply ((xconnections)) ((xusing))).xrun_on_commit)) ((((unsupported)).apply ((xstart_count)))))))
                                    seq
                                      bogusForceDataize.write ((((xcallbacks).xappend)).apply ((xcallback)))
                                      (xexecute).if
                                        bogusForceDataize.write (((xcallback)).apply)
                                  ((xcallback_count).eq (((xlen)).apply (((((unsupported)).apply ((xconnections)) ((xusing))).xrun_on_commit)))).if
                                    (((unsupported)).apply)
                                  xstart_count.write (xcallback_count)
            (((unsupported)).apply)
              seq
                unsupported
                x__init__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xconditions)) ((xconditions)))
                xadd_condition.write
                  [xself xcondition xreason]
                    seq > @
                      (((unsupported)).apply (((((xself).x__class__)).apply ((((unsupported)).apply (((xself).xconditions)))) ((((unsupported)).apply ((xcondition)) ((xreason)))))))
                x__get__.write
                  [xself xinstance xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((xany)).apply ((((unsupported)).apply ((((xgetattr)).apply ((xbase)) ("__unittest_skip__") (FALSE))) ((xbase)) (((xcls).x__bases__))))).if
                          (((unsupported)).apply (TRUE))
                        (((unsupported)).apply ((((unsupported)).apply ((xcondition)) ((xreason)))) (((xself).xconditions)))
                          (((xcondition)).apply).if
                            seq
                              (((unsupported)).apply (((xcls).x__unittest_skip__)) (TRUE))
                              (((unsupported)).apply (((xcls).x__unittest_skip_why__)) ((xreason)))
                              (((unsupported)).apply (TRUE))
                        (((unsupported)).apply (FALSE))
            x_deferredSkip.write
              [xcondition xreason xname]
                memory > xdecorator
                seq > @
                  seq
                    xdecorator.write
                      [xtest_func]
                        memory > xskip_wrapper
                        memory > xcondition
                        memory > xskip
                        memory > xtest_item
                        memory > xdatabases
                        seq > @
                          seq
                            (((unsupported)).apply)
                            (((((xisinstance)).apply ((xtest_func)) ((xtype))).and (((xissubclass)).apply ((xtest_func)) (((xunittest).xTestCase)))).not).if
                              seq
                                xskip_wrapper.write
                                  []
                                    seq > @
                                      (((unsupported)).apply)
                                        (((xargs).and (((xisinstance)).apply ((((unsupported)).apply ((xargs)) (0))) (((xunittest).xTestCase)))).and (((unsupported)).apply (((xconnection).xalias)) ((((xgetattr)).apply ((((unsupported)).apply ((xargs)) (0))) ("databases") ((((unsupported)).apply)))))).if
                                          (((unsupported)).apply ((((xValueError)).apply (("%s cannot be used on %s as %s doesn't allow queries against the %r database.".mod (((unsupported)).apply ((xname)) ((((unsupported)).apply ((xargs)) (0))) ((((((unsupported)).apply ((xargs)) (0)).x__class__).x__qualname__)) (((xconnection).xalias))))))))
                                        (((xcondition)).apply).if
                                          (((unsupported)).apply (((((xunittest).xSkipTest)).apply ((xreason)))))
                                        (((unsupported)).apply ((((xtest_func)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                                xtest_item.write (xskip_wrapper)
                              seq
                                xtest_item.write (xtest_func)
                                xdatabases.write (((xgetattr)).apply ((xtest_item)) ("databases") ("None: is there a None literal in the EO language?"))
                                (((xdatabases).not).or (((unsupported)).apply (((xconnection).xalias)) ((xdatabases)))).if
                                  xcondition.write
                                    []
                                      seq > @
                                        (((unsupported)).apply ((((xValueError)).apply (("%s cannot be used on %s as it doesn't allow queries against the '%s' database.".mod (((unsupported)).apply ((xname)) ((xtest_item)) (((xconnection).xalias))))))))
                                xskip.write (((((xtest_func).x__dict__).xget)).apply ("__unittest_skip__"))
                                (((xisinstance)).apply ((xskip)) ((xCheckCondition))).if
                                  (((unsupported)).apply (((xtest_item).x__unittest_skip__)) (((((xskip).xadd_condition)).apply ((xcondition)) ((xreason)))))
                                  (((unsupported)).apply ((xskip)) (TRUE)).if
                                    (((unsupported)).apply (((xtest_item).x__unittest_skip__)) ((((xCheckCondition)).apply ((((unsupported)).apply ((xcondition)) ((xreason)))))))
                            (((unsupported)).apply ((xtest_item)))
                    (((unsupported)).apply ((xdecorator)))
            xskipIfDBFeature.write
              []
                seq > @
                  (((unsupported)).apply)
                    unsupported
                    (((unsupported)).apply ((((x_deferredSkip)).apply ((((unsupported)).apply ((((xany)).apply ((((unsupported)).apply ((((xgetattr)).apply (((xconnection).xfeatures)) ((xfeature)) (FALSE))) ((xfeature)) ((xfeatures)))))))) (("Database has feature(s) %s".mod (((", ".xjoin)).apply ((xfeatures))))) ("skipIfDBFeature"))))
            xskipUnlessDBFeature.write
              []
                seq > @
                  (((unsupported)).apply)
                    unsupported
                    (((unsupported)).apply ((((x_deferredSkip)).apply ((((unsupported)).apply (((((xall)).apply ((((unsupported)).apply ((((xgetattr)).apply (((xconnection).xfeatures)) ((xfeature)) (FALSE))) ((xfeature)) ((xfeatures))))).not)))) (("Database doesn't support feature(s): %s".mod (((", ".xjoin)).apply ((xfeatures))))) ("skipUnlessDBFeature"))))
            xskipUnlessAnyDBFeature.write
              []
                seq > @
                  (((unsupported)).apply)
                    unsupported
                    (((unsupported)).apply ((((x_deferredSkip)).apply ((((unsupported)).apply (((((xany)).apply ((((unsupported)).apply ((((xgetattr)).apply (((xconnection).xfeatures)) ((xfeature)) (FALSE))) ((xfeature)) ((xfeatures))))).not)))) (("Database doesn't support any of the feature(s): %s".mod (((", ".xjoin)).apply ((xfeatures))))) ("skipUnlessAnyDBFeature"))))
            (((unsupported)).apply ((xWSGIRequestHandler)))
              seq
                (((unsupported)).apply)
                xlog_message.write
                  []
                    seq > @
                      (((unsupported)).apply)
            (((unsupported)).apply ((xWSGIHandler)))
              seq
                (((unsupported)).apply)
                x__init__.write
                  [xself xapplication]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xapplication)) ((xapplication)))
                        (((unsupported)).apply (((xself).xbase_url)) ((((xurlparse)).apply (((((xself).xget_base_url)).apply)))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply)
                x_should_handle.write
                  [xself xpath]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((((xpath).xstartswith)).apply ((((unsupported)).apply (((xself).xbase_url)) (2)))).and ((((unsupported)).apply (((xself).xbase_url)) (1)).not))))
                xfile_path.write
                  [xself xurl]
                    memory > xrelative_url
                    seq > @
                      seq
                        unsupported
                        xrelative_url.write (((unsupported)).apply ((xurl)) ((((unsupported)).apply ((((xlen)).apply ((((unsupported)).apply (((xself).xbase_url)) (2))))))))
                        (((unsupported)).apply ((((xurl2pathname)).apply ((xrelative_url)))))
                xget_response.write
                  [xself xrequest]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((xself).x_should_handle)).apply (((xrequest).xpath))).if
                          (((unsupported)).apply ((xHttp404)))
                            (((unsupported)).apply (((((xself).xserve)).apply ((xrequest)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xget_response)).apply ((xrequest)))))
                xserve.write
                  [xself xrequest]
                    memory > xfinal_rel_path
                    memory > xos_rel_path
                    seq > @
                      seq
                        xos_rel_path.write ((((xself).xfile_path)).apply (((xrequest).xpath)))
                        xos_rel_path.write ((((xposixpath).xnormpath)).apply ((((xunquote)).apply ((xos_rel_path)))))
                        xfinal_rel_path.write (((((((xos_rel_path).xreplace)).apply ("\\") ("/")).xlstrip)).apply ("/"))
                        (((unsupported)).apply ((((unsupported)).apply ((xserve)) ((xrequest)) ((xfinal_rel_path)) (((((xself).xget_base_dir)).apply)))))
                x__call__.write
                  [xself xenviron xstart_response]
                    seq > @
                      seq
                        (((((xself).x_should_handle)).apply ((((xget_path_info)).apply ((xenviron))))).not).if
                          (((unsupported)).apply (((((xself).xapplication)).apply ((xenviron)) ((xstart_response)))))
                        (((unsupported)).apply (((((((xsuper)).apply).x__call__)).apply ((xenviron)) ((xstart_response)))))
            (((unsupported)).apply ((xFSFilesHandler)))
              seq
                (((unsupported)).apply)
                xget_base_dir.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xsettings).xSTATIC_ROOT)))
                xget_base_url.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xsettings).xSTATIC_URL)))
            (((unsupported)).apply ((xFSFilesHandler)))
              seq
                (((unsupported)).apply)
                xget_base_dir.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xsettings).xMEDIA_ROOT)))
                xget_base_url.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xsettings).xMEDIA_URL)))
            (((unsupported)).apply (((xthreading).xThread)))
              seq
                unsupported
                xserver_class.write (xThreadedWSGIServer)
                x__init__.write
                  [xself xhost xstatic_handler xconnections_override xport]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xhost)) ((xhost)))
                        (((unsupported)).apply (((xself).xport)) ((xport)))
                        (((unsupported)).apply (((xself).xis_ready)) (((((xthreading).xEvent)).apply)))
                        (((unsupported)).apply (((xself).xerror)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xstatic_handler)) ((xstatic_handler)))
                        (((unsupported)).apply (((xself).xconnections_override)) ((xconnections_override)))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply)
                xrun.write
                  [xself]
                    memory > xhandler
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((xself).xconnections_override).if
                          (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((xconn)))) ((((((xself).xconnections_override).xitems)).apply)))
                            (((unsupported)).apply ((((unsupported)).apply ((xconnections)) ((xalias)))) ((xconn)))
                        (((unsupported)).apply ((xException)))
                          seq
                            xhandler.write ((((xself).xstatic_handler)).apply ((((x_MediaFilesHandler)).apply ((((xWSGIHandler)).apply)))))
                            (((unsupported)).apply (((xself).xhttpd)) (((((xself).x_create_server)).apply)))
                            (((xself).xport).eq 0).if
                              (((unsupported)).apply (((xself).xport)) ((((unsupported)).apply ((((xself).xhttpd).xserver_address)) (1))))
                            bogusForceDataize.write (((((xself).xhttpd).xset_app)).apply ((xhandler)))
                            bogusForceDataize.write (((((xself).xis_ready).xset)).apply)
                            bogusForceDataize.write (((((xself).xhttpd).xserve_forever)).apply)
                          seq
                            (((unsupported)).apply (((xself).xerror)) ((xe)))
                            bogusForceDataize.write (((((xself).xis_ready).xset)).apply)
                          bogusForceDataize.write ((((xconnections).xclose_all)).apply)
                x_create_server.write
                  [xself xconnections_override]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xserver_class)) ((((unsupported)).apply (((xself).xhost)) (((xself).xport)))) ((xQuietWSGIRequestHandler)) (FALSE) ((xconnections_override)))))
                xterminate.write
                  [xself]
                    seq > @
                      seq
                        (((xhasattr)).apply ((xself)) ("httpd")).if
                          seq
                            bogusForceDataize.write (((((xself).xhttpd).xshutdown)).apply)
                            bogusForceDataize.write (((((xself).xhttpd).xserver_close)).apply)
                        bogusForceDataize.write ((((xself).xjoin)).apply)
            (((unsupported)).apply ((xTransactionTestCase)))
              seq
                (((unsupported)).apply)
                xhost.write "localhost"
                xport.write 0
                xserver_thread_class.write (xLiveServerThread)
                xstatic_handler.write (x_StaticFilesHandler)
                xlive_server_url.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (("http://%s:%s".mod (((unsupported)).apply (((xcls).xhost)) ((((xcls).xserver_thread).xport))))))
                xallowed_host.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xcls).xhost)))
                x_make_connections_override.write
                  [xcls]
                    memory > xconnections_override
                    seq > @
                      (((unsupported)).apply)
                        xconnections_override.write (((unsupported)).apply)
                        (((unsupported)).apply ((xconn)) (((((xconnections).xall)).apply)))
                          ((((xconn).xvendor).eq "sqlite").and ((((xconn).xis_in_memory_db)).apply)).if
                            (((unsupported)).apply ((((unsupported)).apply ((xconnections_override)) (((xconn).xalias)))) ((xconn)))
                        (((unsupported)).apply ((xconnections_override)))
                xsetUpClass.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).xsetUpClass)).apply)
                        (((unsupported)).apply (((xcls).x_live_server_modified_settings)) ((((unsupported)).apply ((xmodify_settings)) ((((unsupported)).apply ("append") (((xcls).xallowed_host)))))))
                        bogusForceDataize.write (((((xcls).x_live_server_modified_settings).xenable)).apply)
                        bogusForceDataize.write ((((xcls).xaddClassCleanup)).apply ((((xcls).x_live_server_modified_settings).xdisable)))
                        bogusForceDataize.write ((((xcls).x_start_server_thread)).apply)
                x_start_server_thread.write
                  [xcls]
                    memory > xconnections_override
                    seq > @
                      (((unsupported)).apply)
                        xconnections_override.write ((((xcls).x_make_connections_override)).apply)
                        (((unsupported)).apply ((xconn)) (((((xconnections_override).xvalues)).apply)))
                          bogusForceDataize.write ((((xconn).xinc_thread_sharing)).apply)
                        (((unsupported)).apply (((xcls).xserver_thread)) (((((xcls).x_create_server_thread)).apply ((xconnections_override)))))
                        (((unsupported)).apply ((((xcls).xserver_thread).xdaemon)) (TRUE))
                        bogusForceDataize.write (((((xcls).xserver_thread).xstart)).apply)
                        bogusForceDataize.write ((((xcls).xaddClassCleanup)).apply (((xcls).x_terminate_thread)))
                        bogusForceDataize.write ((((((xcls).xserver_thread).xis_ready).xwait)).apply)
                        (((xcls).xserver_thread).xerror).if
                          (((unsupported)).apply ((((xcls).xserver_thread).xerror)))
                x_create_server_thread.write
                  [xcls xconnections_override]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xcls).xserver_thread_class)) (((xcls).xhost)) (((xcls).xstatic_handler)) ((xconnections_override)) (((xcls).xport)))))
                x_terminate_thread.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write (((((xcls).xserver_thread).xterminate)).apply)
                        (((unsupported)).apply ((xconn)) (((((((xcls).xserver_thread).xconnections_override).xvalues)).apply)))
                          bogusForceDataize.write ((((xconn).xdec_thread_sharing)).apply)
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xlockfile.write "None: is there a None literal in the EO language?"
                x__init_subclass__.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init_subclass__)).apply ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xcls).xlockfile)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xValueError)).apply (((("{}.lockfile isn't set. Set it to a unique value in the base class.".xformat)).apply (((xcls).x__name__)))))))
                xsetUpClass.write
                  [xcls]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xcls).x_lockfile)) ((((xopen)).apply (((xcls).xlockfile)))))
                        bogusForceDataize.write ((((xcls).xaddClassCleanup)).apply ((((xcls).x_lockfile).xclose)))
                        bogusForceDataize.write ((((xlocks).xlock)).apply (((xcls).x_lockfile)) (((xlocks).xLOCK_EX)))
                        bogusForceDataize.write ((((((xsuper)).apply).xsetUpClass)).apply)