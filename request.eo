memory > xk
memory > xImmutableList
memory > xuploadhandler
memory > xvalue
memory > x_
memory > xKeyError
memory > xiri_to_uri
memory > xlist_
memory > xkey
memory > xMultiPartParserError
memory > xtoken
memory > xAttributeError
memory > xheader
memory > xUnicodeDecodeError
memory > x_lazy_re_compile
memory > xparse_qsl
memory > xaccepted_type
memory > xlist
memory > xQueryDict
memory > xBytesIO
memory > xhandler
memory > xValueError
memory > xelt
memory > xquote
memory > xstr
memory > xis_same_domain
memory > xMultiPartParser
memory > xMultiValueDict
memory > xHttpHeaders
memory > xany
memory > xf
memory > xsettings
memory > xint
memory > xException
memory > xhasattr
memory > xcodecs
memory > xpattern
memory > xsuper
memory > xchain
memory > xRequestDataTooBig
memory > xparse_header
memory > xsigning
memory > xCaseInsensitiveMapping
memory > xbytes
memory > xargs
memory > xOSError
memory > xLookupError
memory > xv
memory > xid
memory > xescape_uri_path
memory > xiter
memory > xe
memory > xport
memory > xsecure_value
memory > xMediaType
memory > xRawPostDataException
memory > xUnreadablePostError
memory > xdomain
memory > xobject
memory > xTooManyFieldsSent
memory > xDisallowedHost
memory > xurlsplit
memory > xImproperlyConfigured
memory > xkwargs
memory > xfull_type
memory > xisinstance
memory > xurljoin
memory > xcgi
memory > xlen
[] > request
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xget_full_path
        memory > xis_all_types
        memory > xbytes_to_text
        memory > xparse_accept_header
        memory > xappendlist
        memory > xfromkeys
        memory > xget_signed_cookie
        memory > xget_port
        memory > xupload_handlers
        memory > xbuild_absolute_uri
        memory > x__str__
        memory > xcopy
        memory > x_get_full_path
        memory > x__deepcopy__
        memory > x_current_scheme_host
        memory > xheaders
        memory > x_mark_post_parse_error
        memory > x__repr__
        memory > xget_full_path_info
        memory > xvalidate_host
        memory > xparse_file_upload
        memory > x_get_raw_host
        memory > x_mutable
        memory > xpop
        memory > xsetdefault
        memory > xclear
        memory > xget_host
        memory > x__iter__
        memory > xurlencode
        memory > xclose
        memory > xhost_validation_re
        memory > x_set_content_type_params
        memory > xsplit_domain_port
        memory > x__getitem__
        memory > xis_secure
        memory > xUNPREFIXED_HEADERS
        memory > xaccepted_types
        memory > x__delitem__
        memory > xscheme
        memory > x_assert_mutable
        memory > x_load_post_and_files
        memory > x_initialize_handlers
        memory > x_encoding
        memory > xbody
        memory > xRAISE_ERROR
        memory > x_upload_handlers
        memory > x__setitem__
        memory > xencoding
        memory > x__init__
        memory > xHTTP_PREFIX
        memory > xread
        memory > xparse_header_name
        memory > xpopitem
        memory > xaccepts
        memory > xsetlistdefault
        memory > xreadlines
        memory > xmatch
        memory > xreadline
        memory > x_get_scheme
        memory > x__copy__
        memory > xsetlist
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            xRAISE_ERROR.write (((xobject)).apply)
            xhost_validation_re.write (((x_lazy_re_compile)).apply ("^([a-z0-9.-]+|[[a-f0-9]*:[a-f0-9.:]+])(:[0-9]+)?$"))
            (((unsupported)).apply ((xOSError)))
            (((unsupported)).apply ((xException)))
              seq
                (((unsupported)).apply)
            (((unsupported)).apply)
              seq
                unsupported
                x_encoding.write "None: is there a None literal in the EO language?"
                x_upload_handlers.write (((unsupported)).apply)
                x__init__.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xGET)) ((((unsupported)).apply ((xQueryDict)) (TRUE))))
                        (((unsupported)).apply (((xself).xPOST)) ((((unsupported)).apply ((xQueryDict)) (TRUE))))
                        (((unsupported)).apply (((xself).xCOOKIES)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xMETA)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xFILES)) ((((xMultiValueDict)).apply)))
                        (((unsupported)).apply (((xself).xpath)) (""))
                        (((unsupported)).apply (((xself).xpath_info)) (""))
                        (((unsupported)).apply (((xself).xmethod)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xresolver_match)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xcontent_type)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xcontent_params)) ("None: is there a None literal in the EO language?"))
                x__repr__.write
                  [xself]
                    seq > @
                      seq
                        ((((unsupported)).apply (((xself).xmethod)) ("None: is there a None literal in the EO language?")).or (((((xself).xget_full_path)).apply).not)).if
                          (((unsupported)).apply (("<%s>".mod (((xself).x__class__).x__name__))))
                        (((unsupported)).apply (("<%s: %s %r>".mod (((unsupported)).apply ((((xself).x__class__).x__name__)) (((xself).xmethod)) (((((xself).xget_full_path)).apply))))))
                xheaders.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xHttpHeaders)).apply (((xself).xMETA)))))
                xaccepted_types.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        (((unsupported)).apply ((((xparse_accept_header)).apply ((((((xself).xheaders).xget)).apply ("Accept") ("*/*"))))))
                xaccepts.write
                  [xself xmedia_type]
                    seq > @
                      (((unsupported)).apply ((((xany)).apply ((((unsupported)).apply (((((xaccepted_type).xmatch)).apply ((xmedia_type)))) ((xaccepted_type)) (((xself).xaccepted_types)))))))
                x_set_content_type_params.write
                  [xself xmeta]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xcontent_type)) (((xself).xcontent_params)))) (((((xcgi).xparse_header)).apply (((((xmeta).xget)).apply ("CONTENT_TYPE") (""))))))
                        (((unsupported)).apply ("charset") (((xself).xcontent_params))).if
                          (((unsupported)).apply ((xLookupError)))
                            bogusForceDataize.write ((((xcodecs).xlookup)).apply ((((unsupported)).apply (((xself).xcontent_params)) ("charset"))))
                            (((unsupported)).apply (((xself).xencoding)) ((((unsupported)).apply (((xself).xcontent_params)) ("charset"))))
                x_get_raw_host.write
                  [xself]
                    memory > xhost
                    memory > xserver_port
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xsettings).xUSE_X_FORWARDED_HOST).and (((unsupported)).apply ("HTTP_X_FORWARDED_HOST") (((xself).xMETA)))).if
                          xhost.write (((unsupported)).apply (((xself).xMETA)) ("HTTP_X_FORWARDED_HOST"))
                          (((unsupported)).apply ("HTTP_HOST") (((xself).xMETA))).if
                            xhost.write (((unsupported)).apply (((xself).xMETA)) ("HTTP_HOST"))
                            seq
                              xhost.write (((unsupported)).apply (((xself).xMETA)) ("SERVER_NAME"))
                              xserver_port.write ((((xself).xget_port)).apply)
                              ((xserver_port).neq (((((xself).xis_secure)).apply).if "443" "80")).if
                                xhost.write ("%s:%s".mod (((unsupported)).apply ((xhost)) ((xserver_port))))
                        (((unsupported)).apply ((xhost)))
                xget_host.write
                  [xself]
                    memory > xallowed_hosts
                    memory > xhost
                    memory > xmsg
                    seq > @
                      seq
                        unsupported
                        xhost.write ((((xself).x_get_raw_host)).apply)
                        xallowed_hosts.write ((xsettings).xALLOWED_HOSTS)
                        (((xsettings).xDEBUG).and ((xallowed_hosts).not)).if
                          xallowed_hosts.write (((unsupported)).apply (".localhost") ("127.0.0.1") ("[::1]"))
                        (((unsupported)).apply ((((unsupported)).apply ((xdomain)) ((xport)))) ((((xsplit_domain_port)).apply ((xhost)))))
                        ((xdomain).and (((xvalidate_host)).apply ((xdomain)) ((xallowed_hosts)))).if
                          (((unsupported)).apply ((xhost)))
                          seq
                            xmsg.write ("Invalid HTTP_HOST header: %r.".mod (xhost))
                            (xdomain).if
                              (((unsupported)).apply ((xmsg)) ((" You may need to add %r to ALLOWED_HOSTS.".mod (xdomain))))
                              (((unsupported)).apply ((xmsg)) (" The domain name provided is not valid according to RFC 1034/1035."))
                            (((unsupported)).apply ((((xDisallowedHost)).apply ((xmsg)))))
                xget_port.write
                  [xself]
                    memory > xport
                    seq > @
                      seq
                        unsupported
                        (((xsettings).xUSE_X_FORWARDED_PORT).and (((unsupported)).apply ("HTTP_X_FORWARDED_PORT") (((xself).xMETA)))).if
                          xport.write (((unsupported)).apply (((xself).xMETA)) ("HTTP_X_FORWARDED_PORT"))
                          xport.write (((unsupported)).apply (((xself).xMETA)) ("SERVER_PORT"))
                        (((unsupported)).apply ((((xstr)).apply ((xport)))))
                xget_full_path.write
                  [xself xforce_append_slash]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_get_full_path)).apply (((xself).xpath)) ((xforce_append_slash)))))
                xget_full_path_info.write
                  [xself xforce_append_slash]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_get_full_path)).apply (((xself).xpath_info)) ((xforce_append_slash)))))
                x_get_full_path.write
                  [xself xpath xforce_append_slash]
                    seq > @
                      (((unsupported)).apply (("%s%s%s".mod (((unsupported)).apply ((((xescape_uri_path)).apply ((xpath)))) ((((xforce_append_slash).and (((((xpath).xendswith)).apply ("/")).not)).if "/" "")) (((((((xself).xMETA).xget)).apply ("QUERY_STRING") ("")).if ("?".add (((xiri_to_uri)).apply ((((((xself).xMETA).xget)).apply ("QUERY_STRING") (""))))) ""))))))
                xget_signed_cookie.write
                  [xself xkey xdefault xsalt xmax_age]
                    memory > xvalue
                    memory > xcookie_value
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xKeyError)))
                          xcookie_value.write (((unsupported)).apply (((xself).xCOOKIES)) ((xkey)))
                          (((unsupported)).apply ((xdefault)) ((xRAISE_ERROR))).if
                            (((unsupported)).apply ((xdefault)))
                            (((unsupported)).apply)
                        (((unsupported)).apply (((xsigning).xBadSignature)))
                          xvalue.write (((unsupported)).apply (((((unsupported)).apply (((xsigning).xget_cookie_signer)) (((xkey).add (xsalt)))).xunsign)) ((xcookie_value)) ((xmax_age)))
                          (((unsupported)).apply ((xdefault)) ((xRAISE_ERROR))).if
                            (((unsupported)).apply ((xdefault)))
                            (((unsupported)).apply)
                        (((unsupported)).apply ((xvalue)))
                xbuild_absolute_uri.write
                  [xself xlocation]
                    memory > xbits
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xlocation)) ("None: is there a None literal in the EO language?")).if
                          xlocation.write ("//%s".mod ((((xself).xget_full_path)).apply))
                          xlocation.write (((xstr)).apply ((xlocation)))
                        xbits.write (((xurlsplit)).apply ((xlocation)))
                        ((((xbits).xscheme).and ((xbits).xnetloc)).not).if
                          (((((((((xbits).xpath).xstartswith)).apply ("/")).and (((xbits).xscheme).not)).and (((xbits).xnetloc).not)).and (((unsupported)).apply ("/./") (((xbits).xpath)))).and (((unsupported)).apply ("/../") (((xbits).xpath)))).if
                            seq
                              ((((xlocation).xstartswith)).apply ("//")).if
                                xlocation.write (((unsupported)).apply ((xlocation)) ((((unsupported)).apply (2))))
                              xlocation.write (((xself).x_current_scheme_host).add (xlocation))
                            xlocation.write (((xurljoin)).apply ((((xself).x_current_scheme_host).add ((xself).xpath))) ((xlocation)))
                        (((unsupported)).apply ((((xiri_to_uri)).apply ((xlocation)))))
                x_current_scheme_host.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((("{}://{}".xformat)).apply (((xself).xscheme)) (((((xself).xget_host)).apply)))))
                x_get_scheme.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("http"))
                xscheme.write
                  [xself]
                    memory > xheader_value
                    seq > @
                      (((unsupported)).apply)
                        ((xsettings).xSECURE_PROXY_SSL_HEADER).if
                          seq
                            (((unsupported)).apply ((xValueError)))
                              (((unsupported)).apply ((((unsupported)).apply ((xheader)) ((xsecure_value)))) (((xsettings).xSECURE_PROXY_SSL_HEADER)))
                              (((unsupported)).apply ((((xImproperlyConfigured)).apply ("The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values."))))
                            xheader_value.write (((((xself).xMETA).xget)).apply ((xheader)))
                            (((unsupported)).apply ((xheader_value)) ("None: is there a None literal in the EO language?")).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xheader_value)) ((((unsupported)).apply ((x_)))))) (((((xheader_value).xsplit)).apply (",") (1))))
                                (((unsupported)).apply (((((((xheader_value).xstrip)).apply).eq (xsecure_value)).if "https" "http")))
                        (((unsupported)).apply (((((xself).x_get_scheme)).apply)))
                xis_secure.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xself).xscheme).eq "https")))
                xencoding.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_encoding)))
                xencoding.write
                  [xself xval]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_encoding)) ((xval)))
                        (((xhasattr)).apply ((xself)) ("GET")).if
                          (((unsupported)).apply ((((unsupported)).apply (((xself).xGET)))))
                        (((xhasattr)).apply ((xself)) ("_post")).if
                          (((unsupported)).apply ((((unsupported)).apply (((xself).x_post)))))
                x_initialize_handlers.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xself).x_upload_handlers)) ((((unsupported)).apply (((((xuploadhandler).xload_handler)).apply ((xhandler)) ((xself)))) ((xhandler)) (((xsettings).xFILE_UPLOAD_HANDLERS)))))
                xupload_handlers.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((xself).x_upload_handlers).not).if
                          bogusForceDataize.write ((((xself).x_initialize_handlers)).apply)
                        (((unsupported)).apply (((xself).x_upload_handlers)))
                xupload_handlers.write
                  [xself xupload_handlers]
                    seq > @
                      (((unsupported)).apply)
                        (((xhasattr)).apply ((xself)) ("_files")).if
                          (((unsupported)).apply ((((xAttributeError)).apply ("You cannot set the upload handlers after the upload has been processed."))))
                        (((unsupported)).apply (((xself).x_upload_handlers)) ((xupload_handlers)))
                xparse_file_upload.write
                  [xself xMETA xpost_data]
                    memory > xparser
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((xself).xupload_handlers)) ((((unsupported)).apply ((xImmutableList)) (((xself).xupload_handlers)) ("You cannot alter upload handlers after the upload has been processed."))))
                        xparser.write (((xMultiPartParser)).apply ((xMETA)) ((xpost_data)) (((xself).xupload_handlers)) (((xself).xencoding)))
                        (((unsupported)).apply (((((xparser).xparse)).apply)))
                xbody.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        ((((xhasattr)).apply ((xself)) ("_body")).not).if
                          seq
                            ((xself).x_read_started).if
                              (((unsupported)).apply ((((xRawPostDataException)).apply ("You cannot access body after reading from request's data stream"))))
                            ((((unsupported)).apply (((xsettings).xDATA_UPLOAD_MAX_MEMORY_SIZE)) ("None: is there a None literal in the EO language?")).and ((((xint)).apply (((((((xself).xMETA).xget)).apply ("CONTENT_LENGTH")).or 0))).greater ((xsettings).xDATA_UPLOAD_MAX_MEMORY_SIZE))).if
                              (((unsupported)).apply ((((xRequestDataTooBig)).apply ("Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE."))))
                            (((unsupported)).apply ((xOSError)))
                              (((unsupported)).apply (((xself).x_body)) (((((xself).xread)).apply)))
                              (((unsupported)).apply ((((xUnreadablePostError)).apply ((((unsupported)).apply (((xe).xargs)))))) ((xe)))
                            (((unsupported)).apply (((xself).x_stream)) ((((xBytesIO)).apply (((xself).x_body)))))
                        (((unsupported)).apply (((xself).x_body)))
                x_mark_post_parse_error.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).x_post)) ((((xQueryDict)).apply)))
                        (((unsupported)).apply (((xself).x_files)) ((((xMultiValueDict)).apply)))
                x_load_post_and_files.write
                  [xself]
                    memory > xdata
                    seq > @
                      seq
                        unsupported
                        (((xself).xmethod).neq "POST").if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply (((xself).x_post)) (((xself).x_files)))) ((((unsupported)).apply ((((unsupported)).apply ((xQueryDict)) (((xself).x_encoding)))) ((((xMultiValueDict)).apply)))))
                            (((unsupported)).apply)
                        (((xself).x_read_started).and ((((xhasattr)).apply ((xself)) ("_body")).not)).if
                          seq
                            bogusForceDataize.write ((((xself).x_mark_post_parse_error)).apply)
                            (((unsupported)).apply)
                        (((xself).xcontent_type).eq "multipart/form-data").if
                          seq
                            (((xhasattr)).apply ((xself)) ("_body")).if
                              xdata.write (((xBytesIO)).apply (((xself).x_body)))
                              xdata.write (xself)
                            (((unsupported)).apply ((xMultiPartParserError)))
                              (((unsupported)).apply ((((unsupported)).apply (((xself).x_post)) (((xself).x_files)))) (((((xself).xparse_file_upload)).apply (((xself).xMETA)) ((xdata)))))
                              seq
                                bogusForceDataize.write ((((xself).x_mark_post_parse_error)).apply)
                                (((unsupported)).apply)
                          (((xself).xcontent_type).eq "application/x-www-form-urlencoded").if
                            (((unsupported)).apply ((((unsupported)).apply (((xself).x_post)) (((xself).x_files)))) ((((unsupported)).apply ((((unsupported)).apply ((xQueryDict)) (((xself).xbody)) (((xself).x_encoding)))) ((((xMultiValueDict)).apply)))))
                            (((unsupported)).apply ((((unsupported)).apply (((xself).x_post)) (((xself).x_files)))) ((((unsupported)).apply ((((unsupported)).apply ((xQueryDict)) (((xself).x_encoding)))) ((((xMultiValueDict)).apply)))))
                xclose.write
                  [xself]
                    seq > @
                      (((xhasattr)).apply ((xself)) ("_files")).if
                        (((unsupported)).apply ((xf)) (((((xchain).xfrom_iterable)).apply ((((unsupported)).apply ((((unsupported)).apply ((xlist_)) (1))) ((xlist_)) ((((((xself).x_files).xlists)).apply)))))))
                          bogusForceDataize.write ((((xf).xclose)).apply)
                xread.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_read_started)) (TRUE))
                        (((unsupported)).apply ((xOSError)))
                          (((unsupported)).apply ((((((xself).x_stream).xread)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                          (((unsupported)).apply ((((xUnreadablePostError)).apply ((((unsupported)).apply (((xe).xargs)))))) ((xe)))
                xreadline.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_read_started)) (TRUE))
                        (((unsupported)).apply ((xOSError)))
                          (((unsupported)).apply ((((((xself).x_stream).xreadline)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                          (((unsupported)).apply ((((xUnreadablePostError)).apply ((((unsupported)).apply (((xe).xargs)))))) ((xe)))
                x__iter__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xiter)).apply (((xself).xreadline)) (""))))
                xreadlines.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xlist)).apply ((xself)))))
            (((unsupported)).apply ((xCaseInsensitiveMapping)))
              seq
                xHTTP_PREFIX.write "HTTP_"
                xUNPREFIXED_HEADERS.write (((unsupported)).apply ("CONTENT_TYPE") ("CONTENT_LENGTH"))
                x__init__.write
                  [xself xenviron]
                    memory > xheaders
                    memory > xname
                    seq > @
                      seq
                        xheaders.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xheader)) ((xvalue)))) (((((xenviron).xitems)).apply)))
                          seq
                            xname.write ((((xself).xparse_header_name)).apply ((xheader)))
                            (xname).if
                              (((unsupported)).apply ((((unsupported)).apply ((xheaders)) ((xname)))) ((xvalue)))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xheaders)))
                x__getitem__.write
                  [xself xkey]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((((((xsuper)).apply).x__getitem__)).apply (((((xkey).xreplace)).apply ("_") ("-"))))))
                xparse_header_name.write
                  [xcls xheader]
                    seq > @
                      (((unsupported)).apply)
                        ((((xheader).xstartswith)).apply (((xcls).xHTTP_PREFIX))).if
                          xheader.write (((unsupported)).apply ((xheader)) ((((unsupported)).apply ((((xlen)).apply (((xcls).xHTTP_PREFIX)))))))
                          (((unsupported)).apply ((xheader)) (((xcls).xUNPREFIXED_HEADERS))).if
                            (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((((((xheader).xreplace)).apply ("_") ("-")).xtitle)).apply)))
            (((unsupported)).apply ((xMultiValueDict)))
              seq
                (((unsupported)).apply)
                x_mutable.write TRUE
                x_encoding.write "None: is there a None literal in the EO language?"
                x__init__.write
                  [xself xquery_string xmutable xencoding]
                    memory > xparse_qsl_kwargs
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply)
                        (((unsupported)).apply (((xself).xencoding)) (((xencoding).or ((xsettings).xDEFAULT_CHARSET))))
                        xquery_string.write ((xquery_string).or "")
                        xparse_qsl_kwargs.write (((unsupported)).apply ("keep_blank_values") (TRUE) ("encoding") (((xself).xencoding)) ("max_num_fields") (((xsettings).xDATA_UPLOAD_MAX_NUMBER_FIELDS)))
                        (((xisinstance)).apply ((xquery_string)) ((xbytes))).if
                          (((unsupported)).apply ((xUnicodeDecodeError)))
                            xquery_string.write ((((xquery_string).xdecode)).apply (((xself).xencoding)))
                            xquery_string.write ((((xquery_string).xdecode)).apply ("iso-8859-1"))
                        (((unsupported)).apply ((xValueError)))
                          (((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xvalue)))) ((((xparse_qsl)).apply ((xquery_string)) ((((unsupported)).apply ((xparse_qsl_kwargs)))))))
                            bogusForceDataize.write ((((xself).xappendlist)).apply ((xkey)) ((xvalue)))
                          (((unsupported)).apply ((((xTooManyFieldsSent)).apply ("The number of GET/POST parameters exceeded settings.DATA_UPLOAD_MAX_NUMBER_FIELDS."))) ((xe)))
                        (((unsupported)).apply (((xself).x_mutable)) ((xmutable)))
                xfromkeys.write
                  [xcls xiterable xvalue xmutable xencoding]
                    memory > xq
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xq.write (((unsupported)).apply ((xcls)) ("") (TRUE) ((xencoding)))
                        (((unsupported)).apply ((xkey)) ((xiterable)))
                          bogusForceDataize.write ((((xq).xappendlist)).apply ((xkey)) ((xvalue)))
                        ((xmutable).not).if
                          (((unsupported)).apply (((xq).x_mutable)) (FALSE))
                        (((unsupported)).apply ((xq)))
                xencoding.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_encoding)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).x_encoding)) (((xsettings).xDEFAULT_CHARSET)))
                        (((unsupported)).apply (((xself).x_encoding)))
                xencoding.write
                  [xself xvalue]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_encoding)) ((xvalue)))
                x_assert_mutable.write
                  [xself]
                    seq > @
                      (((xself).x_mutable).not).if
                        (((unsupported)).apply ((((xAttributeError)).apply ("This QueryDict instance is immutable"))))
                x__setitem__.write
                  [xself xkey xvalue]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        xkey.write (((xbytes_to_text)).apply ((xkey)) (((xself).xencoding)))
                        xvalue.write (((xbytes_to_text)).apply ((xvalue)) (((xself).xencoding)))
                        bogusForceDataize.write ((((((xsuper)).apply).x__setitem__)).apply ((xkey)) ((xvalue)))
                x__delitem__.write
                  [xself xkey]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__delitem__)).apply ((xkey)))
                x__copy__.write
                  [xself]
                    memory > xresult
                    seq > @
                      seq
                        xresult.write (((unsupported)).apply (((xself).x__class__)) ("") (TRUE) (((xself).xencoding)))
                        (((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xvalue)))) (((((xself).xlists)).apply)))
                          bogusForceDataize.write ((((xresult).xsetlist)).apply ((xkey)) ((xvalue)))
                        (((unsupported)).apply ((xresult)))
                x__deepcopy__.write
                  [xself xmemo]
                    memory > xresult
                    seq > @
                      seq
                        xresult.write (((unsupported)).apply (((xself).x__class__)) ("") (TRUE) (((xself).xencoding)))
                        (((unsupported)).apply ((((unsupported)).apply ((xmemo)) ((((xid)).apply ((xself)))))) ((xresult)))
                        (((unsupported)).apply ((((unsupported)).apply ((xkey)) ((xvalue)))) (((((xself).xlists)).apply)))
                          bogusForceDataize.write ((((xresult).xsetlist)).apply (((((xcopy).xdeepcopy)).apply ((xkey)) ((xmemo)))) (((((xcopy).xdeepcopy)).apply ((xvalue)) ((xmemo)))))
                        (((unsupported)).apply ((xresult)))
                xsetlist.write
                  [xself xkey xlist_]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        xkey.write (((xbytes_to_text)).apply ((xkey)) (((xself).xencoding)))
                        xlist_.write (((unsupported)).apply ((((xbytes_to_text)).apply ((xelt)) (((xself).xencoding)))) ((xelt)) ((xlist_)))
                        bogusForceDataize.write ((((((xsuper)).apply).xsetlist)).apply ((xkey)) ((xlist_)))
                xsetlistdefault.write
                  [xself xkey xdefault_list]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xsetlistdefault)).apply ((xkey)) ((xdefault_list)))))
                xappendlist.write
                  [xself xkey xvalue]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        xkey.write (((xbytes_to_text)).apply ((xkey)) (((xself).xencoding)))
                        xvalue.write (((xbytes_to_text)).apply ((xvalue)) (((xself).xencoding)))
                        bogusForceDataize.write ((((((xsuper)).apply).xappendlist)).apply ((xkey)) ((xvalue)))
                xpop.write
                  [xself xkey]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xpop)).apply ((xkey)) ((((unsupported)).apply ((xargs)))))))
                xpopitem.write
                  [xself]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xpopitem)).apply)))
                xclear.write
                  [xself]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).xclear)).apply)
                xsetdefault.write
                  [xself xkey xdefault]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).x_assert_mutable)).apply)
                        xkey.write (((xbytes_to_text)).apply ((xkey)) (((xself).xencoding)))
                        xdefault.write (((xbytes_to_text)).apply ((xdefault)) (((xself).xencoding)))
                        (((unsupported)).apply (((((((xsuper)).apply).xsetdefault)).apply ((xkey)) ((xdefault)))))
                xcopy.write
                  [xself]
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply (((((xself).x__deepcopy__)).apply ((((unsupported)).apply)))))
                xurlencode.write
                  [xself xsafe]
                    memory > xencode
                    memory > xoutput
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xoutput.write (((unsupported)).apply)
                        (xsafe).if
                          seq
                            xsafe.write ((((xsafe).xencode)).apply (((xself).xencoding)))
                            xencode.write
                              [xk xv]
                                seq > @
                                  (((unsupported)).apply (("%s=%s".mod (((unsupported)).apply ((((xquote)).apply ((xk)) ((xsafe)))) ((((xquote)).apply ((xv)) ((xsafe))))))))
                          xencode.write
                            [xk xv]
                              seq > @
                                (((unsupported)).apply ((((xurlencode)).apply ((((unsupported)).apply ((xk)) ((xv)))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xk)) ((xlist_)))) (((((xself).xlists)).apply)))
                          bogusForceDataize.write ((((xoutput).xextend)).apply ((((unsupported)).apply ((((xencode)).apply (((((xk).xencode)).apply (((xself).xencoding)))) (((((((xstr)).apply ((xv))).xencode)).apply (((xself).xencoding)))))) ((xv)) ((xlist_)))))
                        (((unsupported)).apply (((("&".xjoin)).apply ((xoutput)))))
            (((unsupported)).apply)
              seq
                x__init__.write
                  [xself xmedia_type_raw_line]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xfull_type)) (((xself).xparams)))) ((((xparse_header)).apply (((xmedia_type_raw_line).if ((((xmedia_type_raw_line).xencode)).apply ("ascii")) "")))))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xmain_type)) ((x_)) (((xself).xsub_type)))) (((((xfull_type).xpartition)).apply ("/"))))
                x__str__.write
                  [xself]
                    memory > xparams_str
                    seq > @
                      seq
                        xparams_str.write ((("".xjoin)).apply ((((unsupported)).apply (("; %s=%s".mod (((unsupported)).apply ((xk)) (((((xv).xdecode)).apply ("ascii")))))) ((((unsupported)).apply ((xk)) ((xv)))) ((((((xself).xparams).xitems)).apply)))))
                        (((unsupported)).apply (("%s%s%s".mod (((unsupported)).apply (((xself).xmain_type)) ((((xself).xsub_type).if ("/%s".mod ((xself).xsub_type)) "")) ((xparams_str))))))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("<%s: %s>".mod (((unsupported)).apply ((((xself).x__class__).x__qualname__)) ((xself))))))
                xis_all_types.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xmain_type).eq "*").and (((xself).xsub_type).eq "*"))))
                xmatch.write
                  [xself xother]
                    seq > @
                      seq
                        ((xself).xis_all_types).if
                          (((unsupported)).apply (TRUE))
                        xother.write (((xMediaType)).apply ((xother)))
                        ((((xself).xmain_type).eq ((xother).xmain_type)).and (((unsupported)).apply (((xself).xsub_type)) ((((unsupported)).apply ("*") (((xother).xsub_type)))))).if
                          (((unsupported)).apply (TRUE))
                        (((unsupported)).apply (FALSE))
            xbytes_to_text.write
              [xs xencoding]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((xisinstance)).apply ((xs)) ((xbytes))).if
                      (((unsupported)).apply ((((xstr)).apply ((xs)) ((xencoding)) ("replace"))))
                      (((unsupported)).apply ((xs)))
            xsplit_domain_port.write
              [xhost]
                memory > xdomain
                memory > xbits
                seq > @
                  seq
                    (((unsupported)).apply)
                    xhost.write ((((xhost).xlower)).apply)
                    (((((xhost_validation_re).xmatch)).apply ((xhost))).not).if
                      (((unsupported)).apply ((((unsupported)).apply ("") (""))))
                    ((((unsupported)).apply ((xhost)) ((1.neg))).eq "]").if
                      (((unsupported)).apply ((((unsupported)).apply ((xhost)) (""))))
                    xbits.write ((((xhost).xrsplit)).apply (":") (1))
                    (((unsupported)).apply ((((unsupported)).apply ((xdomain)) ((xport)))) ((((((xlen)).apply ((xbits))).eq 2).if (xbits) (((unsupported)).apply ((((unsupported)).apply ((xbits)) (0))) ("")))))
                    xdomain.write (((((xdomain).xendswith)).apply (".")).if (((unsupported)).apply ((xdomain)) ((((unsupported)).apply ((1.neg))))) (xdomain))
                    (((unsupported)).apply ((((unsupported)).apply ((xdomain)) ((xport)))))
            xvalidate_host.write
              [xhost xallowed_hosts]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply ((((xany)).apply ((((unsupported)).apply ((((xpattern).eq "*").or (((xis_same_domain)).apply ((xhost)) ((xpattern))))) ((xpattern)) ((xallowed_hosts)))))))
            xparse_accept_header.write
              [xheader]
                seq > @
                  (((unsupported)).apply ((((unsupported)).apply ((((xMediaType)).apply ((xtoken)))) ((xtoken)) (((((xheader).xsplit)).apply (","))) (((((xtoken).xstrip)).apply)))))