memory > xforms
memory > xKeyTransformIsNull
memory > xargs
memory > xname
memory > xjson
memory > xfalse
memory > xdb
memory > xKeyTransformExact
memory > xlhs_params
memory > xrhs_params
memory > xKeyTransform
memory > xlist
memory > xKeyTransformStartsWith
memory > xCaseInsensitiveMixin
memory > xis_null_sql
memory > xKeyTransformEndsWith
memory > xKeyTransformLte
memory > xJSONExact
memory > xHasAnyKeys
memory > xValueError
memory > xHasKeyLookup
memory > xstr
memory > xchecks
memory > xhas_key_params
memory > xlookups
memory > xKeyTransformIContains
memory > xKeyTransformIEndsWith
memory > xKeyTextTransform
memory > xKeyTransformIExact
memory > xContainedBy
memory > xis_null_params
memory > xrouter
memory > xvalue
memory > xKeyTransformTextLookupMixin
memory > xlhs
memory > xHasKey
memory > xField
memory > xKeyTransformFactory
memory > xKeyTransformGt
memory > xkey_transform
memory > xlhs_key_transforms
memory > xexceptions
memory > xrhs
memory > xKeyTransformNumericLookupMixin
memory > xCheckFieldDefaultMixin
memory > xKeyTransformRegex
memory > xcallable
memory > xpath
memory > xKeyTransformIStartsWith
memory > xrepr
memory > xint
memory > xconnections
memory > xrhs_key_transforms
memory > xhasattr
memory > xTransform
memory > xparams
memory > xNotSupportedError
memory > xDataContains
memory > xsuper
memory > xtuple
memory > xJSONField
memory > xKeyTransformIRegex
memory > xitem
memory > xdatatype
memory > xsql
memory > xKeyTransformLt
memory > xJSONIContains
memory > xHasKeyOrArrayIndex
memory > xhas_key_sql
memory > xPostgresOperatorLookup
memory > xkwargs
memory > xfinal_key
memory > xisinstance
memory > xkey_transforms
memory > xdict
memory > xKeyTransformIn
memory > xHasKeys
memory > xlen
memory > xTypeError
memory > xkey
memory > xKeyTransformGte
[] > json
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xprepare_rhs
        memory > xpostgres_nested_operator
        memory > xcan_use_none_as_rhs
        memory > xcheck
        memory > xresolve_expression_parameter
        memory > xvalidate
        memory > xlookup_name
        memory > xcompile_json_path_final_key
        memory > x__init__
        memory > xprocess_rhs
        memory > xpostgres_operator
        memory > xget_prep_value
        memory > xget_transform
        memory > xdefault_error_messages
        memory > xas_oracle
        memory > xas_mysql
        memory > xformfield
        memory > x__call__
        memory > xcompile_json_path
        memory > xvalue_to_string
        memory > xget_internal_type
        memory > xget_prep_lookup
        memory > xdescription
        memory > xas_postgresql
        memory > xpreprocess_lhs
        memory > xfrom_db_value
        memory > x_
        memory > xempty_strings_allowed
        memory > xas_sql
        memory > xas_sqlite
        memory > xprocess_lhs
        memory > xlogical_operator
        memory > x__all__
        memory > x_default_hint
        memory > xdeconstruct
        memory > x_check_supported
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            x__all__.write (((unsupported)).apply ("JSONField"))
            (((unsupported)).apply ((xCheckFieldDefaultMixin)) ((xField)))
              seq
                xempty_strings_allowed.write (xfalse)
                xdescription.write (((x_)).apply ("A JSON object"))
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("Value must be valid JSON."))))
                x_default_hint.write (((unsupported)).apply ("dict") ("{}"))
                x__init__.write
                  [xself xverbose_name xname xencoder xdecoder]
                    seq > @
                      (((unsupported)).apply)
                        ((xencoder).and ((((xcallable)).apply ((xencoder))).not)).if
                          (((unsupported)).apply ((((xValueError)).apply ("The encoder parameter must be a callable object."))))
                        ((xdecoder).and ((((xcallable)).apply ((xdecoder))).not)).if
                          (((unsupported)).apply ((((xValueError)).apply ("The decoder parameter must be a callable object."))))
                        (((unsupported)).apply (((xself).xencoder)) ((xencoder)))
                        (((unsupported)).apply (((xself).xdecoder)) ((xdecoder)))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xverbose_name)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                xcheck.write
                  [xself]
                    memory > xerrors
                    memory > xdatabases
                    seq > @
                      (((unsupported)).apply)
                        xerrors.write ((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))
                        xdatabases.write (((((xkwargs).xget)).apply ("databases")).or (((unsupported)).apply))
                        bogusForceDataize.write ((((xerrors).xextend)).apply (((((xself).x_check_supported)).apply ((xdatabases)))))
                        (((unsupported)).apply ((xerrors)))
                x_check_supported.write
                  [xself xdatabases]
                    memory > xerrors
                    memory > xconnection
                    seq > @
                      seq
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xdb)) ((xdatabases)))
                          seq
                            (((((xrouter).xallow_migrate_model)).apply ((xdb)) (((xself).xmodel))).not).if
                              (((unsupported)).apply)
                            xconnection.write (((unsupported)).apply ((xconnections)) ((xdb)))
                            (((((xself).xmodel).x_meta).xrequired_db_vendor).and (((((xself).xmodel).x_meta).xrequired_db_vendor).neq ((xconnection).xvendor))).if
                              (((unsupported)).apply)
                            (((((unsupported)).apply ("supports_json_field") (((((xself).xmodel).x_meta).xrequired_db_features))).or (((xconnection).xfeatures).xsupports_json_field)).not).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("%s does not support JSONFields.".mod ((xconnection).xdisplay_name))) (((xself).xmodel)) ("fields.E180"))))
                        (((unsupported)).apply ((xerrors)))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply (((xself).xencoder)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("encoder"))) (((xself).xencoder)))
                        (((unsupported)).apply (((xself).xdecoder)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("decoder"))) (((xself).xdecoder)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xfrom_db_value.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        ((((xisinstance)).apply ((xexpression)) ((xKeyTransform))).and ((((xisinstance)).apply ((xvalue)) ((xstr))).not)).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply (((xjson).xJSONDecodeError)))
                          (((unsupported)).apply ((((unsupported)).apply (((xjson).xloads)) ((xvalue)) (((xself).xdecoder)))))
                          (((unsupported)).apply ((xvalue)))
                xget_internal_type.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("JSONField"))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((xvalue)))
                        (((unsupported)).apply ((((unsupported)).apply (((xjson).xdumps)) ((xvalue)) (((xself).xencoder)))))
                xget_transform.write
                  [xself xname]
                    memory > xtransform
                    seq > @
                      seq
                        xtransform.write ((((((xsuper)).apply).xget_transform)).apply ((xname)))
                        (xtransform).if
                          (((unsupported)).apply ((xtransform)))
                        (((unsupported)).apply ((((xKeyTransformFactory)).apply ((xname)))))
                xvalidate.write
                  [xself xvalue xmodel_instance]
                    seq > @
                      seq
                        bogusForceDataize.write ((((((xsuper)).apply).xvalidate)).apply ((xvalue)) ((xmodel_instance)))
                        (((unsupported)).apply ((xTypeError)))
                          (((unsupported)).apply (((xjson).xdumps)) ((xvalue)) (((xself).xencoder)))
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("value") ((xvalue)))))))
                xvalue_to_string.write
                  [xself xobj]
                    seq > @
                      (((unsupported)).apply (((((xself).xvalue_from_object)).apply ((xobj)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xJSONField)) ("encoder") (((xself).xencoder)) ("decoder") (((xself).xdecoder)) ((xkwargs)))))))))
            xcompile_json_path.write
              [xkey_transforms xinclude_root]
                memory > xnum
                memory > xpath
                seq > @
                  (((unsupported)).apply)
                    xpath.write ((xinclude_root).if (((unsupported)).apply ("$")) (((unsupported)).apply))
                    (((unsupported)).apply ((xkey_transform)) ((xkey_transforms)))
                      (((unsupported)).apply ((xValueError)))
                        xnum.write (((xint)).apply ((xkey_transform)))
                        seq
                          bogusForceDataize.write ((((xpath).xappend)).apply ("."))
                          bogusForceDataize.write ((((xpath).xappend)).apply (((((xjson).xdumps)).apply ((xkey_transform)))))
                        bogusForceDataize.write ((((xpath).xappend)).apply (("[%s]".mod (xnum))))
                    (((unsupported)).apply (((("".xjoin)).apply ((xpath)))))
            (((unsupported)).apply ((xPostgresOperatorLookup)))
              seq
                xlookup_name.write "contains"
                xpostgres_operator.write "@>"
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xparams
                    seq > @
                      seq
                        ((((xconnection).xfeatures).xsupports_json_field_contains).not).if
                          (((unsupported)).apply ((((xNotSupportedError)).apply ("contains lookup is not supported on this database backend."))))
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((xself).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        xparams.write ((((xtuple)).apply ((xlhs_params))).add (((xtuple)).apply ((xrhs_params))))
                        (((unsupported)).apply ((((unsupported)).apply (("JSON_CONTAINS(%s, %s)".mod (((unsupported)).apply ((xlhs)) ((xrhs))))) ((xparams)))))
            (((unsupported)).apply ((xPostgresOperatorLookup)))
              seq
                xlookup_name.write "contained_by"
                xpostgres_operator.write "<@"
                xas_sql.write
                  [xself xcompiler xconnection]
                    memory > xparams
                    seq > @
                      seq
                        ((((xconnection).xfeatures).xsupports_json_field_contains).not).if
                          (((unsupported)).apply ((((xNotSupportedError)).apply ("contained_by lookup is not supported on this database backend."))))
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((xself).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        xparams.write ((((xtuple)).apply ((xrhs_params))).add (((xtuple)).apply ((xlhs_params))))
                        (((unsupported)).apply ((((unsupported)).apply (("JSON_CONTAINS(%s, %s)".mod (((unsupported)).apply ((xrhs)) ((xlhs))))) ((xparams)))))
            (((unsupported)).apply ((xPostgresOperatorLookup)))
              seq
                xlogical_operator.write "None: is there a None literal in the EO language?"
                xcompile_json_path_final_key.write
                  [xself xkey_transform]
                    seq > @
                      (((unsupported)).apply ((".%s".mod ((((xjson).xdumps)).apply ((xkey_transform))))))
                xas_sql.write
                  [xself xcompiler xconnection xtemplate]
                    memory > xrhs_params
                    memory > xlhs_json_path
                    memory > xrhs_json_path
                    memory > xrhs
                    memory > xrhs_key_transforms
                    memory > xsql
                    seq > @
                      (((unsupported)).apply)
                        (((xisinstance)).apply (((xself).xlhs)) ((xKeyTransform))).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)) ((xlhs_key_transforms)))) ((((((xself).xlhs).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                            xlhs_json_path.write (((xcompile_json_path)).apply ((xlhs_key_transforms)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))) (((((xself).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                            xlhs_json_path.write "$"
                        xsql.write ((xtemplate).mod (xlhs))
                        xrhs.write ((xself).xrhs)
                        xrhs_params.write (((unsupported)).apply)
                        ((((xisinstance)).apply ((xrhs)) ((((unsupported)).apply ((xlist)) ((xtuple))))).not).if
                          xrhs.write (((unsupported)).apply ((xrhs)))
                        (((unsupported)).apply ((xkey)) ((xrhs)))
                          seq
                            (((xisinstance)).apply ((xkey)) ((xKeyTransform))).if
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((x_)))) ((xrhs_key_transforms)))) (((((xkey).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                              xrhs_key_transforms.write (((unsupported)).apply ((xkey)))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xrhs_key_transforms)))) ((xfinal_key)))) ((xrhs_key_transforms)))
                            xrhs_json_path.write (((unsupported)).apply ((xcompile_json_path)) ((xrhs_key_transforms)) ((xfalse)))
                            (((unsupported)).apply ((xrhs_json_path)) (((((xself).xcompile_json_path_final_key)).apply ((xfinal_key)))))
                            bogusForceDataize.write ((((xrhs_params).xappend)).apply (((xlhs_json_path).add (xrhs_json_path))))
                        ((xself).xlogical_operator).if
                          xsql.write ("(%s)".mod (((((xself).xlogical_operator).xjoin)).apply (((((unsupported)).apply ((xsql))).mul (((xlen)).apply ((xrhs_params)))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) (((((xtuple)).apply ((xlhs_params))).add (((xtuple)).apply ((xrhs_params))))))))
                xas_mysql.write
                  [xself xcompiler xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply (((xself).xas_sql)) ((xcompiler)) ((xconnection)) ("JSON_CONTAINS_PATH(%s, 'one', %%s)"))))
                xas_oracle.write
                  [xself xcompiler xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((unsupported)).apply (((xself).xas_sql)) ((xcompiler)) ((xconnection)) ("JSON_EXISTS(%s, '%%s')"))))
                        (((unsupported)).apply ((((unsupported)).apply (((xsql).mod (((xtuple)).apply ((xparams))))) ((((unsupported)).apply)))))
                xas_postgresql.write
                  [xself xcompiler xconnection]
                    seq > @
                      seq
                        (((xisinstance)).apply (((xself).xrhs)) ((xKeyTransform))).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((x_)))) ((xrhs_key_transforms)))) ((((((xself).xrhs).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                            (((unsupported)).apply ((xkey)) ((((unsupported)).apply ((xrhs_key_transforms)) ((((unsupported)).apply ((1.neg)))))))
                              (((unsupported)).apply (((xself).xlhs)) ((((xKeyTransform)).apply ((xkey)) (((xself).xlhs)))))
                            (((unsupported)).apply (((xself).xrhs)) ((((unsupported)).apply ((xrhs_key_transforms)) ((1.neg)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xas_postgresql)).apply ((xcompiler)) ((xconnection)))))
                xas_sqlite.write
                  [xself xcompiler xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply (((xself).xas_sql)) ((xcompiler)) ((xconnection)) ("JSON_TYPE(%s, %%s) IS NOT NULL"))))
            (((unsupported)).apply ((xHasKeyLookup)))
              seq
                xlookup_name.write "has_key"
                xpostgres_operator.write "?"
                xprepare_rhs.write (xfalse)
            (((unsupported)).apply ((xHasKeyLookup)))
              seq
                xlookup_name.write "has_keys"
                xpostgres_operator.write "?&"
                xlogical_operator.write " AND "
                xget_prep_lookup.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ((((xstr)).apply ((xitem)))) ((xitem)) (((xself).xrhs)))))
            (((unsupported)).apply ((xHasKeys)))
              seq
                xlookup_name.write "has_any_keys"
                xpostgres_operator.write "?|"
                xlogical_operator.write " OR "
            (((unsupported)).apply ((xHasKey)))
              xcompile_json_path_final_key.write
                [xself xkey_transform]
                  seq > @
                    (((unsupported)).apply ((((unsupported)).apply ((xcompile_json_path)) ((((unsupported)).apply ((xkey_transform)))) ((xfalse)))))
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                xprocess_lhs.write
                  [xself xcompiler xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))) (((((((xsuper)).apply).xprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        (((xconnection).xvendor).eq "mysql").if
                          (((unsupported)).apply ((((unsupported)).apply (("LOWER(%s)".mod (xlhs))) ((xlhs_params)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)))))
                xprocess_rhs.write
                  [xself xcompiler xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        (((xconnection).xvendor).eq "mysql").if
                          (((unsupported)).apply ((((unsupported)).apply (("LOWER(%s)".mod (xrhs))) ((xrhs_params)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))))
            (((unsupported)).apply (((xlookups).xExact)))
              seq
                xcan_use_none_as_rhs.write TRUE
                xprocess_rhs.write
                  [xself xcompiler xconnection]
                    memory > xrhs
                    memory > xrhs_params
                    memory > xfunc
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        (((xrhs).eq "%s").and ((xrhs_params).eq (((unsupported)).apply ("None: is there a None literal in the EO language?")))).if
                          xrhs_params.write (((unsupported)).apply ("null"))
                        (((xconnection).xvendor).eq "mysql").if
                          seq
                            xfunc.write ((((unsupported)).apply ("JSON_EXTRACT(%s, '$')")).mul (((xlen)).apply ((xrhs_params))))
                            xrhs.write ((xrhs).mod (((xtuple)).apply ((xfunc))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))))
            (((unsupported)).apply ((xCaseInsensitiveMixin)) (((xlookups).xIContains)))
            bogusForceDataize.write ((((xJSONField).xregister_lookup)).apply ((xDataContains)))
            bogusForceDataize.write ((((xJSONField).xregister_lookup)).apply ((xContainedBy)))
            bogusForceDataize.write ((((xJSONField).xregister_lookup)).apply ((xHasKey)))
            bogusForceDataize.write ((((xJSONField).xregister_lookup)).apply ((xHasKeys)))
            bogusForceDataize.write ((((xJSONField).xregister_lookup)).apply ((xHasAnyKeys)))
            bogusForceDataize.write ((((xJSONField).xregister_lookup)).apply ((xJSONExact)))
            bogusForceDataize.write ((((xJSONField).xregister_lookup)).apply ((xJSONIContains)))
            (((unsupported)).apply ((xTransform)))
              seq
                xpostgres_operator.write "->"
                xpostgres_nested_operator.write "#>"
                x__init__.write
                  [xself xkey_name]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xkey_name)) ((((xstr)).apply ((xkey_name)))))
                xpreprocess_lhs.write
                  [xself xcompiler xconnection]
                    memory > xprevious
                    memory > xkey_transforms
                    seq > @
                      seq
                        xkey_transforms.write (((unsupported)).apply (((xself).xkey_name)))
                        xprevious.write ((xself).xlhs)
                        while.
                          (((xisinstance)).apply ((xprevious)) ((xKeyTransform)))
                          [unused]
                            seq > @
                              seq
                                bogusForceDataize.write ((((xkey_transforms).xinsert)).apply (0) (((xprevious).xkey_name)))
                                xprevious.write ((xprevious).xlhs)
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xparams)))) (((((xcompiler).xcompile)).apply ((xprevious)))))
                        (((xconnection).xvendor).eq "oracle").if
                          xkey_transforms.write (((unsupported)).apply (((((xkey).xreplace)).apply ("%") ("%%"))) ((xkey)) ((xkey_transforms)))
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xparams)) ((xkey_transforms)))))
                xas_mysql.write
                  [xself xcompiler xconnection]
                    memory > xjson_path
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xparams)) ((xkey_transforms)))) (((((xself).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        xjson_path.write (((xcompile_json_path)).apply ((xkey_transforms)))
                        (((unsupported)).apply ((((unsupported)).apply (("JSON_EXTRACT(%s, %%s)".mod (xlhs))) (((((xtuple)).apply ((xparams))).add (((unsupported)).apply ((xjson_path))))))))
                xas_oracle.write
                  [xself xcompiler xconnection]
                    memory > xjson_path
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xparams)) ((xkey_transforms)))) (((((xself).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        xjson_path.write (((xcompile_json_path)).apply ((xkey_transforms)))
                        (((unsupported)).apply ((((unsupported)).apply (("COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))".mod ((((unsupported)).apply ((xlhs)) ((xjson_path))).mul 2))) (((((xtuple)).apply ((xparams))).mul 2)))))
                xas_postgresql.write
                  [xself xcompiler xconnection]
                    memory > xsql
                    memory > xlookup
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xparams)) ((xkey_transforms)))) (((((xself).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        ((((xlen)).apply ((xkey_transforms))).greater 1).if
                          seq
                            xsql.write ("(%s %s %%s)".mod (((unsupported)).apply ((xlhs)) (((xself).xpostgres_nested_operator))))
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) (((((xtuple)).apply ((xparams))).add (((unsupported)).apply ((xkey_transforms))))))))
                        (((unsupported)).apply ((xValueError)))
                          xlookup.write (((xint)).apply (((xself).xkey_name)))
                          xlookup.write ((xself).xkey_name)
                        (((unsupported)).apply ((((unsupported)).apply (("(%s %s %%s)".mod (((unsupported)).apply ((xlhs)) (((xself).xpostgres_operator))))) (((((xtuple)).apply ((xparams))).add (((unsupported)).apply ((xlookup))))))))
                xas_sqlite.write
                  [xself xcompiler xconnection]
                    memory > xjson_path
                    memory > xdatatype_values
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xparams)) ((xkey_transforms)))) (((((xself).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        xjson_path.write (((xcompile_json_path)).apply ((xkey_transforms)))
                        xdatatype_values.write (((",".xjoin)).apply ((((unsupported)).apply ((((xrepr)).apply ((xdatatype)))) ((xdatatype)) ((((xconnection).xops).xjsonfield_datatype_values)))))
                        (((unsupported)).apply ((((unsupported)).apply (("(CASE WHEN JSON_TYPE(%s, %%s) IN (%s) THEN JSON_TYPE(%s, %%s) ELSE JSON_EXTRACT(%s, %%s) END)".mod (((unsupported)).apply ((xlhs)) ((xdatatype_values)) ((xlhs)) ((xlhs))))) ((((((xtuple)).apply ((xparams))).add (((unsupported)).apply ((xjson_path)))).mul 3)))))
            (((unsupported)).apply ((xKeyTransform)))
              seq
                xpostgres_operator.write "->>"
                xpostgres_nested_operator.write "#>>"
            (((unsupported)).apply)
              seq
                (((unsupported)).apply)
                x__init__.write
                  [xself xkey_transform]
                    memory > xkey_text_transform
                    seq > @
                      (((unsupported)).apply)
                        ((((xisinstance)).apply ((xkey_transform)) ((xKeyTransform))).not).if
                          (((unsupported)).apply ((((xTypeError)).apply ("Transform should be an instance of KeyTransform in order to use this lookup."))))
                        xkey_text_transform.write (((xKeyTextTransform)).apply (((xkey_transform).xkey_name)) ((((unsupported)).apply (((xkey_transform).xsource_expressions)))) ((((unsupported)).apply (((xkey_transform).xextra)))))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xkey_text_transform)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
            (((unsupported)).apply (((xlookups).xIsNull)))
              seq
                xas_oracle.write
                  [xself xcompiler xconnection]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((((xHasKeyOrArrayIndex)).apply ((((xself).xlhs).xlhs)) ((((xself).xlhs).xkey_name))).xas_oracle)).apply ((xcompiler)) ((xconnection)))))
                        (((xself).xrhs).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xlhs)) ((xlhs_params)) ((x_)))) ((((((xself).xlhs).xpreprocess_lhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply (("(NOT %s OR %s IS NULL)".mod (((unsupported)).apply ((xsql)) ((xlhs))))) (((((xtuple)).apply ((xparams))).add (((xtuple)).apply ((xlhs_params))))))))
                xas_sqlite.write
                  [xself xcompiler xconnection]
                    memory > xtemplate
                    seq > @
                      seq
                        xtemplate.write "JSON_TYPE(%s, %%s) IS NULL"
                        (((xself).xrhs).not).if
                          xtemplate.write "JSON_TYPE(%s, %%s) IS NOT NULL"
                        (((unsupported)).apply ((((unsupported)).apply (((((xHasKeyOrArrayIndex)).apply ((((xself).xlhs).xlhs)) ((((xself).xlhs).xkey_name))).xas_sql)) ((xcompiler)) ((xconnection)) ((xtemplate)))))
            (((unsupported)).apply (((xlookups).xIn)))
              xresolve_expression_parameter.write
                [xself xcompiler xconnection xsql xparam]
                  memory > xvalue
                  seq > @
                    seq
                      (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((((xsuper)).apply).xresolve_expression_parameter)).apply ((xcompiler)) ((xconnection)) ((xsql)) ((xparam)))))
                      (((((xhasattr)).apply ((xparam)) ("as_sql")).not).and ((((xconnection).xfeatures).xhas_native_json_field).not)).if
                        (((xconnection).xvendor).eq "oracle").if
                          seq
                            xvalue.write ((((xjson).xloads)).apply ((xparam)))
                            xsql.write "%s(JSON_OBJECT('value' VALUE %%s FORMAT JSON), '$.value')"
                            (((xisinstance)).apply ((xvalue)) ((((unsupported)).apply ((xlist)) ((xdict))))).if
                              xsql.write ((xsql).mod "JSON_QUERY")
                              xsql.write ((xsql).mod "JSON_VALUE")
                          ((((xconnection).xvendor).eq "mysql").or ((((xconnection).xvendor).eq "sqlite").and (((unsupported)).apply ((((unsupported)).apply ((xparams)) (0))) ((((xconnection).xops).xjsonfield_datatype_values))))).if
                            xsql.write "JSON_EXTRACT(%s, '$')"
                      ((((xconnection).xvendor).eq "mysql").and ((xconnection).xmysql_is_mariadb)).if
                        xsql.write ("JSON_UNQUOTE(%s)".mod (xsql))
                      (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
            (((unsupported)).apply ((xJSONExact)))
              seq
                xprocess_rhs.write
                  [xself xcompiler xconnection]
                    memory > xsql
                    memory > xrhs
                    memory > xvalue
                    memory > xfunc
                    seq > @
                      seq
                        (((xisinstance)).apply (((xself).xrhs)) ((xKeyTransform))).if
                          (((unsupported)).apply (((((((xsuper)).apply (((xlookups).xExact)) ((xself))).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        (((xconnection).xvendor).eq "oracle").if
                          seq
                            xfunc.write (((unsupported)).apply)
                            xsql.write "%s(JSON_OBJECT('value' VALUE %%s FORMAT JSON), '$.value')"
                            (((unsupported)).apply ((xvalue)) ((xrhs_params)))
                              seq
                                xvalue.write ((((xjson).xloads)).apply ((xvalue)))
                                (((xisinstance)).apply ((xvalue)) ((((unsupported)).apply ((xlist)) ((xdict))))).if
                                  bogusForceDataize.write ((((xfunc).xappend)).apply (((xsql).mod "JSON_QUERY")))
                                  bogusForceDataize.write ((((xfunc).xappend)).apply (((xsql).mod "JSON_VALUE")))
                            xrhs.write ((xrhs).mod (((xtuple)).apply ((xfunc))))
                          (((xconnection).xvendor).eq "sqlite").if
                            seq
                              xfunc.write (((unsupported)).apply)
                              (((unsupported)).apply ((xvalue)) ((xrhs_params)))
                                (((unsupported)).apply ((xvalue)) ((((xconnection).xops).xjsonfield_datatype_values))).if
                                  bogusForceDataize.write ((((xfunc).xappend)).apply ("%s"))
                                  bogusForceDataize.write ((((xfunc).xappend)).apply ("JSON_EXTRACT(%s, '$')"))
                              xrhs.write ((xrhs).mod (((xtuple)).apply ((xfunc))))
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))))
                xas_oracle.write
                  [xself xcompiler xconnection]
                    memory > xis_null_expr
                    memory > xhas_key_expr
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                        ((xrhs_params).eq (((unsupported)).apply ("null"))).if
                          seq
                            xhas_key_expr.write (((xHasKeyOrArrayIndex)).apply ((((xself).xlhs).xlhs)) ((((xself).xlhs).xkey_name)))
                            (((unsupported)).apply ((((unsupported)).apply ((xhas_key_sql)) ((xhas_key_params)))) (((((xhas_key_expr).xas_oracle)).apply ((xcompiler)) ((xconnection)))))
                            xis_null_expr.write (((((((xself).xlhs).xget_lookup)).apply ("isnull"))).apply (((xself).xlhs)) (TRUE))
                            (((unsupported)).apply ((((unsupported)).apply ((xis_null_sql)) ((xis_null_params)))) (((((xis_null_expr).xas_sql)).apply ((xcompiler)) ((xconnection)))))
                            (((unsupported)).apply ((((unsupported)).apply (("%s AND %s".mod (((unsupported)).apply ((xhas_key_sql)) ((xis_null_sql))))) (((((xtuple)).apply ((xhas_key_params))).add (((xtuple)).apply ((xis_null_params))))))))
                        (((unsupported)).apply (((((((xsuper)).apply).xas_sql)).apply ((xcompiler)) ((xconnection)))))
            (((unsupported)).apply ((xCaseInsensitiveMixin)) ((xKeyTransformTextLookupMixin)) (((xlookups).xIExact)))
            (((unsupported)).apply ((xCaseInsensitiveMixin)) ((xKeyTransformTextLookupMixin)) (((xlookups).xIContains)))
            (((unsupported)).apply ((xKeyTransformTextLookupMixin)) (((xlookups).xStartsWith)))
            (((unsupported)).apply ((xCaseInsensitiveMixin)) ((xKeyTransformTextLookupMixin)) (((xlookups).xIStartsWith)))
            (((unsupported)).apply ((xKeyTransformTextLookupMixin)) (((xlookups).xEndsWith)))
            (((unsupported)).apply ((xCaseInsensitiveMixin)) ((xKeyTransformTextLookupMixin)) (((xlookups).xIEndsWith)))
            (((unsupported)).apply ((xKeyTransformTextLookupMixin)) (((xlookups).xRegex)))
            (((unsupported)).apply ((xCaseInsensitiveMixin)) ((xKeyTransformTextLookupMixin)) (((xlookups).xIRegex)))
            (((unsupported)).apply)
              xprocess_rhs.write
                [xself xcompiler xconnection]
                  memory > xrhs_params
                  seq > @
                    seq
                      (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))) (((((((xsuper)).apply).xprocess_rhs)).apply ((xcompiler)) ((xconnection)))))
                      ((((xconnection).xfeatures).xhas_native_json_field).not).if
                        xrhs_params.write (((unsupported)).apply (((((xjson).xloads)).apply ((xvalue)))) ((xvalue)) ((xrhs_params)))
                      (((unsupported)).apply ((((unsupported)).apply ((xrhs)) ((xrhs_params)))))
            (((unsupported)).apply ((xKeyTransformNumericLookupMixin)) (((xlookups).xLessThan)))
            (((unsupported)).apply ((xKeyTransformNumericLookupMixin)) (((xlookups).xLessThanOrEqual)))
            (((unsupported)).apply ((xKeyTransformNumericLookupMixin)) (((xlookups).xGreaterThan)))
            (((unsupported)).apply ((xKeyTransformNumericLookupMixin)) (((xlookups).xGreaterThanOrEqual)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformIn)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformExact)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformIExact)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformIsNull)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformIContains)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformStartsWith)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformIStartsWith)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformEndsWith)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformIEndsWith)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformRegex)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformIRegex)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformLt)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformLte)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformGt)))
            bogusForceDataize.write ((((xKeyTransform).xregister_lookup)).apply ((xKeyTransformGte)))
            (((unsupported)).apply)
              seq
                x__init__.write
                  [xself xkey_name]
                    seq > @
                      (((unsupported)).apply (((xself).xkey_name)) ((xkey_name)))
                x__call__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xKeyTransform)).apply (((xself).xkey_name)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))