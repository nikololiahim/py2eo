memory > xinner_query_sql
memory > xcompiler
memory > xparam_rows
memory > xsql_parts
memory > xRandom
memory > xget_order_dir
memory > xfield
memory > xf_params
memory > xlhs_params
memory > xmeta
memory > xvalues
memory > xc
memory > xtable
memory > xRef
memory > xEmptyResultSet
memory > x_lazy_re_compile
memory > xall
memory > xlist
memory > xRawSQL
memory > xindex
memory > xparent
memory > xenumerate
memory > xMULTI
memory > xsel_expr
memory > xtargets
memory > xpart_args
memory > xselect_col
memory > xValueError
memory > xparent_link
memory > xo
memory > xwhere
memory > xg_sql
memory > xstr
memory > xq
memory > xselect_index
memory > xgroup_by
memory > xFieldError
memory > xLOOKUP_SEP
memory > xt
memory > xvals
memory > xSINGLE
memory > xpos
memory > xCast
memory > xannotation
memory > xjoins
memory > xparent_model
memory > xki
memory > xexpr
memory > xo_params
memory > xCURSOR
memory > xdefault_order
memory > xpart
memory > xcollections
memory > xNotImplementedError
memory > xselect
memory > x_
memory > xalias
memory > xQuery
memory > xparent_path
memory > xextra_select
memory > xKeyError
memory > xrelated
memory > xsubselect
memory > xdistinct_result
memory > xjoin_opts
memory > xp
memory > xconverter
memory > xcol_alias
memory > xlhs_sql
memory > xo_sql
memory > xpath
memory > xany
memory > xValue
memory > xf
memory > xselect_related_descend
memory > xset
memory > xre
memory > xw_params
memory > xDatabaseError
memory > xException
memory > xr
memory > xcol
memory > xOrderBy
memory > xs_params
memory > xrows
memory > xhasattr
memory > xann_params
memory > xsum
memory > xfrom_
memory > xclause_params
memory > xi
memory > xparams
memory > xNotSupportedError
memory > xr_sql
memory > xF
memory > xcursor
memory > xplaceholder_rows
memory > xsuper
memory > xchain
memory > xs
memory > xrow
memory > xsubparams
memory > xbool
memory > xissubclass
memory > xquery
memory > xtuple
memory > xNotImplemented
memory > xargs
memory > xobj
memory > xclause_sql
memory > xconvs
memory > xTransactionManagementError
memory > xis_ref
memory > xmake_hashable
memory > xgetattr
memory > xv
memory > xinner_query_params
memory > xh_params
memory > xsql
memory > xrelated_klass_info
memory > xg_params
memory > xiter
memory > xpartial
memory > xexpression
memory > xtarget
memory > xsetattr
memory > xSQLCompiler
memory > xann_sql
memory > xname
memory > xzip
memory > xdistinct_params
memory > xidx
memory > xdistinct_fields
memory > xORDER_DIR
memory > xmap
memory > xps
memory > xupdate_params
memory > xjson
memory > xorder
memory > xNO_RESULTS
memory > xtransform_function
memory > xsource_expr
memory > xmodel
memory > xargs_parts
memory > xhaving
memory > xlen
memory > xdict
memory > xj
memory > xisinstance
memory > xTypeError
memory > xa
[] > compiler
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xget_converters
        memory > xapply_converters
        memory > xexecute_sql
        memory > xpre_sql_setup
        memory > xsetup_query
        memory > xcursor_iter
        memory > xcollapse_group_by
        memory > x_expr_refs_base_model
        memory > xget_order_by
        memory > xcontains_self_reference_subquery
        memory > xsingle_alias
        memory > xpre_save_val
        memory > xdeferred_to_columns
        memory > xreturning_params
        memory > xget_extra_select
        memory > x_as_sql
        memory > xhas_results
        memory > x__repr__
        memory > x_order_by_pairs
        memory > xfind_ordering_name
        memory > xget_related_selections
        memory > xget_combinator_sql
        memory > xresults_iter
        memory > xget_select_for_update_of_arguments
        memory > xreturning_fields
        memory > xget_distinct
        memory > xget_group_by
        memory > xas_sql
        memory > xordering_parts
        memory > xget_from_clause
        memory > xfield_as_sql
        memory > xcompile
        memory > xexplain_query
        memory > xas_subquery_condition
        memory > x_setup_joins
        memory > xprepare_value
        memory > xquote_name_unless_alias
        memory > xassemble_as_sql
        memory > x__init__
        memory > xget_select
        memory > xget_default_columns
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
              seq
                xordering_parts.write (((x_lazy_re_compile)).apply ("^(.*)s(?:ASC|DESC).*") ((((xre).xMULTILINE).or ((xre).xDOTALL))))
                x__init__.write
                  [xself xquery xconnection xusing xelide_empty]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xquery)) ((xquery)))
                        (((unsupported)).apply (((xself).xconnection)) ((xconnection)))
                        (((unsupported)).apply (((xself).xusing)) ((xusing)))
                        (((unsupported)).apply (((xself).xelide_empty)) ((xelide_empty)))
                        (((unsupported)).apply (((xself).xquote_cache)) ((((unsupported)).apply ("*") ("*"))))
                        (((unsupported)).apply (((xself).xselect)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xannotation_col_map)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).xklass_info)) ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((xself).x_meta_ordering)) ("None: is there a None literal in the EO language?"))
                x__repr__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ("<{self.__class__.__qualname__} model={self.query.model.__qualname__} connection={self.connection!r} using={self.using!r}>"))
                xsetup_query.write
                  [xself]
                    seq > @
                      seq
                        (((xall)).apply ((((unsupported)).apply (((((unsupported)).apply ((((xself).xquery).xalias_refcount)) ((xa))).eq 0)) ((xa)) ((((xself).xquery).xalias_map))))).if
                          bogusForceDataize.write (((((xself).xquery).xget_initial_alias)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xselect)) (((xself).xklass_info)) (((xself).xannotation_col_map)))) (((((xself).xget_select)).apply)))
                        (((unsupported)).apply (((xself).xcol_count)) ((((xlen)).apply (((xself).xselect)))))
                xpre_sql_setup.write
                  [xself]
                    memory > xextra_select
                    memory > xorder_by
                    memory > xgroup_by
                    seq > @
                      seq
                        (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xsetup_query)).apply)
                        xorder_by.write ((((xself).xget_order_by)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xwhere)) (((xself).xhaving)))) (((((((xself).xquery).xwhere).xsplit_having)).apply)))
                        xextra_select.write ((((xself).xget_extra_select)).apply ((xorder_by)) (((xself).xselect)))
                        (((unsupported)).apply (((xself).xhas_extra_select)) ((((xbool)).apply ((xextra_select)))))
                        xgroup_by.write ((((xself).xget_group_by)).apply ((((xself).xselect).add (xextra_select))) ((xorder_by)))
                        (((unsupported)).apply ((((unsupported)).apply ((xextra_select)) ((xorder_by)) ((xgroup_by)))))
                xget_group_by.write
                  [xself xselect xorder_by]
                    memory > xparams_hash
                    memory > xref_sources
                    memory > xhaving_group_by
                    memory > xexpressions
                    memory > xcols
                    memory > xresult
                    memory > xseen
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).xquery).xgroup_by)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xexpressions.write (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).xquery).xgroup_by)) (TRUE)).if
                          (((unsupported)).apply ((xexpr)) ((((xself).xquery).xgroup_by)))
                            ((((xhasattr)).apply ((xexpr)) ("as_sql")).not).if
                              bogusForceDataize.write ((((xexpressions).xappend)).apply ((((((xself).xquery).xresolve_ref)).apply ((xexpr)))))
                              bogusForceDataize.write ((((xexpressions).xappend)).apply ((xexpr)))
                        xref_sources.write (((unsupported)).apply (((xexpr).xsource)) ((xexpr)) ((xexpressions)) ((((xisinstance)).apply ((xexpr)) ((xRef)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xexpr)) ((x_)) ((x_)))) ((xselect)))
                          seq
                            (((unsupported)).apply ((xexpr)) ((xref_sources))).if
                              (((unsupported)).apply)
                            xcols.write ((((xexpr).xget_group_by_cols)).apply)
                            (((unsupported)).apply ((xcol)) ((xcols)))
                              bogusForceDataize.write ((((xexpressions).xappend)).apply ((xcol)))
                        (((xself).x_meta_ordering).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xexpr)) ((((unsupported)).apply ((xsql)) ((xparams)) ((xis_ref)))))) ((xorder_by)))
                            ((xis_ref).not).if
                              bogusForceDataize.write ((((xexpressions).xextend)).apply (((((xexpr).xget_group_by_cols)).apply)))
                        xhaving_group_by.write (((xself).xhaving).if (((((xself).xhaving).xget_group_by_cols)).apply) (((unsupported)).apply))
                        (((unsupported)).apply ((xexpr)) ((xhaving_group_by)))
                          bogusForceDataize.write ((((xexpressions).xappend)).apply ((xexpr)))
                        xresult.write (((unsupported)).apply)
                        xseen.write (((xset)).apply)
                        xexpressions.write ((((xself).xcollapse_group_by)).apply ((xexpressions)) ((xhaving_group_by)))
                        (((unsupported)).apply ((xexpr)) ((xexpressions)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xcompile)).apply ((xexpr)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xexpr).xselect_format)).apply ((xself)) ((xsql)) ((xparams)))))
                            xparams_hash.write (((xmake_hashable)).apply ((xparams)))
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams_hash)))) ((xseen))).if
                              seq
                                bogusForceDataize.write ((((xresult).xappend)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                                bogusForceDataize.write ((((xseen).xadd)).apply ((((unsupported)).apply ((xsql)) ((xparams_hash)))))
                        (((unsupported)).apply ((xresult)))
                xcollapse_group_by.write
                  [xself xexpressions xhaving]
                    memory > xpks
                    memory > xaliases
                    memory > xpk
                    memory > xpk_aliases
                    seq > @
                      seq
                        ((((xself).xconnection).xfeatures).xallows_group_by_pk).if
                          seq
                            xpk.write "None: is there a None literal in the EO language?"
                            (((unsupported)).apply ((xexpr)) ((xexpressions)))
                              (((((xgetattr)).apply ((xexpr)) ("target") ("None: is there a None literal in the EO language?")).eq (((((xself).xquery).xmodel).x_meta).xpk)).and ((((xgetattr)).apply ((xexpr)) ("alias") ("None: is there a None literal in the EO language?")).eq (((xself).xquery).xbase_table))).if
                                seq
                                  xpk.write (xexpr)
                                  (((unsupported)).apply)
                            (xpk).if
                              seq
                                xpk_aliases.write (((unsupported)).apply (((xexpr).xalias)) ((xexpr)) ((xexpressions)) (((((xhasattr)).apply ((xexpr)) ("target")).and (((xexpr).xtarget).xprimary_key))))
                                xexpressions.write ((((unsupported)).apply ((xpk))).add (((unsupported)).apply ((xexpr)) ((xexpr)) ((xexpressions)) (((((unsupported)).apply ((xexpr)) ((xhaving))).or ((((unsupported)).apply ((((xgetattr)).apply ((xexpr)) ("alias") ("None: is there a None literal in the EO language?"))) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply (((xexpr).xalias)) ((xpk_aliases))))))))
                          ((((xself).xconnection).xfeatures).xallows_group_by_selected_pks).if
                            seq
                              xpks.write (((unsupported)).apply ((xexpr)) ((xexpr)) ((xexpressions)) ((((((xhasattr)).apply ((xexpr)) ("target")).and (((xexpr).xtarget).xprimary_key)).and ((((((xself).xconnection).xfeatures).xallows_group_by_selected_pks_on_model)).apply ((((xexpr).xtarget).xmodel))))))
                              xaliases.write (((unsupported)).apply (((xexpr).xalias)) ((xexpr)) ((xpks)))
                              xexpressions.write (((unsupported)).apply ((xexpr)) ((xexpr)) ((xexpressions)) (((((unsupported)).apply ((xexpr)) ((xpks))).or (((unsupported)).apply ((((xgetattr)).apply ((xexpr)) ("alias") ("None: is there a None literal in the EO language?"))) ((xaliases))))))
                        (((unsupported)).apply ((xexpressions)))
                xget_select.write
                  [xself]
                    memory > xret
                    memory > xempty_result_set_value
                    memory > xselect
                    memory > xannotations
                    memory > xselect_idx
                    memory > xrelated_klass_infos
                    memory > xcols
                    memory > xget_select_from_parent
                    memory > xklass_info
                    memory > xselect_list
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xselect.write (((unsupported)).apply)
                        xklass_info.write "None: is there a None literal in the EO language?"
                        xannotations.write (((unsupported)).apply)
                        xselect_idx.write 0
                        (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((((unsupported)).apply ((xsql)) ((xparams)))))) (((((((xself).xquery).xextra_select).xitems)).apply)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xannotations)) ((xalias)))) ((xselect_idx)))
                            bogusForceDataize.write ((((xselect).xappend)).apply ((((unsupported)).apply ((((xRawSQL)).apply ((xsql)) ((xparams)))) ((xalias)))))
                            (((unsupported)).apply ((xselect_idx)) (2))
                        (((unsupported)).apply ((((((xself).xquery).xselect).and (((xself).xquery).xdefault_cols)).not)))
                        (((xself).xquery).xdefault_cols).if
                          xcols.write ((((xself).xget_default_columns)).apply)
                          xcols.write (((xself).xquery).xselect)
                        (xcols).if
                          seq
                            xselect_list.write (((unsupported)).apply)
                            (((unsupported)).apply ((xcol)) ((xcols)))
                              seq
                                bogusForceDataize.write ((((xselect_list).xappend)).apply ((xselect_idx)))
                                bogusForceDataize.write ((((xselect).xappend)).apply ((((unsupported)).apply ((xcol)) ("None: is there a None literal in the EO language?"))))
                                (((unsupported)).apply ((xselect_idx)) (2))
                            xklass_info.write (((unsupported)).apply ("model") ((((xself).xquery).xmodel)) ("select_fields") ((xselect_list)))
                        (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((xannotation)))) (((((((xself).xquery).xannotation_select).xitems)).apply)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xannotations)) ((xalias)))) ((xselect_idx)))
                            bogusForceDataize.write ((((xselect).xappend)).apply ((((unsupported)).apply ((xannotation)) ((xalias)))))
                            (((unsupported)).apply ((xselect_idx)) (2))
                        (((xself).xquery).xselect_related).if
                          seq
                            xrelated_klass_infos.write ((((xself).xget_related_selections)).apply ((xselect)))
                            (((unsupported)).apply ((((unsupported)).apply ((xklass_info)) ("related_klass_infos"))) ((xrelated_klass_infos)))
                            xget_select_from_parent.write
                              [xklass_info]
                                seq > @
                                  (((unsupported)).apply ((xki)) ((((unsupported)).apply ((xklass_info)) ("related_klass_infos"))))
                                    seq
                                      (((unsupported)).apply ((xki)) ("from_parent")).if
                                        (((unsupported)).apply ((((unsupported)).apply ((xki)) ("select_fields"))) (((((unsupported)).apply ((xklass_info)) ("select_fields")).add (((unsupported)).apply ((xki)) ("select_fields")))))
                                      bogusForceDataize.write (((xget_select_from_parent)).apply ((xki)))
                            bogusForceDataize.write (((xget_select_from_parent)).apply ((xklass_info)))
                        xret.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xcol)) ((xalias)))) ((xselect)))
                          seq
                            (((unsupported)).apply ((xEmptyResultSet)))
                              (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xcompile)).apply ((xcol)))))
                              seq
                                xempty_result_set_value.write (((xgetattr)).apply ((xcol)) ("empty_result_set_value") ((xNotImplemented)))
                                (((unsupported)).apply ((xempty_result_set_value)) ((xNotImplemented))).if
                                  (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((unsupported)).apply ("0") ((((unsupported)).apply)))))
                                  (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xcompile)).apply ((((xValue)).apply ((xempty_result_set_value)))))))
                              (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xcol).xselect_format)).apply ((xself)) ((xsql)) ((xparams)))))
                            bogusForceDataize.write ((((xret).xappend)).apply ((((unsupported)).apply ((xcol)) ((((unsupported)).apply ((xsql)) ((xparams)))) ((xalias)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xret)) ((xklass_info)) ((xannotations)))))
                x_order_by_pairs.write
                  [xself]
                    memory > xexpr
                    memory > xordering
                    memory > xfield
                    memory > xdescending
                    seq > @
                      seq
                        (((xself).xquery).xextra_order_by).if
                          xordering.write (((xself).xquery).xextra_order_by)
                          ((((xself).xquery).xdefault_ordering).not).if
                            xordering.write (((xself).xquery).xorder_by)
                            (((xself).xquery).xorder_by).if
                              xordering.write (((xself).xquery).xorder_by)
                              ((((unsupported)).apply ((((((xself).xquery).xget_meta)).apply))).and ((xmeta).xordering)).if
                                seq
                                  xordering.write ((xmeta).xordering)
                                  (((unsupported)).apply (((xself).x_meta_ordering)) ((xordering)))
                                xordering.write (((unsupported)).apply)
                        (((xself).xquery).xstandard_ordering).if
                          (((unsupported)).apply ((((unsupported)).apply ((xdefault_order)) ((x_)))) ((((unsupported)).apply ((xORDER_DIR)) ("ASC"))))
                          (((unsupported)).apply ((((unsupported)).apply ((xdefault_order)) ((x_)))) ((((unsupported)).apply ((xORDER_DIR)) ("DESC"))))
                        (((unsupported)).apply ((xfield)) ((xordering)))
                          seq
                            (((xhasattr)).apply ((xfield)) ("resolve_expression")).if
                              seq
                                (((xisinstance)).apply ((xfield)) ((xValue))).if
                                  xfield.write (((xCast)).apply ((xfield)) (((xfield).xoutput_field)))
                                ((((xisinstance)).apply ((xfield)) ((xOrderBy))).not).if
                                  xfield.write ((((xfield).xasc)).apply)
                                ((((xself).xquery).xstandard_ordering).not).if
                                  seq
                                    xfield.write ((((xfield).xcopy)).apply)
                                    bogusForceDataize.write ((((xfield).xreverse_ordering)).apply)
                                (((unsupported)).apply ((((unsupported)).apply ((xfield)) (FALSE))))
                                (((unsupported)).apply)
                            ((xfield).eq "?").if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((((xOrderBy)).apply ((((xRandom)).apply)))) (FALSE))))
                                (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xcol)) ((xorder)))) ((((xget_order_dir)).apply ((xfield)) ((xdefault_order)))))
                            xdescending.write ((xorder).eq "DESC")
                            (((unsupported)).apply ((xcol)) ((((xself).xquery).xannotation_select))).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xOrderBy)) ((((xRef)).apply ((xcol)) ((((unsupported)).apply ((((xself).xquery).xannotation_select)) ((xcol)))))) ((xdescending)))) (TRUE))))
                                (((unsupported)).apply)
                            (((unsupported)).apply ((xcol)) ((((xself).xquery).xannotations))).if
                              seq
                                ((((xself).xquery).xcombinator).and ((xself).xselect)).if
                                  xexpr.write (((xF)).apply ((xcol)))
                                  seq
                                    xexpr.write (((unsupported)).apply ((((xself).xquery).xannotations)) ((xcol)))
                                    (((xisinstance)).apply ((xexpr)) ((xValue))).if
                                      xexpr.write (((xCast)).apply ((xexpr)) (((xexpr).xoutput_field)))
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xOrderBy)) ((xexpr)) ((xdescending)))) (FALSE))))
                                (((unsupported)).apply)
                            (((unsupported)).apply (".") ((xfield))).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xtable)) ((xcol)))) (((((xcol).xsplit)).apply (".") (1))))
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xOrderBy)) ((((xRawSQL)).apply (("%s.%s".mod (((unsupported)).apply (((((xself).xquote_name_unless_alias)).apply ((xtable)))) ((xcol))))) ((((unsupported)).apply)))) ((xdescending)))) (FALSE))))
                                (((unsupported)).apply)
                            ((((xself).xquery).xextra).and (((unsupported)).apply ((xcol)) ((((xself).xquery).xextra)))).if
                              (((unsupported)).apply ((xcol)) ((((xself).xquery).xextra_select))).if
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xOrderBy)) ((((xRef)).apply ((xcol)) ((((xRawSQL)).apply ((((unsupported)).apply ((((unsupported)).apply ((((xself).xquery).xextra)) ((xcol)))))))))) ((xdescending)))) (TRUE))))
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xOrderBy)) ((((xRawSQL)).apply ((((unsupported)).apply ((((unsupported)).apply ((((xself).xquery).xextra)) ((xcol)))))))) ((xdescending)))) (FALSE))))
                              ((((xself).xquery).xcombinator).and ((xself).xselect)).if
                                (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xOrderBy)) ((((xF)).apply ((xcol)))) ((xdescending)))) (FALSE))))
                                (((unsupported)).apply ((((unsupported)).apply (((xself).xfind_ordering_name)) ((xfield)) ((((((xself).xquery).xget_meta)).apply)) ((xdefault_order)))))
                xget_order_by.write
                  [xself]
                    memory > xcol_name
                    memory > xparams_hash
                    memory > xorder_by_idx
                    memory > xexpr_src
                    memory > xwithout_ordering
                    memory > xsrc
                    memory > xresolved
                    memory > xresult
                    memory > xseen
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xresult.write (((unsupported)).apply)
                        xseen.write (((xset)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xexpr)) ((xis_ref)))) (((((xself).x_order_by_pairs)).apply)))
                          seq
                            xresolved.write (((unsupported)).apply (((xexpr).xresolve_expression)) (((xself).xquery)) (TRUE) ("None: is there a None literal in the EO language?"))
                            ((((xself).xquery).xcombinator).and ((xself).xselect)).if
                              seq
                                xsrc.write (((unsupported)).apply (((((xresolved).xget_source_expressions)).apply)) (0))
                                xexpr_src.write (((unsupported)).apply (((((xexpr).xget_source_expressions)).apply)) (0))
                                (((unsupported)).apply ((((unsupported)).apply ((xidx)) ((((unsupported)).apply ((xsel_expr)) ((x_)) ((xcol_alias)))))) ((((xenumerate)).apply (((xself).xselect)))))
                                  seq
                                    ((xis_ref).and ((xcol_alias).eq ((xsrc).xrefs))).if
                                      xsrc.write ((xsrc).xsource)
                                      ((xcol_alias).and (((((xisinstance)).apply ((xexpr_src)) ((xF))).and ((xcol_alias).eq ((xexpr_src).xname))).not)).if
                                        (((unsupported)).apply)
                                    ((xsrc).eq (xsel_expr)).if
                                      seq
                                        bogusForceDataize.write ((((xresolved).xset_source_expressions)).apply ((((unsupported)).apply ((((xRawSQL)).apply (("%d".mod ((xidx).add 1))) ((((unsupported)).apply)))))))
                                        (((unsupported)).apply)
                                  seq
                                    (xcol_alias).if
                                      (((unsupported)).apply ((((xDatabaseError)).apply ("ORDER BY term does not match any column in the result set."))))
                                    xorder_by_idx.write ((((xlen)).apply ((((xself).xquery).xselect))).add 1)
                                    xcol_name.write "__orderbycol{order_by_idx}"
                                    (((unsupported)).apply ((xq)) ((((xself).xquery).xcombined_queries)))
                                      bogusForceDataize.write ((((xq).xadd_annotation)).apply ((xexpr_src)) ((xcol_name)))
                                    bogusForceDataize.write (((((xself).xquery).xadd_select_col)).apply ((xresolved)) ((xcol_name)))
                                    bogusForceDataize.write ((((xresolved).xset_source_expressions)).apply ((((unsupported)).apply ((((xRawSQL)).apply ("{order_by_idx}") ((((unsupported)).apply)))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xcompile)).apply ((xresolved)))))
                            xwithout_ordering.write (((unsupported)).apply ((((((xself).xordering_parts).xsearch)).apply ((xsql)))) (1))
                            xparams_hash.write (((xmake_hashable)).apply ((xparams)))
                            (((unsupported)).apply ((((unsupported)).apply ((xwithout_ordering)) ((xparams_hash)))) ((xseen))).if
                              (((unsupported)).apply)
                            bogusForceDataize.write ((((xseen).xadd)).apply ((((unsupported)).apply ((xwithout_ordering)) ((xparams_hash)))))
                            bogusForceDataize.write ((((xresult).xappend)).apply ((((unsupported)).apply ((xresolved)) ((((unsupported)).apply ((xsql)) ((xparams)) ((xis_ref)))))))
                        (((unsupported)).apply ((xresult)))
                xget_extra_select.write
                  [xself xorder_by xselect]
                    memory > xselect_sql
                    memory > xwithout_ordering
                    memory > xextra_select
                    seq > @
                      seq
                        xextra_select.write (((unsupported)).apply)
                        ((((xself).xquery).xdistinct).and ((((xself).xquery).xdistinct_fields).not)).if
                          seq
                            xselect_sql.write (((unsupported)).apply ((((unsupported)).apply ((xt)) (1))) ((xt)) ((xselect)))
                            (((unsupported)).apply ((((unsupported)).apply ((xexpr)) ((((unsupported)).apply ((xsql)) ((xparams)) ((xis_ref)))))) ((xorder_by)))
                              seq
                                xwithout_ordering.write (((unsupported)).apply ((((((xself).xordering_parts).xsearch)).apply ((xsql)))) (1))
                                (((xis_ref).not).and (((unsupported)).apply ((((unsupported)).apply ((xwithout_ordering)) ((xparams)))) ((xselect_sql)))).if
                                  bogusForceDataize.write ((((xextra_select).xappend)).apply ((((unsupported)).apply ((xexpr)) ((((unsupported)).apply ((xwithout_ordering)) ((xparams)))) ("None: is there a None literal in the EO language?"))))
                        (((unsupported)).apply ((xextra_select)))
                xquote_name_unless_alias.write
                  [xself xname]
                    memory > xr
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xname)) (((xself).xquote_cache))).if
                          (((unsupported)).apply ((((unsupported)).apply (((xself).xquote_cache)) ((xname)))))
                        ((((((unsupported)).apply ((xname)) ((((xself).xquery).xalias_map))).and (((unsupported)).apply ((xname)) ((((xself).xquery).xtable_map)))).or (((unsupported)).apply ((xname)) ((((xself).xquery).xextra_select)))).or (((((((xself).xquery).xexternal_aliases).xget)).apply ((xname))).and (((unsupported)).apply ((xname)) ((((xself).xquery).xtable_map))))).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply (((xself).xquote_cache)) ((xname)))) ((xname)))
                            (((unsupported)).apply ((xname)))
                        xr.write ((((((xself).xconnection).xops).xquote_name)).apply ((xname)))
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xquote_cache)) ((xname)))) ((xr)))
                        (((unsupported)).apply ((xr)))
                xcompile.write
                  [xself xnode]
                    memory > xvendor_impl
                    seq > @
                      seq
                        xvendor_impl.write (((xgetattr)).apply ((xnode)) (("as_".add (((xself).xconnection).xvendor))) ("None: is there a None literal in the EO language?"))
                        (xvendor_impl).if
                          (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((xvendor_impl)).apply ((xself)) (((xself).xconnection)))))
                          (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xnode).xas_sql)).apply ((xself)) (((xself).xconnection)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                xget_combinator_sql.write
                  [xself xcombinator xall]
                    memory > xpart_sql
                    memory > xbraces
                    memory > xparams
                    memory > xcompilers
                    memory > xfeatures
                    memory > xresult
                    memory > xcombinator_sql
                    memory > xparts
                    seq > @
                      seq
                        xfeatures.write (((xself).xconnection).xfeatures)
                        xcompilers.write (((unsupported)).apply (((((xquery).xget_compiler)).apply (((xself).xusing)) (((xself).xconnection)) (((xself).xelide_empty)))) ((xquery)) ((((xself).xquery).xcombined_queries)) ((((((xquery).xis_empty)).apply).not)))
                        (((xfeatures).xsupports_slicing_ordering_in_compound).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((xquery)) ((xcompiler)))) ((((xzip)).apply ((((xself).xquery).xcombined_queries)) ((xcompilers)))))
                            seq
                              (((xquery).xlow_mark).or ((xquery).xhigh_mark)).if
                                (((unsupported)).apply ((((xDatabaseError)).apply ("LIMIT/OFFSET not allowed in subqueries of compound statements."))))
                              ((((xcompiler).xget_order_by)).apply).if
                                (((unsupported)).apply ((((xDatabaseError)).apply ("ORDER BY not allowed in subqueries of compound statements."))))
                        xparts.write (((unsupported)).apply)
                        (((unsupported)).apply ((xcompiler)) ((xcompilers)))
                          (((unsupported)).apply ((xEmptyResultSet)))
                            seq
                              (((((xcompiler).xquery).xvalues_select).not).and (((xself).xquery).xvalues_select)).if
                                seq
                                  (((unsupported)).apply (((xcompiler).xquery)) ((((((xcompiler).xquery).xclone)).apply)))
                                  bogusForceDataize.write (((((xcompiler).xquery).xset_values)).apply ((((unsupported)).apply ((((unsupported)).apply ((((xself).xquery).xextra_select)))) ((((unsupported)).apply ((((xself).xquery).xvalues_select)))) ((((unsupported)).apply ((((xself).xquery).xannotation_select)))))))
                              (((unsupported)).apply ((((unsupported)).apply ((xpart_sql)) ((xpart_args)))) (((((xcompiler).xas_sql)).apply)))
                              (((xcompiler).xquery).xcombinator).if
                                (((xfeatures).xsupports_parentheses_in_compound).not).if
                                  xpart_sql.write ((("SELECT * FROM ({})".xformat)).apply ((xpart_sql)))
                                  ((((xself).xquery).xsubquery).or (((xfeatures).xsupports_slicing_ordering_in_compound).not)).if
                                    xpart_sql.write ((("({})".xformat)).apply ((xpart_sql)))
                              (((unsupported)).apply ((xparts)) ((((unsupported)).apply ((((unsupported)).apply ((xpart_sql)) ((xpart_args)))))))
                            seq
                              (((xcombinator).eq "union").or (((xcombinator).eq "difference").and (xparts))).if
                                (((unsupported)).apply)
                              (((unsupported)).apply)
                        ((xparts).not).if
                          (((unsupported)).apply ((xEmptyResultSet)))
                        xcombinator_sql.write (((unsupported)).apply (((((xself).xconnection).xops).xset_operators)) ((xcombinator)))
                        ((xall).and ((xcombinator).eq "union")).if
                          (((unsupported)).apply ((xcombinator_sql)) (" ALL"))
                        xbraces.write "{}"
                        (((((xself).xquery).xsubquery).not).and ((xfeatures).xsupports_slicing_ordering_in_compound)).if
                          xbraces.write "({})"
                        (((unsupported)).apply ((((unsupported)).apply ((xsql_parts)) ((xargs_parts)))) ((((xzip)).apply ((((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((xbraces).xformat)).apply ((xsql)))) ((xargs)))) ((((unsupported)).apply ((xsql)) ((xargs)))) ((xparts)))))))))
                        xresult.write (((unsupported)).apply (((((((" {} ".xformat)).apply ((xcombinator_sql))).xjoin)).apply ((xsql_parts)))))
                        xparams.write (((unsupported)).apply)
                        (((unsupported)).apply ((xpart)) ((xargs_parts)))
                          bogusForceDataize.write ((((xparams).xextend)).apply ((xpart)))
                        (((unsupported)).apply ((((unsupported)).apply ((xresult)) ((xparams)))))
                xas_sql.write
                  [xself xwith_limits xwith_col_aliases]
                    memory > xorder_by
                    memory > xordering
                    memory > xskip_locked
                    memory > xnowait
                    memory > xcol_idx
                    memory > xof
                    memory > xno_key
                    memory > xfor_update_part
                    memory > xfeatures
                    memory > xwith_limit_offset
                    memory > xcombinator
                    memory > xalias
                    memory > xout_cols
                    memory > xrefcounts_before
                    memory > xparams
                    memory > xgrouping
                    memory > xresult
                    memory > xs_sql
                    memory > xsub_selects
                    memory > xselect_clone
                    memory > xsub_params
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xrefcounts_before.write ((((((xself).xquery).xalias_refcount).xcopy)).apply)
                        (((unsupported)).apply)
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xextra_select)) ((xorder_by)) ((xgroup_by)))) (((((xself).xpre_sql_setup)).apply)))
                            xfor_update_part.write "None: is there a None literal in the EO language?"
                            xwith_limit_offset.write ((xwith_limits).and ((((unsupported)).apply ((((xself).xquery).xhigh_mark)) ("None: is there a None literal in the EO language?")).or (((xself).xquery).xlow_mark)))
                            xcombinator.write (((xself).xquery).xcombinator)
                            xfeatures.write (((xself).xconnection).xfeatures)
                            (xcombinator).if
                              seq
                                ((((xgetattr)).apply ((xfeatures)) (((("supports_select_{}".xformat)).apply ((xcombinator))))).not).if
                                  (((unsupported)).apply ((((xNotSupportedError)).apply (((("{} is not supported on this database backend.".xformat)).apply ((xcombinator)))))))
                                (((unsupported)).apply ((((unsupported)).apply ((xresult)) ((xparams)))) (((((xself).xget_combinator_sql)).apply ((xcombinator)) ((((xself).xquery).xcombinator_all)))))
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xdistinct_fields)) ((xdistinct_params)))) (((((xself).xget_distinct)).apply)))
                                (((unsupported)).apply ((((unsupported)).apply ((xfrom_)) ((xf_params)))) (((((xself).xget_from_clause)).apply)))
                                (((unsupported)).apply ((xEmptyResultSet)))
                                  (((unsupported)).apply ((((unsupported)).apply ((xwhere)) ((xw_params)))) (((((unsupported)).apply (((xself).xwhere)) ("None: is there a None literal in the EO language?")).if ((((xself).xcompile)).apply (((xself).xwhere))) (((unsupported)).apply ("") ((((unsupported)).apply))))))
                                  seq
                                    ((xself).xelide_empty).if
                                      (((unsupported)).apply)
                                    (((unsupported)).apply ((((unsupported)).apply ((xwhere)) ((xw_params)))) ((((unsupported)).apply ("0 = 1") ((((unsupported)).apply)))))
                                (((unsupported)).apply ((((unsupported)).apply ((xhaving)) ((xh_params)))) (((((unsupported)).apply (((xself).xhaving)) ("None: is there a None literal in the EO language?")).if ((((xself).xcompile)).apply (((xself).xhaving))) (((unsupported)).apply ("") ((((unsupported)).apply))))))
                                xresult.write (((unsupported)).apply ("SELECT"))
                                xparams.write (((unsupported)).apply)
                                (((xself).xquery).xdistinct).if
                                  seq
                                    (((unsupported)).apply ((((unsupported)).apply ((xdistinct_result)) ((xdistinct_params)))) (((((((xself).xconnection).xops).xdistinct_sql)).apply ((xdistinct_fields)) ((xdistinct_params)))))
                                    (((unsupported)).apply ((xresult)) ((xdistinct_result)))
                                    (((unsupported)).apply ((xparams)) ((xdistinct_params)))
                                xout_cols.write (((unsupported)).apply)
                                xcol_idx.write 2
                                (((unsupported)).apply ((((unsupported)).apply ((x_)) ((((unsupported)).apply ((xs_sql)) ((xs_params)))) ((xalias)))) ((((xself).xselect).add (xextra_select))))
                                  seq
                                    (xalias).if
                                      xs_sql.write ("%s AS %s".mod (((unsupported)).apply ((xs_sql)) (((((((xself).xconnection).xops).xquote_name)).apply ((xalias))))))
                                      (xwith_col_aliases).if
                                        seq
                                          xs_sql.write ("%s AS %s".mod (((unsupported)).apply ((xs_sql)) (((((((xself).xconnection).xops).xquote_name)).apply (("col%d".mod (xcol_idx)))))))
                                          (((unsupported)).apply ((xcol_idx)) (2))
                                    bogusForceDataize.write ((((xparams).xextend)).apply ((xs_params)))
                                    bogusForceDataize.write ((((xout_cols).xappend)).apply ((xs_sql)))
                                (((unsupported)).apply ((xresult)) ((((unsupported)).apply ((((", ".xjoin)).apply ((xout_cols)))))))
                                (xfrom_).if
                                  (((unsupported)).apply ((xresult)) ((((unsupported)).apply ("FROM") ((((unsupported)).apply ((xfrom_)))))))
                                  ((((xself).xconnection).xfeatures).xbare_select_suffix).if
                                    (((unsupported)).apply ((xresult)) ((((unsupported)).apply (((((xself).xconnection).xfeatures).xbare_select_suffix)))))
                                bogusForceDataize.write ((((xparams).xextend)).apply ((xf_params)))
                                ((((xself).xquery).xselect_for_update).and ((xfeatures).xhas_select_for_update)).if
                                  seq
                                    (((((xself).xconnection).xget_autocommit)).apply).if
                                      (((unsupported)).apply ((((xTransactionManagementError)).apply ("select_for_update cannot be used outside of a transaction."))))
                                    ((xwith_limit_offset).and (((xfeatures).xsupports_select_for_update_with_limit).not)).if
                                      (((unsupported)).apply ((((xNotSupportedError)).apply ("LIMIT/OFFSET is not supported with select_for_update on this database backend."))))
                                    xnowait.write (((xself).xquery).xselect_for_update_nowait)
                                    xskip_locked.write (((xself).xquery).xselect_for_update_skip_locked)
                                    xof.write (((xself).xquery).xselect_for_update_of)
                                    xno_key.write (((xself).xquery).xselect_for_no_key_update)
                                    ((xnowait).and (((xfeatures).xhas_select_for_update_nowait).not)).if
                                      (((unsupported)).apply ((((xNotSupportedError)).apply ("NOWAIT is not supported on this database backend."))))
                                      ((xskip_locked).and (((xfeatures).xhas_select_for_update_skip_locked).not)).if
                                        (((unsupported)).apply ((((xNotSupportedError)).apply ("SKIP LOCKED is not supported on this database backend."))))
                                        ((xof).and (((xfeatures).xhas_select_for_update_of).not)).if
                                          (((unsupported)).apply ((((xNotSupportedError)).apply ("FOR UPDATE OF is not supported on this database backend."))))
                                          ((xno_key).and (((xfeatures).xhas_select_for_no_key_update).not)).if
                                            (((unsupported)).apply ((((xNotSupportedError)).apply ("FOR NO KEY UPDATE is not supported on this database backend."))))
                                    xfor_update_part.write (((unsupported)).apply (((((xself).xconnection).xops).xfor_update_sql)) ((xnowait)) ((xskip_locked)) (((((xself).xget_select_for_update_of_arguments)).apply)) ((xno_key)))
                                ((xfor_update_part).and ((xfeatures).xfor_update_after_from)).if
                                  bogusForceDataize.write ((((xresult).xappend)).apply ((xfor_update_part)))
                                (xwhere).if
                                  seq
                                    bogusForceDataize.write ((((xresult).xappend)).apply (("WHERE %s".mod (xwhere))))
                                    bogusForceDataize.write ((((xparams).xextend)).apply ((xw_params)))
                                xgrouping.write (((unsupported)).apply)
                                (((unsupported)).apply ((((unsupported)).apply ((xg_sql)) ((xg_params)))) ((xgroup_by)))
                                  seq
                                    bogusForceDataize.write ((((xgrouping).xappend)).apply ((xg_sql)))
                                    bogusForceDataize.write ((((xparams).xextend)).apply ((xg_params)))
                                (xgrouping).if
                                  seq
                                    (xdistinct_fields).if
                                      (((unsupported)).apply ((((xNotImplementedError)).apply ("annotate() + distinct(fields) is not implemented."))))
                                    xorder_by.write ((xorder_by).or ((((((xself).xconnection).xops).xforce_no_ordering)).apply))
                                    bogusForceDataize.write ((((xresult).xappend)).apply (("GROUP BY %s".mod (((", ".xjoin)).apply ((xgrouping))))))
                                    ((xself).x_meta_ordering).if
                                      xorder_by.write "None: is there a None literal in the EO language?"
                                (xhaving).if
                                  seq
                                    bogusForceDataize.write ((((xresult).xappend)).apply (("HAVING %s".mod (xhaving))))
                                    bogusForceDataize.write ((((xparams).xextend)).apply ((xh_params)))
                            (((xself).xquery).xexplain_info).if
                              bogusForceDataize.write ((((xresult).xinsert)).apply (0) (((((((xself).xconnection).xops).xexplain_query_prefix)).apply (((((xself).xquery).xexplain_info).xformat)) ((((unsupported)).apply (((((xself).xquery).xexplain_info).xoptions)))))))
                            (xorder_by).if
                              seq
                                xordering.write (((unsupported)).apply)
                                (((unsupported)).apply ((((unsupported)).apply ((x_)) ((((unsupported)).apply ((xo_sql)) ((xo_params)) ((x_)))))) ((xorder_by)))
                                  seq
                                    bogusForceDataize.write ((((xordering).xappend)).apply ((xo_sql)))
                                    bogusForceDataize.write ((((xparams).xextend)).apply ((xo_params)))
                                bogusForceDataize.write ((((xresult).xappend)).apply (("ORDER BY %s".mod (((", ".xjoin)).apply ((xordering))))))
                            (xwith_limit_offset).if
                              bogusForceDataize.write ((((xresult).xappend)).apply (((((((xself).xconnection).xops).xlimit_offset_sql)).apply ((((xself).xquery).xlow_mark)) ((((xself).xquery).xhigh_mark)))))
                            ((xfor_update_part).and (((xfeatures).xfor_update_after_from).not)).if
                              bogusForceDataize.write ((((xresult).xappend)).apply ((xfor_update_part)))
                            ((((xself).xquery).xsubquery).and (xextra_select)).if
                              seq
                                xsub_selects.write (((unsupported)).apply)
                                xsub_params.write (((unsupported)).apply)
                                (((unsupported)).apply ((((unsupported)).apply ((xindex)) ((((unsupported)).apply ((xselect)) ((x_)) ((xalias)))))) ((((unsupported)).apply ((xenumerate)) (((xself).xselect)) (1))))
                                  seq
                                    (((xalias).not).and (xwith_col_aliases)).if
                                      xalias.write ("col%d".mod (xindex))
                                    (xalias).if
                                      bogusForceDataize.write ((((xsub_selects).xappend)).apply (("%s.%s".mod (((unsupported)).apply (((((((xself).xconnection).xops).xquote_name)).apply ("subquery"))) (((((((xself).xconnection).xops).xquote_name)).apply ((xalias))))))))
                                      seq
                                        xselect_clone.write ((((xselect).xrelabeled_clone)).apply ((((unsupported)).apply (((xselect).xalias)) ("subquery"))))
                                        (((unsupported)).apply ((((unsupported)).apply ((xsubselect)) ((xsubparams)))) (((((xselect_clone).xas_sql)).apply ((xself)) (((xself).xconnection)))))
                                        bogusForceDataize.write ((((xsub_selects).xappend)).apply ((xsubselect)))
                                        bogusForceDataize.write ((((xsub_params).xextend)).apply ((xsubparams)))
                                (((unsupported)).apply ((((unsupported)).apply (("SELECT %s FROM (%s) subquery".mod (((unsupported)).apply ((((", ".xjoin)).apply ((xsub_selects)))) ((((" ".xjoin)).apply ((xresult))))))) ((((xtuple)).apply (((xsub_params).add (xparams))))))))
                            (((unsupported)).apply ((((unsupported)).apply ((((" ".xjoin)).apply ((xresult)))) ((((xtuple)).apply ((xparams)))))))
                          bogusForceDataize.write (((((xself).xquery).xreset_refcounts)).apply ((xrefcounts_before)))
                xget_default_columns.write
                  [xself xstart_alias xopts xfrom_parent]
                    memory > xonly_load
                    memory > xalias
                    memory > xseen_models
                    memory > xcolumn
                    memory > xresult
                    memory > xmodel
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xresult.write (((unsupported)).apply)
                        (((unsupported)).apply ((xopts)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((((((xself).xquery).xget_meta)).apply)))) ("None: is there a None literal in the EO language?")).if
                            (((unsupported)).apply ((xresult)))
                        xonly_load.write ((((xself).xdeferred_to_columns)).apply)
                        xstart_alias.write ((xstart_alias).or (((((xself).xquery).xget_initial_alias)).apply))
                        xseen_models.write (((unsupported)).apply ("None: is there a None literal in the EO language?") ((xstart_alias)))
                        (((unsupported)).apply ((xfield)) (((xopts).xconcrete_fields)))
                          seq
                            xmodel.write ((((xfield).xmodel).x_meta).xconcrete_model)
                            ((xmodel).eq ((xopts).xmodel)).if
                              xmodel.write "None: is there a None literal in the EO language?"
                            (((xfrom_parent).and (((unsupported)).apply ((xmodel)) ("None: is there a None literal in the EO language?"))).and (((xissubclass)).apply ((((xfrom_parent).x_meta).xconcrete_model)) ((((xmodel).x_meta).xconcrete_model)))).if
                              (((unsupported)).apply)
                            ((((unsupported)).apply (((xfield).xmodel)) ((xonly_load))).and (((unsupported)).apply (((xfield).xattname)) ((((unsupported)).apply ((xonly_load)) (((xfield).xmodel)))))).if
                              (((unsupported)).apply)
                            xalias.write (((((xself).xquery).xjoin_parent_model)).apply ((xopts)) ((xmodel)) ((xstart_alias)) ((xseen_models)))
                            xcolumn.write ((((xfield).xget_col)).apply ((xalias)))
                            bogusForceDataize.write ((((xresult).xappend)).apply ((xcolumn)))
                        (((unsupported)).apply ((xresult)))
                xget_distinct.write
                  [xself]
                    memory > xparts
                    memory > xopts
                    memory > xresult
                    memory > xparams
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xresult.write (((unsupported)).apply)
                        xparams.write (((unsupported)).apply)
                        xopts.write (((((xself).xquery).xget_meta)).apply)
                        (((unsupported)).apply ((xname)) ((((xself).xquery).xdistinct_fields)))
                          seq
                            xparts.write ((((xname).xsplit)).apply ((xLOOKUP_SEP)))
                            (((unsupported)).apply ((((unsupported)).apply ((x_)) ((xtargets)) ((xalias)) ((xjoins)) ((xpath)) ((x_)) ((xtransform_function)))) (((((xself).x_setup_joins)).apply ((xparts)) ((xopts)) ("None: is there a None literal in the EO language?"))))
                            (((unsupported)).apply ((((unsupported)).apply ((xtargets)) ((xalias)) ((x_)))) ((((((xself).xquery).xtrim_joins)).apply ((xtargets)) ((xjoins)) ((xpath)))))
                            (((unsupported)).apply ((xtarget)) ((xtargets)))
                              (((unsupported)).apply ((xname)) ((((xself).xquery).xannotation_select))).if
                                bogusForceDataize.write ((((xresult).xappend)).apply (((((((xself).xconnection).xops).xquote_name)).apply ((xname)))))
                                seq
                                  (((unsupported)).apply ((((unsupported)).apply ((xr)) ((xp)))) (((((xself).xcompile)).apply ((((xtransform_function)).apply ((xtarget)) ((xalias)))))))
                                  bogusForceDataize.write ((((xresult).xappend)).apply ((xr)))
                                  bogusForceDataize.write ((((xparams).xappend)).apply ((xp)))
                        (((unsupported)).apply ((((unsupported)).apply ((xresult)) ((xparams)))))
                xfind_ordering_name.write
                  [xself xname xopts xalias xdefault_order xalready_seen]
                    memory > xpieces
                    memory > xdescending
                    memory > xitem
                    memory > xresults
                    memory > xjoin_tuple
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xorder)))) ((((xget_order_dir)).apply ((xname)) ((xdefault_order)))))
                        xdescending.write ((xorder).eq "DESC")
                        xpieces.write ((((xname).xsplit)).apply ((xLOOKUP_SEP)))
                        (((unsupported)).apply ((((unsupported)).apply ((xfield)) ((xtargets)) ((xalias)) ((xjoins)) ((xpath)) ((xopts)) ((xtransform_function)))) (((((xself).x_setup_joins)).apply ((xpieces)) ((xopts)) ((xalias)))))
                        (((((xfield).xis_relation).and ((xopts).xordering)).and ((((xgetattr)).apply ((xfield)) ("attname") ("None: is there a None literal in the EO language?")).neq (((unsupported)).apply ((xpieces)) ((1.neg))))).and ((xname).neq "pk")).if
                          seq
                            xalready_seen.write ((xalready_seen).or (((xset)).apply))
                            xjoin_tuple.write (((xtuple)).apply ((((unsupported)).apply ((((xgetattr)).apply ((((unsupported)).apply ((((xself).xquery).xalias_map)) ((xj)))) ("join_cols") ("None: is there a None literal in the EO language?"))) ((xj)) ((xjoins)))))
                            (((unsupported)).apply ((xjoin_tuple)) ((xalready_seen))).if
                              (((unsupported)).apply ((((xFieldError)).apply ("Infinite loop caused by ordering."))))
                            bogusForceDataize.write ((((xalready_seen).xadd)).apply ((xjoin_tuple)))
                            xresults.write (((unsupported)).apply)
                            (((unsupported)).apply ((xitem)) (((xopts).xordering)))
                              seq
                                ((((xhasattr)).apply ((xitem)) ("resolve_expression")).and ((((xisinstance)).apply ((xitem)) ((xOrderBy))).not)).if
                                  xitem.write ((xdescending).if ((((xitem).xdesc)).apply) ((((xitem).xasc)).apply))
                                (((xisinstance)).apply ((xitem)) ((xOrderBy))).if
                                  seq
                                    bogusForceDataize.write ((((xresults).xappend)).apply ((((unsupported)).apply ((xitem)) (FALSE))))
                                    (((unsupported)).apply)
                                bogusForceDataize.write ((((xresults).xextend)).apply (((((xself).xfind_ordering_name)).apply ((xitem)) ((xopts)) ((xalias)) ((xorder)) ((xalready_seen)))))
                            (((unsupported)).apply ((xresults)))
                        (((unsupported)).apply ((((unsupported)).apply ((xtargets)) ((xalias)) ((x_)))) ((((((xself).xquery).xtrim_joins)).apply ((xtargets)) ((xjoins)) ((xpath)))))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xOrderBy)) ((((xtransform_function)).apply ((xt)) ((xalias)))) ((xdescending)))) (FALSE))) ((xt)) ((xtargets)))))
                x_setup_joins.write
                  [xself xpieces xopts xalias]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xalias.write ((xalias).or (((((xself).xquery).xget_initial_alias)).apply))
                        (((unsupported)).apply ((((unsupported)).apply ((xfield)) ((xtargets)) ((xopts)) ((xjoins)) ((xpath)) ((xtransform_function)))) ((((((xself).xquery).xsetup_joins)).apply ((xpieces)) ((xopts)) ((xalias)))))
                        xalias.write (((unsupported)).apply ((xjoins)) ((1.neg)))
                        (((unsupported)).apply ((((unsupported)).apply ((xfield)) ((xtargets)) ((xalias)) ((xjoins)) ((xpath)) ((xopts)) ((xtransform_function)))))
                xget_from_clause.write
                  [xself]
                    memory > xresult
                    memory > xparams
                    memory > xfrom_clause
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xresult.write (((unsupported)).apply)
                        xparams.write (((unsupported)).apply)
                        (((unsupported)).apply ((xalias)) ((((xtuple)).apply ((((xself).xquery).xalias_map)))))
                          seq
                            ((((unsupported)).apply ((((xself).xquery).xalias_refcount)) ((xalias))).not).if
                              (((unsupported)).apply)
                            (((unsupported)).apply ((xKeyError)))
                              xfrom_clause.write (((unsupported)).apply ((((xself).xquery).xalias_map)) ((xalias)))
                              (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xclause_sql)) ((xclause_params)))) (((((xself).xcompile)).apply ((xfrom_clause)))))
                            bogusForceDataize.write ((((xresult).xappend)).apply ((xclause_sql)))
                            bogusForceDataize.write ((((xparams).xextend)).apply ((xclause_params)))
                        (((unsupported)).apply ((xt)) ((((xself).xquery).xextra_tables)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xalias)) ((x_)))) ((((((xself).xquery).xtable_alias)).apply ((xt)))))
                            ((((unsupported)).apply ((xalias)) ((((xself).xquery).xalias_map))).or ((((unsupported)).apply ((((xself).xquery).xalias_refcount)) ((xalias))).eq 1)).if
                              bogusForceDataize.write ((((xresult).xappend)).apply ((", %s".mod ((((xself).xquote_name_unless_alias)).apply ((xalias))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xresult)) ((xparams)))))
                xget_related_selections.write
                  [xself xselect xopts xroot_alias xcur_depth xrequested xrestricted]
                    memory > xfrom_parent
                    memory > xinvalid_fields
                    memory > xalias
                    memory > x_get_field_choices
                    memory > xklass_info
                    memory > xfields_not_found
                    memory > xrelated_field_name
                    memory > xnext
                    memory > xcolumns
                    memory > xonly_load
                    memory > xlocal_setter
                    memory > xjoin_info
                    memory > xfields_found
                    memory > xrelated_klass_infos
                    memory > xremote_setter
                    memory > xfield_model
                    memory > xget_related_klass_infos
                    memory > xnext_klass_infos
                    memory > xselect_fields
                    memory > xrelated_fields
                    memory > xmodel
                    memory > xnext_requested
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        x_get_field_choices.write
                          []
                            memory > xdirect_choices
                            memory > xreverse_choices
                            seq > @
                              seq
                                xdirect_choices.write (((unsupported)).apply (((xf).xname)) ((xf)) (((xopts).xfields)) (((xf).xis_relation)))
                                xreverse_choices.write (((unsupported)).apply ((((((xf).xfield).xrelated_query_name)).apply)) ((xf)) (((xopts).xrelated_objects)) ((((xf).xfield).xunique)))
                                (((unsupported)).apply ((((xchain)).apply ((xdirect_choices)) ((xreverse_choices)) ((((xself).xquery).x_filtered_relations)))))
                        xrelated_klass_infos.write (((unsupported)).apply)
                        (((xrestricted).not).and ((xcur_depth).greater (((xself).xquery).xmax_depth))).if
                          (((unsupported)).apply ((xrelated_klass_infos)))
                        ((xopts).not).if
                          seq
                            xopts.write (((((xself).xquery).xget_meta)).apply)
                            xroot_alias.write (((((xself).xquery).xget_initial_alias)).apply)
                        xonly_load.write ((((xself).xdeferred_to_columns)).apply)
                        xfields_found.write (((xset)).apply)
                        (((unsupported)).apply ((xrequested)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xrestricted.write (((xisinstance)).apply ((((xself).xquery).xselect_related)) ((xdict)))
                            (xrestricted).if
                              xrequested.write (((xself).xquery).xselect_related)
                        xget_related_klass_infos.write
                          [xklass_info xrelated_klass_infos]
                            seq > @
                              (((unsupported)).apply ((((unsupported)).apply ((xklass_info)) ("related_klass_infos"))) ((xrelated_klass_infos)))
                        (((unsupported)).apply ((xf)) (((xopts).xfields)))
                          seq
                            xfield_model.write ((((xf).xmodel).x_meta).xconcrete_model)
                            bogusForceDataize.write ((((xfields_found).xadd)).apply (((xf).xname)))
                            (xrestricted).if
                              seq
                                xnext.write ((((xrequested).xget)).apply (((xf).xname)) ((((unsupported)).apply)))
                                (((xf).xis_relation).not).if
                                  ((xnext).or (((unsupported)).apply (((xf).xname)) ((xrequested)))).if
                                    (((unsupported)).apply ((((xFieldError)).apply (("Non-relational field given in select_related: '%s'. Choices are: %s".mod (((unsupported)).apply (((xf).xname)) (((((", ".xjoin)).apply ((((x_get_field_choices)).apply))).or "(none)"))))))))
                              xnext.write FALSE
                            ((((xselect_related_descend)).apply ((xf)) ((xrestricted)) ((xrequested)) (((((xonly_load).xget)).apply ((xfield_model))))).not).if
                              (((unsupported)).apply)
                            xklass_info.write (((unsupported)).apply ("model") ((((xf).xremote_field).xmodel)) ("field") ((xf)) ("reverse") (FALSE) ("local_setter") (((xf).xset_cached_value)) ("remote_setter") ((((xf).xunique).if (((xf).xremote_field).xset_cached_value) (((unsupported)).apply ("None: is there a None literal in the EO language?")))) ("from_parent") (FALSE))
                            bogusForceDataize.write ((((xrelated_klass_infos).xappend)).apply ((xklass_info)))
                            xselect_fields.write (((unsupported)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((x_)) ((x_)) ((x_)) ((xjoins)) ((x_)) ((x_)))) ((((((xself).xquery).xsetup_joins)).apply ((((unsupported)).apply (((xf).xname)))) ((xopts)) ((xroot_alias)))))
                            xalias.write (((unsupported)).apply ((xjoins)) ((1.neg)))
                            xcolumns.write (((unsupported)).apply (((xself).xget_default_columns)) ((xalias)) (((((xf).xremote_field).xmodel).x_meta)))
                            (((unsupported)).apply ((xcol)) ((xcolumns)))
                              seq
                                bogusForceDataize.write ((((xselect_fields).xappend)).apply ((((xlen)).apply ((xselect)))))
                                bogusForceDataize.write ((((xselect).xappend)).apply ((((unsupported)).apply ((xcol)) ("None: is there a None literal in the EO language?"))))
                            (((unsupported)).apply ((((unsupported)).apply ((xklass_info)) ("select_fields"))) ((xselect_fields)))
                            xnext_klass_infos.write ((((xself).xget_related_selections)).apply ((xselect)) (((((xf).xremote_field).xmodel).x_meta)) ((xalias)) (((xcur_depth).add 1)) ((xnext)) ((xrestricted)))
                            bogusForceDataize.write (((xget_related_klass_infos)).apply ((xklass_info)) ((xnext_klass_infos)))
                        (xrestricted).if
                          seq
                            xrelated_fields.write (((unsupported)).apply ((((unsupported)).apply (((xo).xfield)) (((xo).xrelated_model)))) ((xo)) (((xopts).xrelated_objects)) (((((xo).xfield).xunique).and (((xo).xmany_to_many).not))))
                            (((unsupported)).apply ((((unsupported)).apply ((xf)) ((xmodel)))) ((xrelated_fields)))
                              seq
                                ((((unsupported)).apply ((xselect_related_descend)) ((xf)) ((xrestricted)) ((xrequested)) (((((xonly_load).xget)).apply ((xmodel)))) (TRUE)).not).if
                                  (((unsupported)).apply)
                                xrelated_field_name.write ((((xf).xrelated_query_name)).apply)
                                bogusForceDataize.write ((((xfields_found).xadd)).apply ((xrelated_field_name)))
                                xjoin_info.write (((((xself).xquery).xsetup_joins)).apply ((((unsupported)).apply ((xrelated_field_name)))) ((xopts)) ((xroot_alias)))
                                xalias.write (((unsupported)).apply (((xjoin_info).xjoins)) ((1.neg)))
                                xfrom_parent.write ((((xissubclass)).apply ((xmodel)) (((xopts).xmodel))).and (((unsupported)).apply ((xmodel)) (((xopts).xmodel))))
                                xklass_info.write (((unsupported)).apply ("model") ((xmodel)) ("field") ((xf)) ("reverse") (TRUE) ("local_setter") ((((xf).xremote_field).xset_cached_value)) ("remote_setter") (((xf).xset_cached_value)) ("from_parent") ((xfrom_parent)))
                                bogusForceDataize.write ((((xrelated_klass_infos).xappend)).apply ((xklass_info)))
                                xselect_fields.write (((unsupported)).apply)
                                xcolumns.write (((unsupported)).apply (((xself).xget_default_columns)) ((xalias)) (((xmodel).x_meta)) (((xopts).xmodel)))
                                (((unsupported)).apply ((xcol)) ((xcolumns)))
                                  seq
                                    bogusForceDataize.write ((((xselect_fields).xappend)).apply ((((xlen)).apply ((xselect)))))
                                    bogusForceDataize.write ((((xselect).xappend)).apply ((((unsupported)).apply ((xcol)) ("None: is there a None literal in the EO language?"))))
                                (((unsupported)).apply ((((unsupported)).apply ((xklass_info)) ("select_fields"))) ((xselect_fields)))
                                xnext.write ((((xrequested).xget)).apply (((((xf).xrelated_query_name)).apply)) ((((unsupported)).apply)))
                                xnext_klass_infos.write ((((xself).xget_related_selections)).apply ((xselect)) (((xmodel).x_meta)) ((xalias)) (((xcur_depth).add 1)) ((xnext)) ((xrestricted)))
                                bogusForceDataize.write (((xget_related_klass_infos)).apply ((xklass_info)) ((xnext_klass_infos)))
                            xlocal_setter.write
                              [xobj xfrom_obj]
                                seq > @
                                  (xfrom_obj).if
                                    bogusForceDataize.write (((((xf).xremote_field).xset_cached_value)).apply ((xfrom_obj)) ((xobj)))
                            xremote_setter.write
                              [xname xobj xfrom_obj]
                                seq > @
                                  bogusForceDataize.write (((xsetattr)).apply ((xfrom_obj)) ((xname)) ((xobj)))
                            (((unsupported)).apply ((xname)) ((((xlist)).apply ((xrequested)))))
                              seq
                                ((xcur_depth).greater 1).if
                                  (((unsupported)).apply)
                                (((unsupported)).apply ((xname)) ((((xself).xquery).x_filtered_relations))).if
                                  seq
                                    bogusForceDataize.write ((((xfields_found).xadd)).apply ((xname)))
                                    (((unsupported)).apply ((((unsupported)).apply ((xf)) ((x_)) ((xjoin_opts)) ((xjoins)) ((x_)) ((x_)))) ((((((xself).xquery).xsetup_joins)).apply ((((unsupported)).apply ((xname)))) ((xopts)) ((xroot_alias)))))
                                    xmodel.write ((xjoin_opts).xmodel)
                                    xalias.write (((unsupported)).apply ((xjoins)) ((1.neg)))
                                    xfrom_parent.write ((((xissubclass)).apply ((xmodel)) (((xopts).xmodel))).and (((unsupported)).apply ((xmodel)) (((xopts).xmodel))))
                                    xklass_info.write (((unsupported)).apply ("model") ((xmodel)) ("field") ((xf)) ("reverse") (TRUE) ("local_setter") ((xlocal_setter)) ("remote_setter") ((((xpartial)).apply ((xremote_setter)) ((xname)))) ("from_parent") ((xfrom_parent)))
                                    bogusForceDataize.write ((((xrelated_klass_infos).xappend)).apply ((xklass_info)))
                                    xselect_fields.write (((unsupported)).apply)
                                    xcolumns.write (((unsupported)).apply (((xself).xget_default_columns)) ((xalias)) (((xmodel).x_meta)) (((xopts).xmodel)))
                                    (((unsupported)).apply ((xcol)) ((xcolumns)))
                                      seq
                                        bogusForceDataize.write ((((xselect_fields).xappend)).apply ((((xlen)).apply ((xselect)))))
                                        bogusForceDataize.write ((((xselect).xappend)).apply ((((unsupported)).apply ((xcol)) ("None: is there a None literal in the EO language?"))))
                                    (((unsupported)).apply ((((unsupported)).apply ((xklass_info)) ("select_fields"))) ((xselect_fields)))
                                    xnext_requested.write ((((xrequested).xget)).apply ((xname)) ((((unsupported)).apply)))
                                    xnext_klass_infos.write (((unsupported)).apply (((xself).xget_related_selections)) ((xselect)) (((xmodel).x_meta)) ((xalias)) (((xcur_depth).add 1)) ((xnext_requested)) ((xrestricted)))
                                    bogusForceDataize.write (((xget_related_klass_infos)).apply ((xklass_info)) ((xnext_klass_infos)))
                            xfields_not_found.write ((((((xset)).apply ((xrequested))).xdifference)).apply ((xfields_found)))
                            (xfields_not_found).if
                              seq
                                xinvalid_fields.write (((unsupported)).apply (("'%s'".mod (xs))) ((xs)) ((xfields_not_found)))
                                (((unsupported)).apply ((((xFieldError)).apply (("Invalid field name(s) given in select_related: %s. Choices are: %s".mod (((unsupported)).apply ((((", ".xjoin)).apply ((xinvalid_fields)))) (((((", ".xjoin)).apply ((((x_get_field_choices)).apply))).or "(none)"))))))))
                        (((unsupported)).apply ((xrelated_klass_infos)))
                xget_select_for_update_of_arguments.write
                  [xself]
                    memory > xfield
                    memory > x_get_field_choices
                    memory > xinvalid_names
                    memory > x_get_parent_klass_info
                    memory > x_get_first_selected_col_from_model
                    memory > xresult
                    memory > xklass_infos
                    memory > xklass_info
                    memory > xcol
                    seq > @
                      seq
                        (((unsupported)).apply)
                        x_get_parent_klass_info.write
                          [xklass_info]
                            memory > xparent_list
                            memory > xconcrete_model
                            seq > @
                              seq
                                xconcrete_model.write (((((unsupported)).apply ((xklass_info)) ("model")).x_meta).xconcrete_model)
                                (((unsupported)).apply ((((unsupported)).apply ((xparent_model)) ((xparent_link)))) (((((((xconcrete_model).x_meta).xparents).xitems)).apply)))
                                  seq
                                    xparent_list.write (((((xparent_model).x_meta).xget_parent_list)).apply)
                                    (((unsupported)).apply ((((unsupported)).apply ("model") ((xparent_model)) ("field") ((xparent_link)) ("reverse") (FALSE) ("select_fields") ((((unsupported)).apply ((xselect_index)) ((xselect_index)) ((((unsupported)).apply ((xklass_info)) ("select_fields"))) ((((((((unsupported)).apply ((((unsupported)).apply (((xself).xselect)) ((xselect_index)))) (0)).xtarget).xmodel).eq (xparent_model)).or (((unsupported)).apply ((((((unsupported)).apply ((((unsupported)).apply (((xself).xselect)) ((xselect_index)))) (0)).xtarget).xmodel)) ((xparent_list))))))))))
                        x_get_first_selected_col_from_model.write
                          [xklass_info]
                            memory > xconcrete_model
                            seq > @
                              seq
                                (((unsupported)).apply)
                                xconcrete_model.write (((((unsupported)).apply ((xklass_info)) ("model")).x_meta).xconcrete_model)
                                (((unsupported)).apply ((xselect_index)) ((((unsupported)).apply ((xklass_info)) ("select_fields"))))
                                  ((((((unsupported)).apply ((((unsupported)).apply (((xself).xselect)) ((xselect_index)))) (0)).xtarget).xmodel).eq (xconcrete_model)).if
                                    (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xself).xselect)) ((xselect_index)))) (0))))
                        x_get_field_choices.write
                          []
                            memory > xfield
                            memory > xqueue
                            memory > xpath
                            seq > @
                              seq
                                unsupported
                                xqueue.write ((((xcollections).xdeque)).apply ((((unsupported)).apply ((((unsupported)).apply ("None: is there a None literal in the EO language?") (((xself).xklass_info)))))))
                                while.
                                  (xqueue)
                                  [unused]
                                    seq > @
                                      seq
                                        (((unsupported)).apply ((((unsupported)).apply ((xparent_path)) ((xklass_info)))) (((((xqueue).xpopleft)).apply)))
                                        (((unsupported)).apply ((xparent_path)) ("None: is there a None literal in the EO language?")).if
                                          seq
                                            xpath.write (((unsupported)).apply)
                                            (((unsupported)).apply ("self"))
                                          seq
                                            xfield.write (((unsupported)).apply ((xklass_info)) ("field"))
                                            (((unsupported)).apply ((xklass_info)) ("reverse")).if
                                              xfield.write ((xfield).xremote_field)
                                            xpath.write ((xparent_path).add (((unsupported)).apply (((xfield).xname))))
                                            (((unsupported)).apply (((((xLOOKUP_SEP).xjoin)).apply ((xpath)))))
                                        bogusForceDataize.write ((((xqueue).xextend)).apply ((((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xklass_info)))) ((xklass_info)) ((((x_get_parent_klass_info)).apply ((xklass_info)))))))
                                        bogusForceDataize.write ((((xqueue).xextend)).apply ((((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xklass_info)))) ((xklass_info)) (((((xklass_info).xget)).apply ("related_klass_infos") ((((unsupported)).apply)))))))
                        (((xself).xklass_info).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xresult.write (((unsupported)).apply)
                        xinvalid_names.write (((unsupported)).apply)
                        (((unsupported)).apply ((xname)) ((((xself).xquery).xselect_for_update_of)))
                          seq
                            xklass_info.write ((xself).xklass_info)
                            ((xname).eq "self").if
                              xcol.write (((x_get_first_selected_col_from_model)).apply ((xklass_info)))
                              seq
                                (((unsupported)).apply ((xpart)) (((((xname).xsplit)).apply ((xLOOKUP_SEP)))))
                                  seq
                                    xklass_infos.write (((unsupported)).apply ((((unsupported)).apply (((((xklass_info).xget)).apply ("related_klass_infos") ((((unsupported)).apply)))))) ((((unsupported)).apply ((((x_get_parent_klass_info)).apply ((xklass_info)))))))
                                    (((unsupported)).apply ((xrelated_klass_info)) ((xklass_infos)))
                                      seq
                                        xfield.write (((unsupported)).apply ((xrelated_klass_info)) ("field"))
                                        (((unsupported)).apply ((xrelated_klass_info)) ("reverse")).if
                                          xfield.write ((xfield).xremote_field)
                                        (((xfield).xname).eq (xpart)).if
                                          seq
                                            xklass_info.write (xrelated_klass_info)
                                            (((unsupported)).apply)
                                      seq
                                        xklass_info.write "None: is there a None literal in the EO language?"
                                        (((unsupported)).apply)
                                (((unsupported)).apply ((xklass_info)) ("None: is there a None literal in the EO language?")).if
                                  seq
                                    bogusForceDataize.write ((((xinvalid_names).xappend)).apply ((xname)))
                                    (((unsupported)).apply)
                                xcol.write (((x_get_first_selected_col_from_model)).apply ((xklass_info)))
                            (((unsupported)).apply ((xcol)) ("None: is there a None literal in the EO language?")).if
                              ((((xself).xconnection).xfeatures).xselect_for_update_of_column).if
                                bogusForceDataize.write ((((xresult).xappend)).apply ((((unsupported)).apply (((((xself).xcompile)).apply ((xcol)))) (0))))
                                bogusForceDataize.write ((((xresult).xappend)).apply (((((xself).xquote_name_unless_alias)).apply (((xcol).xalias)))))
                        (xinvalid_names).if
                          (((unsupported)).apply ((((xFieldError)).apply (("Invalid field name(s) given in select_for_update(of=(...)): %s. Only relational fields followed in the query are allowed. Choices are: %s.".mod (((unsupported)).apply ((((", ".xjoin)).apply ((xinvalid_names)))) ((((", ".xjoin)).apply ((((x_get_field_choices)).apply))))))))))
                        (((unsupported)).apply ((xresult)))
                xdeferred_to_columns.write
                  [xself]
                    memory > xcolumns
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xcolumns.write (((unsupported)).apply)
                        bogusForceDataize.write (((((xself).xquery).xdeferred_to_data)).apply ((xcolumns)))
                        (((unsupported)).apply ((xcolumns)))
                xget_converters.write
                  [xself xexpressions]
                    memory > xfield_converters
                    memory > xconverters
                    memory > xbackend_converters
                    seq > @
                      seq
                        xconverters.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xi)) ((xexpression)))) ((((xenumerate)).apply ((xexpressions)))))
                          (xexpression).if
                            seq
                              xbackend_converters.write ((((((xself).xconnection).xops).xget_db_converters)).apply ((xexpression)))
                              xfield_converters.write ((((xexpression).xget_db_converters)).apply (((xself).xconnection)))
                              ((xbackend_converters).or (xfield_converters)).if
                                (((unsupported)).apply ((((unsupported)).apply ((xconverters)) ((xi)))) ((((unsupported)).apply (((xbackend_converters).add (xfield_converters))) ((xexpression)))))
                        (((unsupported)).apply ((xconverters)))
                xapply_converters.write
                  [xself xrows xconverters]
                    memory > xvalue
                    memory > xconnection
                    seq > @
                      seq
                        xconnection.write ((xself).xconnection)
                        xconverters.write (((xlist)).apply (((((xconverters).xitems)).apply)))
                        (((unsupported)).apply ((xrow)) ((((xmap)).apply ((xlist)) ((xrows)))))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xpos)) ((((unsupported)).apply ((xconvs)) ((xexpression)))))) ((xconverters)))
                              seq
                                xvalue.write (((unsupported)).apply ((xrow)) ((xpos)))
                                (((unsupported)).apply ((xconverter)) ((xconvs)))
                                  xvalue.write (((xconverter)).apply ((xvalue)) ((xexpression)) ((xconnection)))
                                (((unsupported)).apply ((((unsupported)).apply ((xrow)) ((xpos)))) ((xvalue)))
                            (((unsupported)).apply ((xrow)))
                xresults_iter.write
                  [xself xresults xtuple_expected xchunked_fetch xchunk_size]
                    memory > xrows
                    memory > xconverters
                    memory > xfields
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        (((unsupported)).apply ((xresults)) ("None: is there a None literal in the EO language?")).if
                          xresults.write (((unsupported)).apply (((xself).xexecute_sql)) ((xMULTI)) ((xchunked_fetch)) ((xchunk_size)))
                        xfields.write (((unsupported)).apply ((((unsupported)).apply ((xs)) (0))) ((xs)) ((((unsupported)).apply (((xself).xselect)) ((((unsupported)).apply (0) (((xself).xcol_count)))))))
                        xconverters.write ((((xself).xget_converters)).apply ((xfields)))
                        xrows.write ((((xchain).xfrom_iterable)).apply ((xresults)))
                        (xconverters).if
                          seq
                            xrows.write ((((xself).xapply_converters)).apply ((xrows)) ((xconverters)))
                            (xtuple_expected).if
                              xrows.write (((xmap)).apply ((xtuple)) ((xrows)))
                        (((unsupported)).apply ((xrows)))
                xhas_results.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xbool)).apply (((((xself).xexecute_sql)).apply ((xSINGLE)))))))
                xexecute_sql.write
                  [xself xresult_type xchunked_fetch xchunk_size]
                    memory > xcursor
                    memory > xval
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xresult_type.write ((xresult_type).or (xNO_RESULTS))
                        (((unsupported)).apply ((xEmptyResultSet)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xas_sql)).apply)))
                            ((xsql).not).if
                              (((unsupported)).apply ((xEmptyResultSet)))
                          ((xresult_type).eq (xMULTI)).if
                            (((unsupported)).apply ((((xiter)).apply ((((unsupported)).apply)))))
                            (((unsupported)).apply)
                        (xchunked_fetch).if
                          xcursor.write (((((xself).xconnection).xchunked_cursor)).apply)
                          xcursor.write (((((xself).xconnection).xcursor)).apply)
                        (((unsupported)).apply ((xException)))
                          bogusForceDataize.write ((((xcursor).xexecute)).apply ((xsql)) ((xparams)))
                          seq
                            bogusForceDataize.write ((((xcursor).xclose)).apply)
                            (((unsupported)).apply)
                        ((xresult_type).eq (xCURSOR)).if
                          (((unsupported)).apply ((xcursor)))
                        ((xresult_type).eq (xSINGLE)).if
                          (((unsupported)).apply)
                            seq
                              xval.write ((((xcursor).xfetchone)).apply)
                              (xval).if
                                (((unsupported)).apply ((((unsupported)).apply ((xval)) ((((unsupported)).apply (0) (((xself).xcol_count)))))))
                              (((unsupported)).apply ((xval)))
                            bogusForceDataize.write ((((xcursor).xclose)).apply)
                        ((xresult_type).eq (xNO_RESULTS)).if
                          seq
                            bogusForceDataize.write ((((xcursor).xclose)).apply)
                            (((unsupported)).apply)
                        xresult.write (((xcursor_iter)).apply ((xcursor)) (((((xself).xconnection).xfeatures).xempty_fetchmany_value)) ((((xself).xhas_extra_select).if ((xself).xcol_count) "None: is there a None literal in the EO language?")) ((xchunk_size)))
                        (((xchunked_fetch).not).or (((((xself).xconnection).xfeatures).xcan_use_chunked_reads).not)).if
                          (((unsupported)).apply ((((xlist)).apply ((xresult)))))
                        (((unsupported)).apply ((xresult)))
                xas_subquery_condition.write
                  [xself xalias xcolumns xcompiler]
                    memory > xqn
                    memory > xrhs
                    memory > xqn2
                    seq > @
                      seq
                        xqn.write ((xcompiler).xquote_name_unless_alias)
                        xqn2.write ((((xself).xconnection).xops).xquote_name)
                        (((unsupported)).apply ((((unsupported)).apply ((xindex)) ((xselect_col)))) ((((xenumerate)).apply ((((xself).xquery).xselect)))))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xlhs_sql)) ((xlhs_params)))) (((((xself).xcompile)).apply ((xselect_col)))))
                            xrhs.write ("%s.%s".mod (((unsupported)).apply ((((xqn)).apply ((xalias)))) ((((xqn2)).apply ((((unsupported)).apply ((xcolumns)) ((xindex))))))))
                            bogusForceDataize.write ((((((xself).xquery).xwhere).xadd)).apply ((((xRawSQL)).apply (("%s = %s".mod (((unsupported)).apply ((xlhs_sql)) ((xrhs))))) ((xlhs_params)))) ("AND"))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xas_sql)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply (("EXISTS (%s)".mod (xsql))) ((xparams)))))
                xexplain_query.write
                  [xself]
                    memory > xresult
                    memory > xoutput_formatter
                    seq > @
                      seq
                        xresult.write (((xlist)).apply (((((xself).xexecute_sql)).apply)))
                        xoutput_formatter.write ((((((xself).xquery).xexplain_info).xformat).eq "json").if ((xjson).xdumps) (xstr))
                        (((unsupported)).apply ((xrow)) ((((unsupported)).apply ((xresult)) (0))))
                          ((((xisinstance)).apply ((xrow)) ((xstr))).not).if
                            (((unsupported)).apply ((((" ".xjoin)).apply ((((unsupported)).apply ((((xoutput_formatter)).apply ((xc)))) ((xc)) ((xrow)))))))
                            (((unsupported)).apply ((xrow)))
            (((unsupported)).apply ((xSQLCompiler)))
              seq
                xreturning_fields.write "None: is there a None literal in the EO language?"
                xreturning_params.write (((xtuple)).apply)
                xfield_as_sql.write
                  [xself xfield xval]
                    memory > xparams
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xfield)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((unsupported)).apply ((xval)) ((((unsupported)).apply)))))
                          (((xhasattr)).apply ((xval)) ("as_sql")).if
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xcompile)).apply ((xval)))))
                            (((xhasattr)).apply ((xfield)) ("get_placeholder")).if
                              (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((unsupported)).apply (((((xfield).xget_placeholder)).apply ((xval)) ((xself)) (((xself).xconnection)))) ((((unsupported)).apply ((xval)))))))
                              (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((unsupported)).apply ("%s") ((((unsupported)).apply ((xval)))))))
                        xparams.write ((((((xself).xconnection).xops).xmodify_insert_params)).apply ((xsql)) ((xparams)))
                        (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
                xprepare_value.write
                  [xself xfield xvalue]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xhasattr)).apply ((xvalue)) ("resolve_expression")).if
                          seq
                            xvalue.write (((unsupported)).apply (((xvalue).xresolve_expression)) (((xself).xquery)) (FALSE) (TRUE))
                            ((xvalue).xcontains_column_references).if
                              (((unsupported)).apply ((((xValueError)).apply (("Failed to insert expression \"%s\" on %s. F() expressions can only be used to update, not to insert.".mod (((unsupported)).apply ((xvalue)) ((xfield))))))))
                            ((xvalue).xcontains_aggregate).if
                              (((unsupported)).apply ((((xFieldError)).apply (("Aggregate functions are not allowed in this query (%s=%r).".mod (((unsupported)).apply (((xfield).xname)) ((xvalue))))))))
                            ((xvalue).xcontains_over_clause).if
                              (((unsupported)).apply ((((xFieldError)).apply (("Window expressions are not allowed in this query (%s=%r).".mod (((unsupported)).apply (((xfield).xname)) ((xvalue))))))))
                          xvalue.write (((unsupported)).apply (((xfield).xget_db_prep_save)) ((xvalue)) (((xself).xconnection)))
                        (((unsupported)).apply ((xvalue)))
                xpre_save_val.write
                  [xself xfield xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xself).xquery).xraw).if
                          (((unsupported)).apply ((((xgetattr)).apply ((xobj)) (((xfield).xattname)))))
                        (((unsupported)).apply ((((unsupported)).apply (((xfield).xpre_save)) ((xobj)) (TRUE))))
                xassemble_as_sql.write
                  [xself xfields xvalue_rows]
                    memory > xparam_rows
                    memory > xsql_and_param_pair_rows
                    memory > xrows_of_fields_as_sql
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((xvalue_rows).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply)) ((((unsupported)).apply)))))
                        xrows_of_fields_as_sql.write (((unsupported)).apply ((((unsupported)).apply (((((xself).xfield_as_sql)).apply ((xfield)) ((xv)))) ((((unsupported)).apply ((xfield)) ((xv)))) ((((xzip)).apply ((xfields)) ((xrow)))))) ((xrow)) ((xvalue_rows)))
                        xsql_and_param_pair_rows.write (((unsupported)).apply ((((xzip)).apply ((((unsupported)).apply ((xrow)))))) ((xrow)) ((xrows_of_fields_as_sql)))
                        (((unsupported)).apply ((((unsupported)).apply ((xplaceholder_rows)) ((xparam_rows)))) ((((xzip)).apply ((((unsupported)).apply ((xsql_and_param_pair_rows)))))))
                        xparam_rows.write (((unsupported)).apply ((((unsupported)).apply ((xp)) ((xps)) ((xrow)) ((xp)) ((xps)))) ((xrow)) ((xparam_rows)))
                        (((unsupported)).apply ((((unsupported)).apply ((xplaceholder_rows)) ((xparam_rows)))))
                xas_sql.write
                  [xself]
                    memory > xinsert_statement
                    memory > xparams
                    memory > xresult
                    memory > xopts
                    memory > xfields
                    memory > xvalue_rows
                    memory > xon_conflict_suffix_sql
                    memory > xcan_bulk
                    memory > xqn
                    seq > @
                      seq
                        xqn.write ((((xself).xconnection).xops).xquote_name)
                        xopts.write (((((xself).xquery).xget_meta)).apply)
                        xinsert_statement.write (((unsupported)).apply (((((xself).xconnection).xops).xinsert_statement)) ((((xself).xquery).xon_conflict)))
                        xresult.write (((unsupported)).apply (("%s %s".mod (((unsupported)).apply ((xinsert_statement)) ((((xqn)).apply (((xopts).xdb_table))))))))
                        xfields.write ((((xself).xquery).xfields).or (((unsupported)).apply (((xopts).xpk))))
                        bogusForceDataize.write ((((xresult).xappend)).apply (("(%s)".mod (((", ".xjoin)).apply ((((unsupported)).apply ((((xqn)).apply (((xf).xcolumn)))) ((xf)) ((xfields))))))))
                        (((xself).xquery).xfields).if
                          xvalue_rows.write (((unsupported)).apply ((((unsupported)).apply (((((xself).xprepare_value)).apply ((xfield)) (((((xself).xpre_save_val)).apply ((xfield)) ((xobj)))))) ((xfield)) ((xfields)))) ((xobj)) ((((xself).xquery).xobjs)))
                          seq
                            xvalue_rows.write (((unsupported)).apply ((((unsupported)).apply (((((((xself).xconnection).xops).xpk_default_value)).apply)))) ((x_)) ((((xself).xquery).xobjs)))
                            xfields.write (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        xcan_bulk.write ((((xself).xreturning_fields).not).and ((((xself).xconnection).xfeatures).xhas_bulk_insert))
                        (((unsupported)).apply ((((unsupported)).apply ((xplaceholder_rows)) ((xparam_rows)))) (((((xself).xassemble_as_sql)).apply ((xfields)) ((xvalue_rows)))))
                        xon_conflict_suffix_sql.write ((((((xself).xconnection).xops).xon_conflict_suffix_sql)).apply ((xfields)) ((((xself).xquery).xon_conflict)) ((((xself).xquery).xupdate_fields)) ((((xself).xquery).xunique_fields)))
                        (((xself).xreturning_fields).and ((((xself).xconnection).xfeatures).xcan_return_columns_from_insert)).if
                          seq
                            ((((xself).xconnection).xfeatures).xcan_return_rows_from_bulk_insert).if
                              seq
                                bogusForceDataize.write ((((xresult).xappend)).apply (((((((xself).xconnection).xops).xbulk_insert_sql)).apply ((xfields)) ((xplaceholder_rows)))))
                                xparams.write (xparam_rows)
                              seq
                                bogusForceDataize.write ((((xresult).xappend)).apply (("VALUES (%s)".mod (((", ".xjoin)).apply ((((unsupported)).apply ((xplaceholder_rows)) (0)))))))
                                xparams.write (((unsupported)).apply ((((unsupported)).apply ((xparam_rows)) (0))))
                            (xon_conflict_suffix_sql).if
                              bogusForceDataize.write ((((xresult).xappend)).apply ((xon_conflict_suffix_sql)))
                            (((unsupported)).apply ((((unsupported)).apply ((xr_sql)) (((xself).xreturning_params)))) (((((((xself).xconnection).xops).xreturn_insert_columns)).apply (((xself).xreturning_fields)))))
                            (xr_sql).if
                              seq
                                bogusForceDataize.write ((((xresult).xappend)).apply ((xr_sql)))
                                (((unsupported)).apply ((xparams)) ((((unsupported)).apply (((xself).xreturning_params)))))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((" ".xjoin)).apply ((xresult)))) ((((xtuple)).apply (((((xchain).xfrom_iterable)).apply ((xparams)))))))))))
                        (xcan_bulk).if
                          seq
                            bogusForceDataize.write ((((xresult).xappend)).apply (((((((xself).xconnection).xops).xbulk_insert_sql)).apply ((xfields)) ((xplaceholder_rows)))))
                            (xon_conflict_suffix_sql).if
                              bogusForceDataize.write ((((xresult).xappend)).apply ((xon_conflict_suffix_sql)))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((" ".xjoin)).apply ((xresult)))) ((((xtuple)).apply ((((unsupported)).apply ((xp)) ((xps)) ((xparam_rows)) ((xp)) ((xps)))))))))))
                          seq
                            (xon_conflict_suffix_sql).if
                              bogusForceDataize.write ((((xresult).xappend)).apply ((xon_conflict_suffix_sql)))
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((((" ".xjoin)).apply (((xresult).add (((unsupported)).apply (("VALUES (%s)".mod (((", ".xjoin)).apply ((xp)))))))))) ((xvals)))) ((((unsupported)).apply ((xp)) ((xvals)))) ((((xzip)).apply ((xplaceholder_rows)) ((xparam_rows)))))))
                xexecute_sql.write
                  [xself xreturning_fields]
                    memory > xrows
                    memory > xconverters
                    memory > xopts
                    memory > xcols
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xreturning_fields).and ((((xlen)).apply ((((xself).xquery).xobjs))).neq 1)).and (((((xself).xconnection).xfeatures).xcan_return_rows_from_bulk_insert).not)).not)))
                        xopts.write (((((xself).xquery).xget_meta)).apply)
                        (((unsupported)).apply (((xself).xreturning_fields)) ((xreturning_fields)))
                        (((unsupported)).apply ((((((xself).xconnection).xcursor)).apply)) ((xcursor)))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xas_sql)).apply)))
                              bogusForceDataize.write ((((xcursor).xexecute)).apply ((xsql)) ((xparams)))
                            (((xself).xreturning_fields).not).if
                              (((unsupported)).apply ((((unsupported)).apply)))
                            (((((xself).xconnection).xfeatures).xcan_return_rows_from_bulk_insert).and ((((xlen)).apply ((((xself).xquery).xobjs))).greater 1)).if
                              xrows.write ((((((xself).xconnection).xops).xfetch_returned_insert_rows)).apply ((xcursor)))
                              ((((xself).xconnection).xfeatures).xcan_return_columns_from_insert).if
                                seq
                                  (((unsupported)).apply (((((xlen)).apply ((((xself).xquery).xobjs))).eq 1)))
                                  xrows.write (((unsupported)).apply (((((((xself).xconnection).xops).xfetch_returned_insert_columns)).apply ((xcursor)) (((xself).xreturning_params)))))
                                xrows.write (((unsupported)).apply ((((unsupported)).apply (((((((xself).xconnection).xops).xlast_insert_id)).apply ((xcursor)) (((xopts).xdb_table)) ((((xopts).xpk).xcolumn)))))))
                        xcols.write (((unsupported)).apply (((((xfield).xget_col)).apply (((xopts).xdb_table)))) ((xfield)) (((xself).xreturning_fields)))
                        xconverters.write ((((xself).xget_converters)).apply ((xcols)))
                        (xconverters).if
                          xrows.write (((xlist)).apply (((((xself).xapply_converters)).apply ((xrows)) ((xconverters)))))
                        (((unsupported)).apply ((xrows)))
            (((unsupported)).apply ((xSQLCompiler)))
              seq
                xsingle_alias.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write (((((xself).xquery).xget_initial_alias)).apply)
                        (((unsupported)).apply (((((xsum)).apply ((((unsupported)).apply (((((unsupported)).apply ((((xself).xquery).xalias_refcount)) ((xt))).greater 0)) ((xt)) ((((xself).xquery).xalias_map))))).eq 1)))
                x_expr_refs_base_model.write
                  [xcls xexpr xbase_model]
                    seq > @
                      (((unsupported)).apply)
                        (((xisinstance)).apply ((xexpr)) ((xQuery))).if
                          (((unsupported)).apply ((((xexpr).xmodel).eq (xbase_model))))
                        ((((xhasattr)).apply ((xexpr)) ("get_source_expressions")).not).if
                          (((unsupported)).apply (FALSE))
                        (((unsupported)).apply ((((xany)).apply ((((unsupported)).apply (((((xcls).x_expr_refs_base_model)).apply ((xsource_expr)) ((xbase_model)))) ((xsource_expr)) (((((xexpr).xget_source_expressions)).apply)))))))
                xcontains_self_reference_subquery.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xany)).apply ((((unsupported)).apply (((((xself).x_expr_refs_base_model)).apply ((xexpr)) ((((xself).xquery).xmodel)))) ((xexpr)) ((((xchain)).apply (((((((xself).xquery).xannotations).xvalues)).apply)) (((((xself).xquery).xwhere).xchildren)))))))))
                x_as_sql.write
                  [xself xquery]
                    memory > xresult
                    seq > @
                      seq
                        xresult.write (((unsupported)).apply (("DELETE FROM %s".mod ((((xself).xquote_name_unless_alias)).apply (((xquery).xbase_table))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xwhere)) ((xparams)))) (((((xself).xcompile)).apply (((xquery).xwhere)))))
                        (xwhere).if
                          bogusForceDataize.write ((((xresult).xappend)).apply (("WHERE %s".mod (xwhere))))
                        (((unsupported)).apply ((((unsupported)).apply ((((" ".xjoin)).apply ((xresult)))) ((((xtuple)).apply ((xparams)))))))
                xas_sql.write
                  [xself]
                    memory > xouterq
                    memory > xinnerq
                    memory > xpk
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xself).xsingle_alias).and (((xself).xcontains_self_reference_subquery).not)).if
                          (((unsupported)).apply (((((xself).x_as_sql)).apply (((xself).xquery)))))
                        xinnerq.write (((((xself).xquery).xclone)).apply)
                        (((unsupported)).apply (((xinnerq).x__class__)) ((xQuery)))
                        bogusForceDataize.write ((((xinnerq).xclear_select_clause)).apply)
                        xpk.write (((((xself).xquery).xmodel).x_meta).xpk)
                        (((unsupported)).apply (((xinnerq).xselect)) ((((unsupported)).apply (((((xpk).xget_col)).apply ((((((xself).xquery).xget_initial_alias)).apply)))))))
                        xouterq.write (((xQuery)).apply ((((xself).xquery).xmodel)))
                        (((((xself).xconnection).xfeatures).xupdate_can_self_select).not).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((((unsupported)).apply (((xinnerq).xget_compiler)) (((xself).xconnection))).xas_sql)).apply)))
                            xinnerq.write (((xRawSQL)).apply (("SELECT * FROM (%s) subquery".mod (xsql))) ((xparams)))
                        bogusForceDataize.write ((((xouterq).xadd_filter)).apply ("pk__in") ((xinnerq)))
                        (((unsupported)).apply (((((xself).x_as_sql)).apply ((xouterq)))))
            (((unsupported)).apply ((xSQLCompiler)))
              seq
                xas_sql.write
                  [xself]
                    memory > xtable
                    memory > xplaceholder
                    memory > xval
                    memory > xname
                    memory > xresult
                    memory > xqn
                    seq > @
                      seq
                        (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xpre_sql_setup)).apply)
                        ((((xself).xquery).xvalues).not).if
                          (((unsupported)).apply ((((unsupported)).apply ("") ((((unsupported)).apply)))))
                        xqn.write ((xself).xquote_name_unless_alias)
                        (((unsupported)).apply ((((unsupported)).apply ((xvalues)) ((xupdate_params)))) ((((unsupported)).apply ((((unsupported)).apply)) ((((unsupported)).apply)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xfield)) ((xmodel)) ((xval)))) ((((xself).xquery).xvalues)))
                          seq
                            (((xhasattr)).apply ((xval)) ("resolve_expression")).if
                              seq
                                xval.write (((unsupported)).apply (((xval).xresolve_expression)) (((xself).xquery)) (FALSE) (TRUE))
                                ((xval).xcontains_aggregate).if
                                  (((unsupported)).apply ((((xFieldError)).apply (("Aggregate functions are not allowed in this query (%s=%r).".mod (((unsupported)).apply (((xfield).xname)) ((xval))))))))
                                ((xval).xcontains_over_clause).if
                                  (((unsupported)).apply ((((xFieldError)).apply (("Window expressions are not allowed in this query (%s=%r).".mod (((unsupported)).apply (((xfield).xname)) ((xval))))))))
                              (((xhasattr)).apply ((xval)) ("prepare_database_save")).if
                                ((xfield).xremote_field).if
                                  xval.write (((unsupported)).apply (((xfield).xget_db_prep_save)) (((((xval).xprepare_database_save)).apply ((xfield)))) (((xself).xconnection)))
                                  (((unsupported)).apply ((((xTypeError)).apply (("Tried to update field %s with a model instance, %r. Use a value compatible with %s.".mod (((unsupported)).apply ((xfield)) ((xval)) ((((xfield).x__class__).x__name__))))))))
                                xval.write (((unsupported)).apply (((xfield).xget_db_prep_save)) ((xval)) (((xself).xconnection)))
                            (((xhasattr)).apply ((xfield)) ("get_placeholder")).if
                              xplaceholder.write ((((xfield).xget_placeholder)).apply ((xval)) ((xself)) (((xself).xconnection)))
                              xplaceholder.write "%s"
                            xname.write ((xfield).xcolumn)
                            (((xhasattr)).apply ((xval)) ("as_sql")).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) (((((xself).xcompile)).apply ((xval)))))
                                bogusForceDataize.write ((((xvalues).xappend)).apply (("%s = %s".mod (((unsupported)).apply ((((xqn)).apply ((xname)))) (((xplaceholder).mod (xsql)))))))
                                bogusForceDataize.write ((((xupdate_params).xextend)).apply ((xparams)))
                              (((unsupported)).apply ((xval)) ("None: is there a None literal in the EO language?")).if
                                seq
                                  bogusForceDataize.write ((((xvalues).xappend)).apply (("%s = %s".mod (((unsupported)).apply ((((xqn)).apply ((xname)))) ((xplaceholder))))))
                                  bogusForceDataize.write ((((xupdate_params).xappend)).apply ((xval)))
                                bogusForceDataize.write ((((xvalues).xappend)).apply (("%s = NULL".mod (((xqn)).apply ((xname))))))
                        xtable.write (((xself).xquery).xbase_table)
                        xresult.write (((unsupported)).apply (("UPDATE %s SET".mod (((xqn)).apply ((xtable))))) ((((", ".xjoin)).apply ((xvalues)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xwhere)) ((xparams)))) (((((xself).xcompile)).apply ((((xself).xquery).xwhere)))))
                        (xwhere).if
                          bogusForceDataize.write ((((xresult).xappend)).apply (("WHERE %s".mod (xwhere))))
                        (((unsupported)).apply ((((unsupported)).apply ((((" ".xjoin)).apply ((xresult)))) ((((xtuple)).apply (((xupdate_params).add (xparams))))))))
                xexecute_sql.write
                  [xself xresult_type]
                    memory > xcursor
                    memory > xrows
                    memory > xis_empty
                    memory > xaux_rows
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xcursor.write ((((((xsuper)).apply).xexecute_sql)).apply ((xresult_type)))
                        (((unsupported)).apply)
                          seq
                            xrows.write ((xcursor).if ((xcursor).xrowcount) 0)
                            xis_empty.write (((unsupported)).apply ((xcursor)) ("None: is there a None literal in the EO language?"))
                          (xcursor).if
                            bogusForceDataize.write ((((xcursor).xclose)).apply)
                        (((unsupported)).apply ((xquery)) ((((((xself).xquery).xget_related_updates)).apply)))
                          seq
                            xaux_rows.write (((((((xquery).xget_compiler)).apply (((xself).xusing))).xexecute_sql)).apply ((xresult_type)))
                            ((xis_empty).and (xaux_rows)).if
                              seq
                                xrows.write (xaux_rows)
                                xis_empty.write FALSE
                        (((unsupported)).apply ((xrows)))
                xpre_sql_setup.write
                  [xself]
                    memory > xmeta
                    memory > xcount
                    memory > xrelated_ids_index
                    memory > xidents
                    memory > xmust_pre_select
                    memory > xrefcounts_before
                    memory > xquery
                    memory > xrelated_ids
                    memory > xfields
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xrefcounts_before.write ((((((xself).xquery).xalias_refcount).xcopy)).apply)
                        bogusForceDataize.write (((((xself).xquery).xget_initial_alias)).apply)
                        xcount.write (((((xself).xquery).xcount_active_tables)).apply)
                        (((((xself).xquery).xrelated_updates).not).and ((xcount).eq 1)).if
                          (((unsupported)).apply)
                        xquery.write (((unsupported)).apply ((((xself).xquery).xchain)) ((xQuery)))
                        (((unsupported)).apply (((xquery).xselect_related)) (FALSE))
                        (((unsupported)).apply (((xquery).xclear_ordering)) (TRUE))
                        (((unsupported)).apply (((xquery).xextra)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xquery).xselect)) ((((unsupported)).apply)))
                        xmeta.write ((((xquery).xget_meta)).apply)
                        xfields.write (((unsupported)).apply ((((xmeta).xpk).xname)))
                        xrelated_ids_index.write (((unsupported)).apply)
                        (((unsupported)).apply ((xrelated)) ((((xself).xquery).xrelated_updates)))
                          (((xall)).apply ((((unsupported)).apply ((((xpath).xjoin_field).xprimary_key)) ((xpath)) (((((xmeta).xget_path_to_parent)).apply ((xrelated))))))).if
                            bogusForceDataize.write ((((xrelated_ids_index).xappend)).apply ((((unsupported)).apply ((xrelated)) (0))))
                            seq
                              bogusForceDataize.write ((((xrelated_ids_index).xappend)).apply ((((unsupported)).apply ((xrelated)) ((((xlen)).apply ((xfields)))))))
                              bogusForceDataize.write ((((xfields).xappend)).apply (((((xrelated).x_meta).xpk).xname)))
                        bogusForceDataize.write ((((xquery).xadd_fields)).apply ((xfields)))
                        bogusForceDataize.write ((((((xsuper)).apply).xpre_sql_setup)).apply)
                        xmust_pre_select.write (((xcount).greater 1).and (((((xself).xconnection).xfeatures).xupdate_can_self_select).not))
                        bogusForceDataize.write (((((xself).xquery).xclear_where)).apply)
                        ((((xself).xquery).xrelated_updates).or (xmust_pre_select)).if
                          seq
                            xidents.write (((unsupported)).apply)
                            xrelated_ids.write ((((xcollections).xdefaultdict)).apply ((xlist)))
                            (((unsupported)).apply ((xrows)) ((((((((xquery).xget_compiler)).apply (((xself).xusing))).xexecute_sql)).apply ((xMULTI)))))
                              seq
                                bogusForceDataize.write ((((xidents).xextend)).apply ((((unsupported)).apply ((((unsupported)).apply ((xr)) (0))) ((xr)) ((xrows)))))
                                (((unsupported)).apply ((((unsupported)).apply ((xparent)) ((xindex)))) ((xrelated_ids_index)))
                                  bogusForceDataize.write ((((((unsupported)).apply ((xrelated_ids)) ((xparent))).xextend)).apply ((((unsupported)).apply ((((unsupported)).apply ((xr)) ((xindex)))) ((xr)) ((xrows)))))
                            bogusForceDataize.write (((((xself).xquery).xadd_filter)).apply ("pk__in") ((xidents)))
                            (((unsupported)).apply ((((xself).xquery).xrelated_ids)) ((xrelated_ids)))
                          bogusForceDataize.write (((((xself).xquery).xadd_filter)).apply ("pk__in") ((xquery)))
                        bogusForceDataize.write (((((xself).xquery).xreset_refcounts)).apply ((xrefcounts_before)))
            (((unsupported)).apply ((xSQLCompiler)))
              xas_sql.write
                [xself]
                  memory > xsql
                  memory > xparams
                  seq > @
                    seq
                      (((unsupported)).apply)
                      (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))) ((((unsupported)).apply ((((unsupported)).apply)) ((((unsupported)).apply)))))
                      (((unsupported)).apply ((xannotation)) (((((((xself).xquery).xannotation_select).xvalues)).apply)))
                        seq
                          (((unsupported)).apply ((((unsupported)).apply ((xann_sql)) ((xann_params)))) (((((xself).xcompile)).apply ((xannotation)))))
                          (((unsupported)).apply ((((unsupported)).apply ((xann_sql)) ((xann_params)))) (((((xannotation).xselect_format)).apply ((xself)) ((xann_sql)) ((xann_params)))))
                          bogusForceDataize.write ((((xsql).xappend)).apply ((xann_sql)))
                          bogusForceDataize.write ((((xparams).xextend)).apply ((xann_params)))
                      (((unsupported)).apply (((xself).xcol_count)) ((((xlen)).apply ((((xself).xquery).xannotation_select)))))
                      xsql.write (((", ".xjoin)).apply ((xsql)))
                      xparams.write (((xtuple)).apply ((xparams)))
                      (((unsupported)).apply ((((unsupported)).apply ((xinner_query_sql)) ((xinner_query_params)))) ((((unsupported)).apply (((((unsupported)).apply (((((xself).xquery).xinner_query).xget_compiler)) (((xself).xusing)) (((xself).xelide_empty))).xas_sql)) (TRUE))))
                      xsql.write ("SELECT %s FROM (%s) subquery".mod (((unsupported)).apply ((xsql)) ((xinner_query_sql))))
                      xparams.write ((xparams).add (xinner_query_params))
                      (((unsupported)).apply ((((unsupported)).apply ((xsql)) ((xparams)))))
            xcursor_iter.write
              [xcursor xsentinel xcol_count xitersize]
                seq > @
                  seq
                    (((unsupported)).apply)
                    (((unsupported)).apply)
                      (((unsupported)).apply ((xrows)) ((((xiter)).apply ((((unsupported)).apply (((((xcursor).xfetchmany)).apply ((xitersize)))))) ((xsentinel)))))
                        (((unsupported)).apply (((((unsupported)).apply ((xcol_count)) ("None: is there a None literal in the EO language?")).if (xrows) (((unsupported)).apply ((((unsupported)).apply ((xr)) ((((unsupported)).apply ((xcol_count)))))) ((xr)) ((xrows))))))
                      bogusForceDataize.write ((((xcursor).xclose)).apply)