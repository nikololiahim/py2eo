memory > xPathInfo
memory > xuc
memory > xForeignKeyDeferredAttribute
memory > xForeignObjectRel
memory > xTypeError
memory > xForwardOneToOneDescriptor
memory > xinspect
memory > xCASCADE
memory > xRelatedGreaterThan
memory > xrelated_models
memory > xu
memory > xto_field
memory > xfield
memory > xut
memory > xforms
memory > xAttributeError
memory > xReverseManyToOneDescriptor
memory > xRelatedIn
memory > xtarget_field_name
memory > xRelatedLessThanOrEqual
memory > xForeignKey
memory > xlist
memory > xrel
memory > xlhs_field
memory > xindex
memory > xparent
memory > xValueError
memory > xRelatedIsNull
memory > xfrozenset
memory > xstr
memory > xchecks
memory > xattname
memory > xQ
memory > xsource_field_name
memory > xapps
memory > xManyToManyDescriptor
memory > xLOOKUP_SEP
memory > xrange
memory > xmake_model_tuple
memory > xfrom_field
memory > xrouter
memory > xRelatedGreaterThanOrEqual
memory > xapp_label
memory > xSET_NULL
memory > xReverseOneToOneDescriptor
memory > xthrough
memory > xField
memory > xconnection
memory > xkeyword
memory > xclash_field
memory > xexceptions
memory > xSET_DEFAULT
memory > xany
memory > xRelatedField
memory > xtype
memory > xOneToOneRel
memory > xcallable
memory > xpath
memory > xf
memory > xRelatedExact
memory > xsettings
memory > xr
memory > xhasattr
memory > xsum
memory > xi
memory > xForwardManyToOneDescriptor
memory > xsuper
memory > xManyToManyRel
memory > xissubclass
memory > xm
memory > xtuple
memory > xForeignObject
memory > xutils
memory > xargs
memory > xrel_field
memory > xmodel_name
memory > xSettingsReference
memory > xrh_field
memory > xFieldCacheMixin
memory > xcolumn
memory > xgetattr
memory > xrhs_field
memory > xpartial
memory > xRelatedLessThan
memory > xtarget
memory > xModelBase
memory > xsetattr
memory > xname
memory > xsource
memory > xlh_field
memory > xmodels
memory > xerror_class
memory > xerror_id
memory > xManyToOneRel
memory > xkwargs
memory > xisinstance
memory > xfield_name
memory > xlen
memory > xdict
[] > related
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > x_check_related_name_is_valid
        memory > xsave_form_data
        memory > x_check_related_query_name_is_valid
        memory > x_get_m2m_reverse_attr
        memory > xvalue_from_object
        memory > xRECURSIVE_RELATIONSHIP_CONSTANT
        memory > x_check_table_uniqueness
        memory > x_get_path_info
        memory > x_check_on_delete
        memory > xget_extra_descriptor_filter
        memory > xcontribute_to_class
        memory > xreverse_path_infos
        memory > xforeign_related_fields
        memory > xcontribute_to_related_class
        memory > xresolve_related_fields
        memory > xrequires_unique_target
        memory > xformfield
        memory > xget_extra_restriction
        memory > xconvert_empty_strings
        memory > xresolve_relation
        memory > xdb_parameters
        memory > xget_lookups
        memory > xcreate_many_to_many_intermediary_model
        memory > x_check_unique
        memory > xget_db_prep_value
        memory > xmany_to_one
        memory > xget_col
        memory > xcheck
        memory > x_get_m2m_attr
        memory > xone_to_one
        memory > x_check_ignored_options
        memory > xget_local_related_value
        memory > xget_path_info
        memory > xget_foreign_related_value
        memory > xdo_related_class
        memory > xtarget_field
        memory > xdescription
        memory > xset_attributes_from_rel
        memory > x_
        memory > xget_db_converters
        memory > xget_cache_name
        memory > xforward_related_accessor_class
        memory > xget_default
        memory > xmany_to_many
        memory > xone_to_many
        memory > xget_db_prep_save
        memory > xempty_strings_allowed
        memory > xrelated_query_name
        memory > xto_python
        memory > xget_attname_column
        memory > xget_reverse_path_info
        memory > xvalidate
        memory > xrelated_accessor_class
        memory > xget_limit_choices_to
        memory > xlazy_related_operation
        memory > xget_joining_columns
        memory > x_check_referencing_to_swapped_model
        memory > xdb_type
        memory > xget_forward_related_filter
        memory > xdeconstruct
        memory > xget_attname
        memory > x__init__
        memory > xdescriptor_class
        memory > x_check_unique_target
        memory > xget_reverse_related_filter
        memory > xrelated_model
        memory > xget_reverse_joining_columns
        memory > xlocal_related_fields
        memory > xreverse_related_fields
        memory > x_check_clashes
        memory > xget_prep_value
        memory > xrelated_fields
        memory > x_check_relation_model_exists
        memory > x_get_m2m_db_table
        memory > xdefault_error_messages
        memory > xdb_check
        memory > x_check_relationship_model
        memory > xswappable_setting
        memory > x_check_to_fields_exist
        memory > xrel_class
        memory > xget_instance_value_for_fields
        memory > x__copy__
        memory > xpath_infos
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            xRECURSIVE_RELATIONSHIP_CONSTANT.write "self"
            xresolve_relation.write
              [xscope_model xrelation]
                seq > @
                  seq
                    (((unsupported)).apply)
                    ((xrelation).eq (xRECURSIVE_RELATIONSHIP_CONSTANT)).if
                      xrelation.write (xscope_model)
                    (((xisinstance)).apply ((xrelation)) ((xstr))).if
                      (((unsupported)).apply (".") ((xrelation))).if
                        xrelation.write ("%s.%s".mod (((unsupported)).apply ((((xscope_model).x_meta).xapp_label)) ((xrelation))))
                    (((unsupported)).apply ((xrelation)))
            xlazy_related_operation.write
              [xfunction xmodel]
                memory > xmodels
                memory > xapps
                memory > xmodel_keys
                seq > @
                  (((unsupported)).apply)
                    (((unsupported)).apply)
                    xmodels.write ((((unsupported)).apply ((xmodel))).sub (((unsupported)).apply ((((xresolve_relation)).apply ((xmodel)) ((xrel)))) ((xrel)) ((xrelated_models))))
                    xmodel_keys.write (((unsupported)).apply ((((xmake_model_tuple)).apply ((xm)))) ((xm)) ((xmodels)))
                    xapps.write (((xmodel).x_meta).xapps)
                    (((unsupported)).apply (((((xapps).xlazy_model_operation)).apply ((((xpartial)).apply ((xfunction)) ((((unsupported)).apply ((xkwargs)))))) ((((unsupported)).apply ((xmodel_keys)))))))
            (((unsupported)).apply ((xFieldCacheMixin)) ((xField)))
              seq
                unsupported
                xone_to_many.write FALSE
                xone_to_one.write FALSE
                xmany_to_many.write FALSE
                xmany_to_one.write FALSE
                x__init__.write
                  [xself xrelated_name xrelated_query_name xlimit_choices_to]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).x_related_name)) ((xrelated_name)))
                        (((unsupported)).apply (((xself).x_related_query_name)) ((xrelated_query_name)))
                        (((unsupported)).apply (((xself).x_limit_choices_to)) ((xlimit_choices_to)))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xkwargs)))))
                xrelated_model.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xapps).xcheck_models_ready)).apply)
                        (((unsupported)).apply ((((xself).xremote_field).xmodel)))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_related_name_is_valid)).apply)))) ((((unsupported)).apply (((((xself).x_check_related_query_name_is_valid)).apply)))) ((((unsupported)).apply (((((xself).x_check_relation_model_exists)).apply)))) ((((unsupported)).apply (((((xself).x_check_referencing_to_swapped_model)).apply)))) ((((unsupported)).apply (((((xself).x_check_clashes)).apply)))))))
                x_check_related_name_is_valid.write
                  [xself]
                    memory > xis_valid_id
                    memory > xrelated_name
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xrelated_name.write (((xself).xremote_field).xrelated_name)
                        (((unsupported)).apply ((xrelated_name)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xis_valid_id.write ((((((xkeyword).xiskeyword)).apply ((xrelated_name))).not).and ((((xrelated_name).xisidentifier)).apply))
                        (((xis_valid_id).or ((((xrelated_name).xendswith)).apply ("-"))).not).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("The name '%s' is invalid related_name for field %s.%s".mod (((unsupported)).apply ((((xself).xremote_field).xrelated_name)) (((((xself).xmodel).x_meta).xobject_name)) (((xself).xname))))) ("Related name must be a valid Python identifier or end with a '-'") ((xself)) ("fields.E306"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_related_query_name_is_valid.write
                  [xself]
                    memory > xerrors
                    memory > xrel_query_name
                    seq > @
                      seq
                        (((((xself).xremote_field).xis_hidden)).apply).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xrel_query_name.write ((((xself).xrelated_query_name)).apply)
                        xerrors.write (((unsupported)).apply)
                        ((((xrel_query_name).xendswith)).apply ("_")).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Reverse query name '%s' must not end with an underscore.".mod (xrel_query_name))) ("Add or change a related_name or related_query_name argument for this field.") ((xself)) ("fields.E308"))))
                        (((unsupported)).apply ((xLOOKUP_SEP)) ((xrel_query_name))).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Reverse query name '%s' must not contain '%s'.".mod (((unsupported)).apply ((xrel_query_name)) ((xLOOKUP_SEP))))) ("Add or change a related_name or related_query_name argument for this field.") ((xself)) ("fields.E309"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_relation_model_exists.write
                  [xself]
                    memory > xrel_is_missing
                    memory > xmodel_name
                    memory > xrel_is_string
                    seq > @
                      seq
                        xrel_is_missing.write (((unsupported)).apply ((((xself).xremote_field).xmodel)) (((((((xself).xopts).xapps).xget_models)).apply)))
                        xrel_is_string.write (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr)))
                        xmodel_name.write ((xrel_is_string).if (((xself).xremote_field).xmodel) (((((xself).xremote_field).xmodel).x_meta).xobject_name))
                        ((xrel_is_missing).and ((xrel_is_string).or ((((((xself).xremote_field).xmodel).x_meta).xswapped).not))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("Field defines a relation with model '%s', which is either not installed, or is abstract.".mod (xmodel_name))) ((xself)) ("fields.E300"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_referencing_to_swapped_model.write
                  [xself]
                    seq > @
                      seq
                        (((((unsupported)).apply ((((xself).xremote_field).xmodel)) (((((((xself).xopts).xapps).xget_models)).apply))).and ((((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr))).not)).and (((((xself).xremote_field).xmodel).x_meta).xswapped)).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("Field defines a relation with the model '%s', which has been swapped out.".mod (((((xself).xremote_field).xmodel).x_meta).xlabel))) (("Update the relation to point at 'settings.%s'.".mod (((((xself).xremote_field).xmodel).x_meta).xswappable))) ((xself)) ("fields.E301"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_clashes.write
                  [xself]
                    memory > xrel_name
                    memory > xrel_query_name
                    memory > xclash_name
                    memory > xrel_opts
                    memory > xpotential_clashes
                    memory > xopts
                    memory > xerrors
                    memory > xfield_name
                    memory > xrel_is_hidden
                    seq > @
                      seq
                        unsupported
                        (((unsupported)).apply)
                        xerrors.write (((unsupported)).apply)
                        xopts.write (((xself).xmodel).x_meta)
                        ((((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xModelBase))).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xrel_opts.write ((((xself).xremote_field).xmodel).x_meta)
                        xrel_is_hidden.write (((((xself).xremote_field).xis_hidden)).apply)
                        xrel_name.write (((((xself).xremote_field).xget_accessor_name)).apply)
                        xrel_query_name.write ((((xself).xrelated_query_name)).apply)
                        xfield_name.write ("%s.%s".mod (((unsupported)).apply (((xopts).xlabel)) (((xself).xname))))
                        xpotential_clashes.write (((xrel_opts).xfields).sub ((xrel_opts).xmany_to_many))
                        (((unsupported)).apply ((xclash_field)) ((xpotential_clashes)))
                          seq
                            xclash_name.write ("%s.%s".mod (((unsupported)).apply (((xrel_opts).xlabel)) (((xclash_field).xname))))
                            (((xrel_is_hidden).not).and (((xclash_field).xname).eq (xrel_name))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("Reverse accessor '{rel_opts.object_name}.{rel_name}' for '{field_name}' clashes with field name '{clash_name}'.") (("Rename field '%s', or add/change a related_name argument to the definition for field '%s'.".mod (((unsupported)).apply ((xclash_name)) ((xfield_name))))) ((xself)) ("fields.E302"))))
                            (((xclash_field).xname).eq (xrel_query_name)).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Reverse query name for '%s' clashes with field name '%s'.".mod (((unsupported)).apply ((xfield_name)) ((xclash_name))))) (("Rename field '%s', or add/change a related_name argument to the definition for field '%s'.".mod (((unsupported)).apply ((xclash_name)) ((xfield_name))))) ((xself)) ("fields.E303"))))
                        xpotential_clashes.write (((unsupported)).apply ((xr)) ((xr)) (((xrel_opts).xrelated_objects)) ((((unsupported)).apply (((xr).xfield)) ((xself)))))
                        (((unsupported)).apply ((xclash_field)) ((xpotential_clashes)))
                          seq
                            xclash_name.write ("%s.%s".mod (((unsupported)).apply (((((xclash_field).xrelated_model).x_meta).xlabel)) ((((xclash_field).xfield).xname))))
                            (((xrel_is_hidden).not).and (((((xclash_field).xget_accessor_name)).apply).eq (xrel_name))).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) ("Reverse accessor '{rel_opts.object_name}.{rel_name}' for '{field_name}' clashes with reverse accessor for '{clash_name}'.") (("Add or change a related_name argument to the definition for '%s' or '%s'.".mod (((unsupported)).apply ((xfield_name)) ((xclash_name))))) ((xself)) ("fields.E304"))))
                            (((((xclash_field).xget_accessor_name)).apply).eq (xrel_query_name)).if
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Reverse query name for '%s' clashes with reverse query name for '%s'.".mod (((unsupported)).apply ((xfield_name)) ((xclash_name))))) (("Add or change a related_name argument to the definition for '%s' or '%s'.".mod (((unsupported)).apply ((xfield_name)) ((xclash_name))))) ((xself)) ("fields.E305"))))
                        (((unsupported)).apply ((xerrors)))
                xdb_type.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xcontribute_to_class.write
                  [xself xcls xname xprivate_only]
                    memory > xresolve_related_class
                    memory > xrelated_query_name
                    memory > xrelated_name
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xsuper)).apply).xcontribute_to_class)) ((xcls)) ((xname)) ((xprivate_only)) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xopts)) (((xcls).x_meta)))
                        ((((xcls).x_meta).xabstract).not).if
                          seq
                            (((xself).xremote_field).xrelated_name).if
                              xrelated_name.write (((xself).xremote_field).xrelated_name)
                              xrelated_name.write (((xself).xopts).xdefault_related_name)
                            (xrelated_name).if
                              seq
                                xrelated_name.write ((xrelated_name).mod (((unsupported)).apply ("class") ((((((xcls).x__name__).xlower)).apply)) ("model_name") (((((((xcls).x_meta).xmodel_name).xlower)).apply)) ("app_label") (((((((xcls).x_meta).xapp_label).xlower)).apply))))
                                (((unsupported)).apply ((((xself).xremote_field).xrelated_name)) ((xrelated_name)))
                            (((xself).xremote_field).xrelated_query_name).if
                              seq
                                xrelated_query_name.write ((((xself).xremote_field).xrelated_query_name).mod (((unsupported)).apply ("class") ((((((xcls).x__name__).xlower)).apply)) ("app_label") (((((((xcls).x_meta).xapp_label).xlower)).apply))))
                                (((unsupported)).apply ((((xself).xremote_field).xrelated_query_name)) ((xrelated_query_name)))
                            xresolve_related_class.write
                              [xmodel xrelated xfield]
                                seq > @
                                  seq
                                    (((unsupported)).apply ((((xfield).xremote_field).xmodel)) ((xrelated)))
                                    bogusForceDataize.write ((((xfield).xdo_related_class)).apply ((xrelated)) ((xmodel)))
                            (((unsupported)).apply ((xlazy_related_operation)) ((xresolve_related_class)) ((xcls)) ((((xself).xremote_field).xmodel)) ((xself)))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        ((xself).x_limit_choices_to).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("limit_choices_to"))) (((xself).x_limit_choices_to)))
                        (((unsupported)).apply (((xself).x_related_name)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("related_name"))) (((xself).x_related_name)))
                        (((unsupported)).apply (((xself).x_related_query_name)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("related_query_name"))) (((xself).x_related_query_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xget_forward_related_filter.write
                  [xself xobj]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (("%s__%s".mod (((unsupported)).apply (((xself).xname)) (((xrh_field).xname))))) ((((xgetattr)).apply ((xobj)) (((xrh_field).xattname)))) ((((unsupported)).apply ((x_)) ((xrh_field)))) (((xself).xrelated_fields)))))
                xget_reverse_related_filter.write
                  [xself xobj]
                    memory > xdescriptor_filter
                    memory > xbase_q
                    memory > xbase_filter
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xbase_filter.write (((unsupported)).apply ((((unsupported)).apply (((xrh_field).xattname)) ((((xgetattr)).apply ((xobj)) (((xlh_field).xattname)))))) ((((unsupported)).apply ((xlh_field)) ((xrh_field)))) (((xself).xrelated_fields)))
                        xdescriptor_filter.write ((((xself).xget_extra_descriptor_filter)).apply ((xobj)))
                        xbase_q.write (((xQ)).apply ((((unsupported)).apply ((xbase_filter)))))
                        (((xisinstance)).apply ((xdescriptor_filter)) ((xdict))).if
                          (((unsupported)).apply (((xbase_q).and (((xQ)).apply ((((unsupported)).apply ((xdescriptor_filter))))))))
                          (xdescriptor_filter).if
                            (((unsupported)).apply (((xbase_q).and (xdescriptor_filter))))
                        (((unsupported)).apply ((xbase_q)))
                xswappable_setting.write
                  [xself]
                    memory > xto_string
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        ((xself).xswappable).if
                          seq
                            (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr))).if
                              xto_string.write (((xself).xremote_field).xmodel)
                              xto_string.write (((((xself).xremote_field).xmodel).x_meta).xlabel)
                            (((unsupported)).apply (((((xapps).xget_swappable_settings_name)).apply ((xto_string)))))
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xset_attributes_from_rel.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply (((xself).xname)) ((((xself).xname).or (((((((xself).xremote_field).xmodel).x_meta).xmodel_name).sub "_").sub ((((((xself).xremote_field).xmodel).x_meta).xpk).xname)))))
                        (((unsupported)).apply (((xself).xverbose_name)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply (((xself).xverbose_name)) ((((((xself).xremote_field).xmodel).x_meta).xverbose_name)))
                        bogusForceDataize.write (((((xself).xremote_field).xset_field_name)).apply)
                xdo_related_class.write
                  [xself xother xcls]
                    seq > @
                      seq
                        bogusForceDataize.write ((((xself).xset_attributes_from_rel)).apply)
                        bogusForceDataize.write ((((xself).xcontribute_to_related_class)).apply ((xother)) (((xself).xremote_field)))
                xget_limit_choices_to.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xcallable)).apply ((((xself).xremote_field).xlimit_choices_to))).if
                          (((unsupported)).apply ((((((xself).xremote_field).xlimit_choices_to)).apply)))
                        (((unsupported)).apply ((((xself).xremote_field).xlimit_choices_to)))
                xformfield.write
                  [xself]
                    memory > xdefaults
                    memory > xlimit_choices_to
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xdefaults.write (((unsupported)).apply)
                        (((xhasattr)).apply (((xself).xremote_field)) ("get_related_field")).if
                          seq
                            xlimit_choices_to.write (((xself).xremote_field).xlimit_choices_to)
                            bogusForceDataize.write ((((xdefaults).xupdate)).apply ((((unsupported)).apply ("limit_choices_to") ((xlimit_choices_to)))))
                        bogusForceDataize.write ((((xdefaults).xupdate)).apply ((xkwargs)))
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((xdefaults)))))))
                xrelated_query_name.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((((xself).xremote_field).xrelated_query_name).or (((xself).xremote_field).xrelated_name)).or (((xself).xopts).xmodel_name))))
                xtarget_field.write
                  [xself]
                    memory > xtarget_fields
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        xtarget_fields.write ((((unsupported)).apply (((xself).xpath_infos)) ((1.neg))).xtarget_fields)
                        ((((xlen)).apply ((xtarget_fields))).greater 1).if
                          (((unsupported)).apply (((((xexceptions).xFieldError)).apply ("The relation has multiple target fields, but only single target field was asked for"))))
                        (((unsupported)).apply ((((unsupported)).apply ((xtarget_fields)) (0))))
                xget_cache_name.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (((xself).xname)))
            (((unsupported)).apply ((xRelatedField)))
              seq
                (((unsupported)).apply)
                xmany_to_many.write FALSE
                xmany_to_one.write TRUE
                xone_to_many.write FALSE
                xone_to_one.write FALSE
                xrequires_unique_target.write TRUE
                xrelated_accessor_class.write (xReverseManyToOneDescriptor)
                xforward_related_accessor_class.write (xForwardManyToOneDescriptor)
                xrel_class.write (xForeignObjectRel)
                x__init__.write
                  [xself xto xon_delete xfrom_fields xto_fields xrel xrelated_name xrelated_query_name xlimit_choices_to xparent_link xswappable]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xrel)) ("None: is there a None literal in the EO language?")).if
                          xrel.write (((unsupported)).apply (((xself).xrel_class)) ((xself)) ((xto)) ((xrelated_name)) ((xrelated_query_name)) ((xlimit_choices_to)) ((xparent_link)) ((xon_delete)))
                        (((unsupported)).apply (((((xsuper)).apply).x__init__)) ((xrel)) ((xrelated_name)) ((xrelated_query_name)) ((xlimit_choices_to)) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xfrom_fields)) ((xfrom_fields)))
                        (((unsupported)).apply (((xself).xto_fields)) ((xto_fields)))
                        (((unsupported)).apply (((xself).xswappable)) ((xswappable)))
                x__copy__.write
                  [xself]
                    memory > xobj
                    seq > @
                      seq
                        xobj.write ((((((xsuper)).apply).x__copy__)).apply)
                        bogusForceDataize.write (((((xobj).x__dict__).xpop)).apply ("path_infos") ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write (((((xobj).x__dict__).xpop)).apply ("reverse_path_infos") ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xobj)))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_to_fields_exist)).apply)))) ((((unsupported)).apply (((((xself).x_check_unique_target)).apply)))))))
                x_check_to_fields_exist.write
                  [xself]
                    memory > xerrors
                    seq > @
                      seq
                        (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr))).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((xto_field)) (((xself).xto_fields)))
                          (xto_field).if
                            (((unsupported)).apply (((xexceptions).xFieldDoesNotExist)))
                              bogusForceDataize.write (((((((xself).xremote_field).xmodel).x_meta).xget_field)).apply ((xto_field)))
                              bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The to_field '%s' doesn't exist on the related model '%s'.".mod (((unsupported)).apply ((xto_field)) ((((((xself).xremote_field).xmodel).x_meta).xlabel))))) ((xself)) ("fields.E312"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_unique_target.write
                  [xself]
                    memory > xrel_is_string
                    memory > xhas_unique_constraint
                    memory > xforeign_fields
                    memory > xunique_foreign_fields
                    memory > xmodel_name
                    memory > xfield_combination
                    memory > xfield_name
                    seq > @
                      seq
                        xrel_is_string.write (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr)))
                        ((xrel_is_string).or (((xself).xrequires_unique_target).not)).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply (((xexceptions).xFieldDoesNotExist)))
                          unsupported
                          (((unsupported)).apply ((((unsupported)).apply)))
                        (((xself).xforeign_related_fields).not).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xunique_foreign_fields.write (((unsupported)).apply ((((xfrozenset)).apply ((((unsupported)).apply (((xf).xname)))))) ((xf)) ((((((((xself).xremote_field).xmodel).x_meta).xget_fields)).apply)) ((((xgetattr)).apply ((xf)) ("unique") (FALSE))))
                        bogusForceDataize.write ((((xunique_foreign_fields).xupdate)).apply ((((unsupported)).apply ((((xfrozenset)).apply ((xut)))) ((xut)) ((((((xself).xremote_field).xmodel).x_meta).xunique_together)))))
                        bogusForceDataize.write ((((xunique_foreign_fields).xupdate)).apply ((((unsupported)).apply ((((xfrozenset)).apply (((xuc).xfields)))) ((xuc)) ((((((xself).xremote_field).xmodel).x_meta).xtotal_unique_constraints)))))
                        xforeign_fields.write (((unsupported)).apply (((xf).xname)) ((xf)) (((xself).xforeign_related_fields)))
                        xhas_unique_constraint.write (((xany)).apply ((((unsupported)).apply (((xu).leq (xforeign_fields))) ((xu)) ((xunique_foreign_fields)))))
                        (((xhas_unique_constraint).not).and ((((xlen)).apply (((xself).xforeign_related_fields))).greater 1)).if
                          seq
                            xfield_combination.write (((", ".xjoin)).apply ((((unsupported)).apply (("'%s'".mod ((xrel_field).xname))) ((xrel_field)) (((xself).xforeign_related_fields)))))
                            xmodel_name.write ((((xself).xremote_field).xmodel).x__name__)
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("No subset of the fields %s on model '%s' is unique.".mod (((unsupported)).apply ((xfield_combination)) ((xmodel_name))))) ("Mark a single field as unique=True or add a set of fields to a unique constraint (via unique_together or a UniqueConstraint (without condition) in the model Meta.constraints).") ((xself)) ("fields.E310"))))))
                          ((xhas_unique_constraint).not).if
                            seq
                              xfield_name.write ((((unsupported)).apply (((xself).xforeign_related_fields)) (0)).xname)
                              xmodel_name.write ((((xself).xremote_field).xmodel).x__name__)
                              (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s.%s' must be unique because it is referenced by a foreign key.".mod (((unsupported)).apply ((xmodel_name)) ((xfield_name))))) ("Add unique=True to this field or add a UniqueConstraint (without condition) in the model Meta.constraints.") ((xself)) ("fields.E311"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                xdeconstruct.write
                  [xself]
                    memory > xswappable_setting
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("on_delete"))) ((((xself).xremote_field).xon_delete)))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("from_fields"))) (((xself).xfrom_fields)))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to_fields"))) (((xself).xto_fields)))
                        (((xself).xremote_field).xparent_link).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("parent_link"))) ((((xself).xremote_field).xparent_link)))
                        (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr))).if
                          (((unsupported)).apply (".") ((((xself).xremote_field).xmodel))).if
                            seq
                              (((unsupported)).apply ((((unsupported)).apply ((xapp_label)) ((xmodel_name)))) (((((((xself).xremote_field).xmodel).xsplit)).apply ("."))))
                              (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) (("%s.%s".mod (((unsupported)).apply ((xapp_label)) (((((xmodel_name).xlower)).apply))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) (((((((xself).xremote_field).xmodel).xlower)).apply)))
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ((((((xself).xremote_field).xmodel).x_meta).xlabel_lower)))
                        xswappable_setting.write ((xself).xswappable_setting)
                        (((unsupported)).apply ((xswappable_setting)) ("None: is there a None literal in the EO language?")).if
                          seq
                            (((xhasattr)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ("setting_name")).if
                              (((((unsupported)).apply ((xkwargs)) ("to")).xsetting_name).neq (xswappable_setting)).if
                                (((unsupported)).apply ((((xValueError)).apply (("Cannot deconstruct a ForeignKey pointing to a model that is swapped in place of more than one model (%s and %s)".mod (((unsupported)).apply (((((unsupported)).apply ((xkwargs)) ("to")).xsetting_name)) ((xswappable_setting))))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ((((xSettingsReference)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ((xswappable_setting)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xresolve_related_fields.write
                  [xself]
                    memory > xto_field
                    memory > xfrom_field
                    memory > xto_field_name
                    memory > xrelated_fields
                    memory > xfrom_field_name
                    seq > @
                      seq
                        ((((xself).xfrom_fields).not).or ((((xlen)).apply (((xself).xfrom_fields))).neq (((xlen)).apply (((xself).xto_fields))))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Foreign Object from and to fields must be the same non-zero length"))))
                        (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr))).if
                          (((unsupported)).apply ((((xValueError)).apply (("Related model %r cannot be resolved".mod (((xself).xremote_field).xmodel))))))
                        xrelated_fields.write (((unsupported)).apply)
                        (((unsupported)).apply ((xindex)) ((((xrange)).apply ((((xlen)).apply (((xself).xfrom_fields)))))))
                          seq
                            xfrom_field_name.write (((unsupported)).apply (((xself).xfrom_fields)) ((xindex)))
                            xto_field_name.write (((unsupported)).apply (((xself).xto_fields)) ((xindex)))
                            xfrom_field.write (((xfrom_field_name).eq (xRECURSIVE_RELATIONSHIP_CONSTANT)).if (xself) (((((xself).xopts).xget_field)).apply ((xfrom_field_name))))
                            xto_field.write ((((unsupported)).apply ((xto_field_name)) ("None: is there a None literal in the EO language?")).if (((((xself).xremote_field).xmodel).x_meta).xpk) (((((((xself).xremote_field).xmodel).x_meta).xget_field)).apply ((xto_field_name))))
                            bogusForceDataize.write ((((xrelated_fields).xappend)).apply ((((unsupported)).apply ((xfrom_field)) ((xto_field)))))
                        (((unsupported)).apply ((xrelated_fields)))
                xrelated_fields.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xresolve_related_fields)).apply)))
                xreverse_related_fields.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xrhs_field)) ((xlhs_field)))) ((((unsupported)).apply ((xlhs_field)) ((xrhs_field)))) (((xself).xrelated_fields)))))
                xlocal_related_fields.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xtuple)).apply ((((unsupported)).apply ((xlhs_field)) ((((unsupported)).apply ((xlhs_field)) ((xrhs_field)))) (((xself).xrelated_fields)))))))
                xforeign_related_fields.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xtuple)).apply ((((unsupported)).apply ((xrhs_field)) ((((unsupported)).apply ((xlhs_field)) ((xrhs_field)))) (((xself).xrelated_fields)) ((xrhs_field)))))))
                xget_local_related_value.write
                  [xself xinstance]
                    seq > @
                      (((unsupported)).apply (((((xself).xget_instance_value_for_fields)).apply ((xinstance)) (((xself).xlocal_related_fields)))))
                xget_foreign_related_value.write
                  [xself xinstance]
                    seq > @
                      (((unsupported)).apply (((((xself).xget_instance_value_for_fields)).apply ((xinstance)) (((xself).xforeign_related_fields)))))
                xget_instance_value_for_fields.write
                  [xinstance xfields]
                    memory > xret
                    memory > xopts
                    memory > xpossible_parent_link
                    seq > @
                      (((unsupported)).apply)
                        xret.write (((unsupported)).apply)
                        xopts.write ((xinstance).x_meta)
                        (((unsupported)).apply ((xfield)) ((xfields)))
                          seq
                            ((xfield).xprimary_key).if
                              seq
                                xpossible_parent_link.write ((((xopts).xget_ancestor_link)).apply (((xfield).xmodel)))
                                ((((xpossible_parent_link).not).or ((xpossible_parent_link).xprimary_key)).or ((((xpossible_parent_link).xmodel).x_meta).xabstract)).if
                                  seq
                                    bogusForceDataize.write ((((xret).xappend)).apply (((xinstance).xpk)))
                                    (((unsupported)).apply)
                            bogusForceDataize.write ((((xret).xappend)).apply ((((xgetattr)).apply ((xinstance)) (((xfield).xattname)))))
                        (((unsupported)).apply ((((xtuple)).apply ((xret)))))
                xget_attname_column.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xattname)) ((xcolumn)))) (((((((xsuper)).apply).xget_attname_column)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((xattname)) ("None: is there a None literal in the EO language?"))))
                xget_joining_columns.write
                  [xself xreverse_join]
                    memory > xsource
                    seq > @
                      (((unsupported)).apply)
                        xsource.write ((xreverse_join).if ((xself).xreverse_related_fields) ((xself).xrelated_fields))
                        (((unsupported)).apply ((((xtuple)).apply ((((unsupported)).apply ((((unsupported)).apply (((xlhs_field).xcolumn)) (((xrhs_field).xcolumn)))) ((((unsupported)).apply ((xlhs_field)) ((xrhs_field)))) ((xsource)))))))
                xget_reverse_joining_columns.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply (((xself).xget_joining_columns)) (TRUE))))
                xget_extra_descriptor_filter.write
                  [xself xinstance]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply)))
                xget_extra_restriction.write
                  [xself xalias xrelated_alias]
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xget_path_info.write
                  [xself xfiltered_relation]
                    memory > xfrom_opts
                    memory > xopts
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xopts.write ((((xself).xremote_field).xmodel).x_meta)
                        xfrom_opts.write (((xself).xmodel).x_meta)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xPathInfo)) ((xfrom_opts)) ((xopts)) (((xself).xforeign_related_fields)) ((xself)) (FALSE) (TRUE) ((xfiltered_relation)))))))
                xpath_infos.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xget_path_info)).apply)))
                xget_reverse_path_info.write
                  [xself xfiltered_relation]
                    memory > xfrom_opts
                    memory > xopts
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xopts.write (((xself).xmodel).x_meta)
                        xfrom_opts.write ((((xself).xremote_field).xmodel).x_meta)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xPathInfo)) ((xfrom_opts)) ((xopts)) ((((unsupported)).apply (((xopts).xpk)))) (((xself).xremote_field)) ((((xself).xunique).not)) (FALSE) ((xfiltered_relation)))))))
                xreverse_path_infos.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xget_reverse_path_info)).apply)))
                xget_lookups.write
                  [xcls]
                    memory > xbases
                    memory > xclass_lookups
                    seq > @
                      (((unsupported)).apply)
                        xbases.write ((((xinspect).xgetmro)).apply ((xcls)))
                        xbases.write (((unsupported)).apply ((xbases)) ((((unsupported)).apply ((((((xbases).xindex)).apply ((xForeignObject))).sub 1)))))
                        xclass_lookups.write (((unsupported)).apply ((((((xparent).x__dict__).xget)).apply ("class_lookups") ((((unsupported)).apply)))) ((xparent)) ((xbases)))
                        (((unsupported)).apply (((((xcls).xmerge_dicts)).apply ((xclass_lookups)))))
                xcontribute_to_class.write
                  [xself xcls xname xprivate_only]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xsuper)).apply).xcontribute_to_class)) ((xcls)) ((xname)) ((xprivate_only)) ((((unsupported)).apply ((xkwargs)))))
                        bogusForceDataize.write (((xsetattr)).apply ((xcls)) (((xself).xname)) (((((xself).xforward_related_accessor_class)).apply ((xself)))))
                xcontribute_to_related_class.write
                  [xself xcls xrelated]
                    seq > @
                      (((((((xself).xremote_field).xis_hidden)).apply).not).and (((((xrelated).xrelated_model).x_meta).xswapped).not)).if
                        seq
                          bogusForceDataize.write (((xsetattr)).apply ((((xcls).x_meta).xconcrete_model)) (((((xrelated).xget_accessor_name)).apply)) (((((xself).xrelated_accessor_class)).apply ((xrelated)))))
                          (((xself).xremote_field).xlimit_choices_to).if
                            bogusForceDataize.write ((((((xcls).x_meta).xrelated_fkey_lookups).xappend)).apply ((((xself).xremote_field).xlimit_choices_to)))
            bogusForceDataize.write ((((xForeignObject).xregister_lookup)).apply ((xRelatedIn)))
            bogusForceDataize.write ((((xForeignObject).xregister_lookup)).apply ((xRelatedExact)))
            bogusForceDataize.write ((((xForeignObject).xregister_lookup)).apply ((xRelatedLessThan)))
            bogusForceDataize.write ((((xForeignObject).xregister_lookup)).apply ((xRelatedGreaterThan)))
            bogusForceDataize.write ((((xForeignObject).xregister_lookup)).apply ((xRelatedGreaterThanOrEqual)))
            bogusForceDataize.write ((((xForeignObject).xregister_lookup)).apply ((xRelatedLessThanOrEqual)))
            bogusForceDataize.write ((((xForeignObject).xregister_lookup)).apply ((xRelatedIsNull)))
            (((unsupported)).apply ((xForeignObject)))
              seq
                (((unsupported)).apply)
                xdescriptor_class.write (xForeignKeyDeferredAttribute)
                xmany_to_many.write FALSE
                xmany_to_one.write TRUE
                xone_to_many.write FALSE
                xone_to_one.write FALSE
                xrel_class.write (xManyToOneRel)
                xempty_strings_allowed.write FALSE
                xdefault_error_messages.write (((unsupported)).apply ("invalid") ((((x_)).apply ("%(model)s instance with %(field)s %(value)r does not exist."))))
                xdescription.write (((x_)).apply ("Foreign Key (type determined by related field)"))
                x__init__.write
                  [xself xto xon_delete xrelated_name xrelated_query_name xlimit_choices_to xparent_link xto_field xdb_constraint]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xAttributeError)))
                          unsupported
                          ((((xisinstance)).apply ((xto)) ((xstr))).not).if
                            (((unsupported)).apply ((((xTypeError)).apply (("%s(%r) is invalid. First parameter to ForeignKey must be either a model, a model name, or the string %r".mod (((unsupported)).apply ((((xself).x__class__).x__name__)) ((xto)) ((xRECURSIVE_RELATIONSHIP_CONSTANT))))))))
                          xto_field.write ((xto_field).or ((((xto).x_meta).xpk).and ((((xto).x_meta).xpk).xname)))
                        ((((xcallable)).apply ((xon_delete))).not).if
                          (((unsupported)).apply ((((xTypeError)).apply ("on_delete must be callable."))))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("rel"))) ((((unsupported)).apply (((xself).xrel_class)) ((xself)) ((xto)) ((xto_field)) ((xrelated_name)) ((xrelated_query_name)) ((xlimit_choices_to)) ((xparent_link)) ((xon_delete)))))
                        bogusForceDataize.write ((((xkwargs).xsetdefault)).apply ("db_index") (TRUE))
                        (((unsupported)).apply (((((xsuper)).apply).x__init__)) ((xto)) ((xon_delete)) ((xrelated_name)) ((xrelated_query_name)) ((xlimit_choices_to)) ((((unsupported)).apply ((xRECURSIVE_RELATIONSHIP_CONSTANT)))) ((((unsupported)).apply ((xto_field)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xdb_constraint)) ((xdb_constraint)))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_on_delete)).apply)))) ((((unsupported)).apply (((((xself).x_check_unique)).apply)))))))
                x_check_on_delete.write
                  [xself]
                    memory > xon_delete
                    seq > @
                      seq
                        xon_delete.write (((xgetattr)).apply (((xself).xremote_field)) ("on_delete") ("None: is there a None literal in the EO language?"))
                        (((xon_delete).eq (xSET_NULL)).and (((xself).xnull).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("Field specifies on_delete=SET_NULL, but cannot be null.") ("Set null=True argument on the field, or change the on_delete rule.") ((xself)) ("fields.E320"))))))
                          (((xon_delete).eq (xSET_DEFAULT)).and (((((xself).xhas_default)).apply).not)).if
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("Field specifies on_delete=SET_DEFAULT, but has no default value.") ("Set a default value, or change the on_delete rule.") ((xself)) ("fields.E321"))))))
                            (((unsupported)).apply ((((unsupported)).apply)))
                x_check_unique.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).xunique).if (((unsupported)).apply ((((unsupported)).apply (((xchecks).xWarning)) ("Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.") ("ForeignKey(unique=True) is usually better served by a OneToOneField.") ((xself)) ("fields.W342")))) (((unsupported)).apply))))
                xdeconstruct.write
                  [xself]
                    memory > xto_meta
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to_fields"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("from_fields"))))))
                        ((xself).xdb_index).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_index"))))))
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_index"))) (FALSE))
                        (((unsupported)).apply (((xself).xdb_constraint)) (TRUE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_constraint"))) (((xself).xdb_constraint)))
                        xto_meta.write (((xgetattr)).apply ((((xself).xremote_field).xmodel)) ("_meta") ("None: is there a None literal in the EO language?"))
                        ((((xself).xremote_field).xfield_name).and (((xto_meta).not).or (((xto_meta).xpk).and ((((xself).xremote_field).xfield_name).neq (((xto_meta).xpk).xname))))).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to_field"))) ((((xself).xremote_field).xfield_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xto_python.write
                  [xself xvalue]
                    seq > @
                      (((unsupported)).apply ((((((xself).xtarget_field).xto_python)).apply ((xvalue)))))
                xtarget_field.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).xforeign_related_fields)) (0))))
                xget_reverse_path_info.write
                  [xself xfiltered_relation]
                    memory > xfrom_opts
                    memory > xopts
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xopts.write (((xself).xmodel).x_meta)
                        xfrom_opts.write ((((xself).xremote_field).xmodel).x_meta)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xPathInfo)) ((xfrom_opts)) ((xopts)) ((((unsupported)).apply (((xopts).xpk)))) (((xself).xremote_field)) ((((xself).xunique).not)) (FALSE) ((xfiltered_relation)))))))
                xvalidate.write
                  [xself xvalue xmodel_instance]
                    memory > xqs
                    memory > xusing
                    seq > @
                      seq
                        (((xself).xremote_field).xparent_link).if
                          (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).xvalidate)).apply ((xvalue)) ((xmodel_instance)))
                        (((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply)
                        xusing.write (((unsupported)).apply (((xrouter).xdb_for_read)) ((((xself).xremote_field).xmodel)) ((xmodel_instance)))
                        xqs.write ((((((((((xself).xremote_field).xmodel).x_base_manager).xusing)).apply ((xusing))).xfilter)).apply ((((unsupported)).apply ((((unsupported)).apply ((((xself).xremote_field).xfield_name)) ((xvalue)))))))
                        xqs.write ((((xqs).xcomplex_filter)).apply (((((xself).xget_limit_choices_to)).apply)))
                        (((((xqs).xexists)).apply).not).if
                          (((unsupported)).apply ((((unsupported)).apply (((xexceptions).xValidationError)) ((((unsupported)).apply (((xself).xerror_messages)) ("invalid"))) ("invalid") ((((unsupported)).apply ("model") ((((((xself).xremote_field).xmodel).x_meta).xverbose_name)) ("pk") ((xvalue)) ("field") ((((xself).xremote_field).xfield_name)) ("value") ((xvalue)))))))
                xresolve_related_fields.write
                  [xself]
                    memory > xrelated_fields
                    seq > @
                      seq
                        xrelated_fields.write ((((((xsuper)).apply).xresolve_related_fields)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xfrom_field)) ((xto_field)))) ((xrelated_fields)))
                          ((xto_field).and (((xto_field).xmodel).neq (((((xself).xremote_field).xmodel).x_meta).xconcrete_model))).if
                            (((unsupported)).apply (((((xexceptions).xFieldError)).apply (("'%s.%s' refers to field '%s' which is not local to model '%s'.".mod (((unsupported)).apply (((((xself).xmodel).x_meta).xlabel)) (((xself).xname)) (((xto_field).xname)) ((((((((xself).xremote_field).xmodel).x_meta).xconcrete_model).x_meta).xlabel))))))))
                        (((unsupported)).apply ((xrelated_fields)))
                xget_attname.write
                  [xself]
                    seq > @
                      (((unsupported)).apply (("%s_id".mod ((xself).xname))))
                xget_attname_column.write
                  [xself]
                    memory > xcolumn
                    memory > xattname
                    seq > @
                      seq
                        xattname.write ((((xself).xget_attname)).apply)
                        xcolumn.write (((xself).xdb_column).or (xattname))
                        (((unsupported)).apply ((((unsupported)).apply ((xattname)) ((xcolumn)))))
                xget_default.write
                  [xself]
                    memory > xfield_default
                    seq > @
                      seq
                        unsupported
                        xfield_default.write ((((((xsuper)).apply).xget_default)).apply)
                        (((xisinstance)).apply ((xfield_default)) ((((xself).xremote_field).xmodel))).if
                          (((unsupported)).apply ((((xgetattr)).apply ((xfield_default)) ((((xself).xtarget_field).xattname)))))
                        (((unsupported)).apply ((xfield_default)))
                xget_db_prep_save.write
                  [xself xvalue xconnection]
                    seq > @
                      ((((unsupported)).apply ((xvalue)) ("None: is there a None literal in the EO language?")).or (((xvalue).eq "").and (((((xself).xtarget_field).xempty_strings_allowed).not).or (((xconnection).xfeatures).xinterprets_empty_strings_as_nulls)))).if
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((((unsupported)).apply ((((xself).xtarget_field).xget_db_prep_save)) ((xvalue)) ((xconnection)))))
                xget_db_prep_value.write
                  [xself xvalue xconnection xprepared]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((((xself).xtarget_field).xget_db_prep_value)).apply ((xvalue)) ((xconnection)) ((xprepared)))))
                xget_prep_value.write
                  [xself xvalue]
                    seq > @
                      (((unsupported)).apply ((((((xself).xtarget_field).xget_prep_value)).apply ((xvalue)))))
                xcontribute_to_related_class.write
                  [xself xcls xrelated]
                    seq > @
                      seq
                        bogusForceDataize.write ((((((xsuper)).apply).xcontribute_to_related_class)).apply ((xcls)) ((xrelated)))
                        (((unsupported)).apply ((((xself).xremote_field).xfield_name)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((xself).xremote_field).xfield_name)) (((((xcls).x_meta).xpk).xname)))
                xformfield.write
                  [xself xusing]
                    seq > @
                      (((unsupported)).apply)
                        (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr))).if
                          (((unsupported)).apply ((((xValueError)).apply (("Cannot create form field for %r yet, because its related model %r has not been loaded yet".mod (((unsupported)).apply (((xself).xname)) ((((xself).xremote_field).xmodel))))))))
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((((unsupported)).apply ("form_class") (((xforms).xModelChoiceField)) ("queryset") ((((((((xself).xremote_field).xmodel).x_default_manager).xusing)).apply ((xusing)))) ("to_field_name") ((((xself).xremote_field).xfield_name)) ((xkwargs)) ("blank") (((xself).xblank)))))))))
                xdb_check.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xdb_type.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ((((xself).xtarget_field).xrel_db_type)) ((xconnection)))))
                xdb_parameters.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ("type") (((((xself).xdb_type)).apply ((xconnection)))) ("check") (((((xself).xdb_check)).apply ((xconnection)))))))
                xconvert_empty_strings.write
                  [xself xvalue xexpression xconnection]
                    seq > @
                      seq
                        (((xvalue).not).and (((xisinstance)).apply ((xvalue)) ((xstr)))).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply ((xvalue)))
                xget_db_converters.write
                  [xself xconnection]
                    memory > xconverters
                    seq > @
                      seq
                        xconverters.write ((((((xsuper)).apply).xget_db_converters)).apply ((xconnection)))
                        (((xconnection).xfeatures).xinterprets_empty_strings_as_nulls).if
                          (((unsupported)).apply ((xconverters)) ((((unsupported)).apply (((xself).xconvert_empty_strings)))))
                        (((unsupported)).apply ((xconverters)))
                xget_col.write
                  [xself xalias xoutput_field]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xoutput_field)) ("None: is there a None literal in the EO language?")).if
                          seq
                            xoutput_field.write ((xself).xtarget_field)
                            while.
                              (((xisinstance)).apply ((xoutput_field)) ((xForeignKey)))
                              [unused]
                                seq > @
                                  seq
                                    xoutput_field.write ((xoutput_field).xtarget_field)
                                    (((unsupported)).apply ((xoutput_field)) ((xself))).if
                                      (((unsupported)).apply ((((xValueError)).apply ("Cannot resolve output_field."))))
                        (((unsupported)).apply (((((((xsuper)).apply).xget_col)).apply ((xalias)) ((xoutput_field)))))
            (((unsupported)).apply ((xForeignKey)))
              seq
                (((unsupported)).apply)
                xmany_to_many.write FALSE
                xmany_to_one.write FALSE
                xone_to_many.write FALSE
                xone_to_one.write TRUE
                xrelated_accessor_class.write (xReverseOneToOneDescriptor)
                xforward_related_accessor_class.write (xForwardOneToOneDescriptor)
                xrel_class.write (xOneToOneRel)
                xdescription.write (((x_)).apply ("One-to-one relationship"))
                x__init__.write
                  [xself xto xon_delete xto_field]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("unique"))) (TRUE))
                        (((unsupported)).apply (((((xsuper)).apply).x__init__)) ((xto)) ((xon_delete)) ((xto_field)) ((((unsupported)).apply ((xkwargs)))))
                xdeconstruct.write
                  [xself]
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply ("unique") ((xkwargs))).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("unique"))))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                xformfield.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((xself).xremote_field).xparent_link).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((xkwargs)))))))
                xsave_form_data.write
                  [xself xinstance xdata]
                    seq > @
                      (((xisinstance)).apply ((xdata)) ((((xself).xremote_field).xmodel))).if
                        bogusForceDataize.write (((xsetattr)).apply ((xinstance)) (((xself).xname)) ((xdata)))
                        seq
                          bogusForceDataize.write (((xsetattr)).apply ((xinstance)) (((xself).xattname)) ((xdata)))
                          (((unsupported)).apply ((xdata)) ("None: is there a None literal in the EO language?")).if
                            bogusForceDataize.write (((xsetattr)).apply ((xinstance)) (((xself).xname)) ((xdata)))
                x_check_unique.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply)))
            xcreate_many_to_many_intermediary_model.write
              [xfield xklass]
                memory > xset_managed
                memory > xmeta
                memory > xto
                memory > xfrom_
                memory > xto_model
                memory > xname
                seq > @
                  seq
                    (((unsupported)).apply)
                    xset_managed.write
                      [xmodel xrelated xthrough]
                        seq > @
                          (((unsupported)).apply ((((xthrough).x_meta).xmanaged)) (((((xmodel).x_meta).xmanaged).or (((xrelated).x_meta).xmanaged))))
                    xto_model.write (((xresolve_relation)).apply ((xklass)) ((((xfield).xremote_field).xmodel)))
                    xname.write ("%s_%s".mod (((unsupported)).apply ((((xklass).x_meta).xobject_name)) (((xfield).xname))))
                    bogusForceDataize.write (((xlazy_related_operation)).apply ((xset_managed)) ((xklass)) ((xto_model)) ((xname)))
                    xto.write (((unsupported)).apply ((((xmake_model_tuple)).apply ((xto_model)))) (1))
                    xfrom_.write (((xklass).x_meta).xmodel_name)
                    ((xto).eq (xfrom_)).if
                      seq
                        xto.write ("to_%s".mod (xto))
                        xfrom_.write ("from_%s".mod (xfrom_))
                    xmeta.write (((xtype)).apply ("Meta") ((((unsupported)).apply)) ((((unsupported)).apply ("db_table") (((((xfield).x_get_m2m_db_table)).apply (((xklass).x_meta)))) ("auto_created") ((xklass)) ("app_label") ((((xklass).x_meta).xapp_label)) ("db_tablespace") ((((xklass).x_meta).xdb_tablespace)) ("unique_together") ((((unsupported)).apply ((xfrom_)) ((xto)))) ("verbose_name") (((((x_)).apply ("%(from)s-%(to)s relationship")).mod (((unsupported)).apply ("from") ((xfrom_)) ("to") ((xto))))) ("verbose_name_plural") (((((x_)).apply ("%(from)s-%(to)s relationships")).mod (((unsupported)).apply ("from") ((xfrom_)) ("to") ((xto))))) ("apps") (((((xfield).xmodel).x_meta).xapps)))))
                    (((unsupported)).apply ((((xtype)).apply ((xname)) ((((unsupported)).apply (((xmodels).xModel)))) ((((unsupported)).apply ("Meta") ((xmeta)) ("__module__") (((xklass).x__module__)) ((xfrom_)) ((((unsupported)).apply (((xmodels).xForeignKey)) ((xklass)) (("%s-".mod (xname))) (((xfield).xdb_tablespace)) ((((xfield).xremote_field).xdb_constraint)) ((xCASCADE)))) ((xto)) ((((unsupported)).apply (((xmodels).xForeignKey)) ((xto_model)) (("%s-".mod (xname))) (((xfield).xdb_tablespace)) ((((xfield).xremote_field).xdb_constraint)) ((xCASCADE)))))))))
            (((unsupported)).apply ((xRelatedField)))
              seq
                (((unsupported)).apply)
                xmany_to_many.write TRUE
                xmany_to_one.write FALSE
                xone_to_many.write FALSE
                xone_to_one.write FALSE
                xrel_class.write (xManyToManyRel)
                xdescription.write (((x_)).apply ("Many-to-many relationship"))
                x__init__.write
                  [xself xto xrelated_name xrelated_query_name xlimit_choices_to xsymmetrical xthrough xthrough_fields xdb_constraint xdb_table xswappable]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xAttributeError)))
                          unsupported
                          ((((xisinstance)).apply ((xto)) ((xstr))).not).if
                            (((unsupported)).apply ((((xTypeError)).apply (("%s(%r) is invalid. First parameter to ManyToManyField must be either a model, a model name, or the string %r".mod (((unsupported)).apply ((((xself).x__class__).x__name__)) ((xto)) ((xRECURSIVE_RELATIONSHIP_CONSTANT))))))))
                        (((unsupported)).apply ((xsymmetrical)) ("None: is there a None literal in the EO language?")).if
                          xsymmetrical.write ((xto).eq (xRECURSIVE_RELATIONSHIP_CONSTANT))
                        ((((unsupported)).apply ((xthrough)) ("None: is there a None literal in the EO language?")).and (((unsupported)).apply ((xdb_table)) ("None: is there a None literal in the EO language?"))).if
                          (((unsupported)).apply ((((xValueError)).apply ("Cannot specify a db_table if an intermediary model is used."))))
                        (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("rel"))) ((((unsupported)).apply (((xself).xrel_class)) ((xself)) ((xto)) ((xrelated_name)) ((xrelated_query_name)) ((xlimit_choices_to)) ((xsymmetrical)) ((xthrough)) ((xthrough_fields)) ((xdb_constraint)))))
                        (((unsupported)).apply (((xself).xhas_null_arg)) ((((unsupported)).apply ("null") ((xkwargs)))))
                        (((unsupported)).apply (((((xsuper)).apply).x__init__)) ((xrelated_name)) ((xrelated_query_name)) ((xlimit_choices_to)) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xdb_table)) ((xdb_table)))
                        (((unsupported)).apply (((xself).xswappable)) ((xswappable)))
                xcheck.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((((((xsuper)).apply).xcheck)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_unique)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_relationship_model)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_ignored_options)).apply ((((unsupported)).apply ((xkwargs)))))))) ((((unsupported)).apply (((((xself).x_check_table_uniqueness)).apply ((((unsupported)).apply ((xkwargs)))))))))))
                x_check_unique.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        ((xself).xunique).if
                          (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply (((xchecks).xError)) ("ManyToManyFields cannot be unique.") ((xself)) ("fields.E330"))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                x_check_ignored_options.write
                  [xself]
                    memory > xwarnings
                    seq > @
                      (((unsupported)).apply)
                        xwarnings.write (((unsupported)).apply)
                        ((xself).xhas_null_arg).if
                          bogusForceDataize.write ((((xwarnings).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) ("null has no effect on ManyToManyField.") ((xself)) ("fields.W340"))))
                        ((xself).x_validators).if
                          bogusForceDataize.write ((((xwarnings).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) ("ManyToManyField does not support validators.") ((xself)) ("fields.W341"))))
                        ((((xself).xremote_field).xsymmetrical).and ((xself).x_related_name)).if
                          bogusForceDataize.write ((((xwarnings).xappend)).apply ((((unsupported)).apply (((xchecks).xWarning)) ("related_name has no effect on ManyToManyField with a symmetrical relationship, e.g. to \"self\".") ((xself)) ("fields.W345"))))
                        (((unsupported)).apply ((xwarnings)))
                x_check_relationship_model.write
                  [xself xfrom_model]
                    memory > xseen_to
                    memory > xerrors
                    memory > xfrom_model_name
                    memory > xqualified_model_name
                    memory > xseen_self
                    memory > xpossible_field_names
                    memory > xto_model
                    memory > xto_model_name
                    memory > xrelationship_model_name
                    memory > xfield
                    memory > xhint
                    memory > xself_referential
                    memory > xseen_from
                    seq > @
                      (((unsupported)).apply)
                        (((xhasattr)).apply ((((xself).xremote_field).xthrough)) ("_meta")).if
                          xqualified_model_name.write ("%s.%s".mod (((unsupported)).apply ((((((xself).xremote_field).xthrough).x_meta).xapp_label)) (((((xself).xremote_field).xthrough).x__name__))))
                          xqualified_model_name.write (((xself).xremote_field).xthrough)
                        xerrors.write (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).xremote_field).xthrough)) ((((unsupported)).apply (((((xself).xopts).xapps).xget_models)) (TRUE)))).if
                          bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Field specifies a many-to-many relation through model '%s', which has not been installed.".mod (xqualified_model_name))) ((xself)) ("fields.E331"))))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xfrom_model)) ("None: is there a None literal in the EO language?"))) ("ManyToManyField with intermediate tables cannot be checked if you don't pass the model where the field is attached to."))
                            xto_model.write (((xresolve_relation)).apply ((xfrom_model)) ((((xself).xremote_field).xmodel)))
                            xfrom_model_name.write (((xfrom_model).x_meta).xobject_name)
                            (((xisinstance)).apply ((xto_model)) ((xstr))).if
                              xto_model_name.write (xto_model)
                              xto_model_name.write (((xto_model).x_meta).xobject_name)
                            xrelationship_model_name.write (((((xself).xremote_field).xthrough).x_meta).xobject_name)
                            xself_referential.write ((xfrom_model).eq (xto_model))
                            (xself_referential).if
                              seq
                                xseen_self.write (((xsum)).apply ((((unsupported)).apply (((xfrom_model).eq (((xgetattr)).apply (((xfield).xremote_field)) ("model") ("None: is there a None literal in the EO language?")))) ((xfield)) ((((((xself).xremote_field).xthrough).x_meta).xfields)))))
                                (((xseen_self).greater 2).and ((((xself).xremote_field).xthrough_fields).not)).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The model is used as an intermediate model by '%s', but it has more than two foreign keys to '%s', which is ambiguous. You must specify which two foreign keys Django should use via the through_fields keyword argument.".mod (((unsupported)).apply ((xself)) ((xfrom_model_name))))) ("Use through_fields to specify which two foreign keys Django should use.") ((((xself).xremote_field).xthrough)) ("fields.E333"))))
                              seq
                                xseen_from.write (((xsum)).apply ((((unsupported)).apply (((xfrom_model).eq (((xgetattr)).apply (((xfield).xremote_field)) ("model") ("None: is there a None literal in the EO language?")))) ((xfield)) ((((((xself).xremote_field).xthrough).x_meta).xfields)))))
                                xseen_to.write (((xsum)).apply ((((unsupported)).apply (((xto_model).eq (((xgetattr)).apply (((xfield).xremote_field)) ("model") ("None: is there a None literal in the EO language?")))) ((xfield)) ((((((xself).xremote_field).xthrough).x_meta).xfields)))))
                                (((xseen_from).greater 1).and ((((xself).xremote_field).xthrough_fields).not)).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The model is used as an intermediate model by '%s', but it has more than one foreign key from '%s', which is ambiguous. You must specify which foreign key Django should use via the through_fields keyword argument.".mod (((unsupported)).apply ((xself)) ((xfrom_model_name))))) (("If you want to create a recursive relationship, use ManyToManyField(\"%s\", through=\"%s\").".mod (((unsupported)).apply ((xRECURSIVE_RELATIONSHIP_CONSTANT)) ((xrelationship_model_name))))) ((xself)) ("fields.E334"))))
                                (((xseen_to).greater 1).and ((((xself).xremote_field).xthrough_fields).not)).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The model is used as an intermediate model by '%s', but it has more than one foreign key to '%s', which is ambiguous. You must specify which foreign key Django should use via the through_fields keyword argument.".mod (((unsupported)).apply ((xself)) ((xto_model_name))))) (("If you want to create a recursive relationship, use ManyToManyField(\"%s\", through=\"%s\").".mod (((unsupported)).apply ((xRECURSIVE_RELATIONSHIP_CONSTANT)) ((xrelationship_model_name))))) ((xself)) ("fields.E335"))))
                                (((xseen_from).eq 0).or ((xseen_to).eq 0)).if
                                  bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The model is used as an intermediate model by '%s', but it does not have a foreign key to '%s' or '%s'.".mod (((unsupported)).apply ((xself)) ((xfrom_model_name)) ((xto_model_name))))) ((((xself).xremote_field).xthrough)) ("fields.E336"))))
                        (((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) ("None: is there a None literal in the EO language?")).if
                          (((((((xlen)).apply ((((xself).xremote_field).xthrough_fields))).geq 2).and (((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) (0))).and (((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) (1))).not).if
                            bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("Field specifies 'through_fields' but does not provide the names of the two link fields that should be used for the relation through model '%s'.".mod (xqualified_model_name))) ("Make sure you specify 'through_fields' as through_fields=('field1', 'field2')") ((xself)) ("fields.E337"))))
                            seq
                              (((unsupported)).apply ((((unsupported)).apply ((xfrom_model)) ("None: is there a None literal in the EO language?"))) ("ManyToManyField with intermediate tables cannot be checked if you don't pass the model where the field is attached to."))
                              (((unsupported)).apply ((((unsupported)).apply ((xsource)) ((xthrough)) ((xtarget)))) ((((unsupported)).apply ((xfrom_model)) ((((xself).xremote_field).xthrough)) ((((xself).xremote_field).xmodel)))))
                              (((unsupported)).apply ((((unsupported)).apply ((xsource_field_name)) ((xtarget_field_name)))) ((((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) ((((unsupported)).apply (2))))))
                              (((unsupported)).apply ((((unsupported)).apply ((xfield_name)) ((xrelated_model)))) ((((unsupported)).apply ((((unsupported)).apply ((xsource_field_name)) ((xsource)))) ((((unsupported)).apply ((xtarget_field_name)) ((xtarget)))))))
                                seq
                                  xpossible_field_names.write (((unsupported)).apply)
                                  (((unsupported)).apply ((xf)) ((((xthrough).x_meta).xfields)))
                                    ((((xhasattr)).apply ((xf)) ("remote_field")).and ((((xgetattr)).apply (((xf).xremote_field)) ("model") ("None: is there a None literal in the EO language?")).eq (xrelated_model))).if
                                      bogusForceDataize.write ((((xpossible_field_names).xappend)).apply (((xf).xname)))
                                  (xpossible_field_names).if
                                    xhint.write ("Did you mean one of the following foreign keys to '%s': %s?".mod (((unsupported)).apply ((((xrelated_model).x_meta).xobject_name)) ((((", ".xjoin)).apply ((xpossible_field_names))))))
                                    xhint.write "None: is there a None literal in the EO language?"
                                  (((unsupported)).apply (((xexceptions).xFieldDoesNotExist)))
                                    xfield.write (((((xthrough).x_meta).xget_field)).apply ((xfield_name)))
                                    bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("The intermediary model '%s' has no field '%s'.".mod (((unsupported)).apply ((xqualified_model_name)) ((xfield_name))))) ((xhint)) ((xself)) ("fields.E338"))))
                                    (((((xhasattr)).apply ((xfield)) ("remote_field")).and ((((xgetattr)).apply (((xfield).xremote_field)) ("model") ("None: is there a None literal in the EO language?")).eq (xrelated_model))).not).if
                                      bogusForceDataize.write ((((xerrors).xappend)).apply ((((unsupported)).apply (((xchecks).xError)) (("'%s.%s' is not a foreign key to '%s'.".mod (((unsupported)).apply ((((xthrough).x_meta).xobject_name)) ((xfield_name)) ((((xrelated_model).x_meta).xobject_name))))) ((xhint)) ((xself)) ("fields.E339"))))
                        (((unsupported)).apply ((xerrors)))
                x_check_table_uniqueness.write
                  [xself]
                    memory > xopts
                    memory > xclashing_obj
                    memory > xregistered_tables
                    memory > xerror_hint
                    memory > xm2m_db_table
                    memory > xmodel
                    memory > x_get_field_name
                    seq > @
                      (((unsupported)).apply)
                        ((((xisinstance)).apply ((((xself).xremote_field).xthrough)) ((xstr))).or ((((((xself).xremote_field).xthrough).x_meta).xmanaged).not)).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        xregistered_tables.write (((unsupported)).apply ((((xmodel).x_meta).xdb_table)) ((xmodel)) ((xmodel)) ((((unsupported)).apply (((((xself).xopts).xapps).xget_models)) (TRUE))) ((((xmodel).neq (((xself).xremote_field).xthrough)).and (((xmodel).x_meta).xmanaged))))
                        xm2m_db_table.write ((((xself).xm2m_db_table)).apply)
                        xmodel.write ((((xregistered_tables).xget)).apply ((xm2m_db_table)))
                        ((xmodel).and ((((xmodel).x_meta).xconcrete_model).neq (((((xself).xremote_field).xthrough).x_meta).xconcrete_model))).if
                          seq
                            (((xmodel).x_meta).xauto_created).if
                              seq
                                x_get_field_name.write
                                  [xmodel]
                                    seq > @
                                      (((unsupported)).apply ((xfield)) ((((((xmodel).x_meta).xauto_created).x_meta).xmany_to_many)))
                                        (((unsupported)).apply ((((xfield).xremote_field).xthrough)) ((xmodel))).if
                                          (((unsupported)).apply (((xfield).xname)))
                                xopts.write ((((xmodel).x_meta).xauto_created).x_meta)
                                xclashing_obj.write ("%s.%s".mod (((unsupported)).apply (((xopts).xlabel)) ((((x_get_field_name)).apply ((xmodel))))))
                              xclashing_obj.write (((xmodel).x_meta).xlabel)
                            ((xsettings).xDATABASE_ROUTERS).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xerror_class)) ((xerror_id)))) ((((unsupported)).apply (((xchecks).xWarning)) ("fields.W344"))))
                                xerror_hint.write ("You have configured settings.DATABASE_ROUTERS. Verify that the table of %r is correctly routed to a separate database.".mod (xclashing_obj))
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xerror_class)) ((xerror_id)))) ((((unsupported)).apply (((xchecks).xError)) ("fields.E340"))))
                                xerror_hint.write "None: is there a None literal in the EO language?"
                            (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xerror_class)) (("The field's intermediary table '%s' clashes with the table name of '%s'.".mod (((unsupported)).apply ((xm2m_db_table)) ((xclashing_obj))))) ((xself)) ((xerror_hint)) ((xerror_id)))))))
                        (((unsupported)).apply ((((unsupported)).apply)))
                xdeconstruct.write
                  [xself]
                    memory > xswappable_setting
                    seq > @
                      seq
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))) (((((((xsuper)).apply).xdeconstruct)).apply)))
                        (((unsupported)).apply (((xself).xdb_table)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_table"))) (((xself).xdb_table)))
                        (((unsupported)).apply ((((xself).xremote_field).xdb_constraint)) (TRUE)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("db_constraint"))) ((((xself).xremote_field).xdb_constraint)))
                        (((xisinstance)).apply ((((xself).xremote_field).xmodel)) ((xstr))).if
                          (((unsupported)).apply (".") ((((xself).xremote_field).xmodel))).if
                            seq
                              (((unsupported)).apply ((((unsupported)).apply ((xapp_label)) ((xmodel_name)))) (((((((xself).xremote_field).xmodel).xsplit)).apply ("."))))
                              (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) (("%s.%s".mod (((unsupported)).apply ((xapp_label)) (((((xmodel_name).xlower)).apply))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) (((((((xself).xremote_field).xmodel).xlower)).apply)))
                          (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ((((((xself).xremote_field).xmodel).x_meta).xlabel_lower)))
                        (((unsupported)).apply ((((xgetattr)).apply (((xself).xremote_field)) ("through") ("None: is there a None literal in the EO language?"))) ("None: is there a None literal in the EO language?")).if
                          (((xisinstance)).apply ((((xself).xremote_field).xthrough)) ((xstr))).if
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("through"))) ((((xself).xremote_field).xthrough)))
                            ((((((xself).xremote_field).xthrough).x_meta).xauto_created).not).if
                              (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("through"))) ((((((xself).xremote_field).xthrough).x_meta).xlabel)))
                        xswappable_setting.write ((xself).xswappable_setting)
                        (((unsupported)).apply ((xswappable_setting)) ("None: is there a None literal in the EO language?")).if
                          seq
                            (((xhasattr)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ("setting_name")).if
                              (((((unsupported)).apply ((xkwargs)) ("to")).xsetting_name).neq (xswappable_setting)).if
                                (((unsupported)).apply ((((xValueError)).apply (("Cannot deconstruct a ManyToManyField pointing to a model that is swapped in place of more than one model (%s and %s)".mod (((unsupported)).apply (((((unsupported)).apply ((xkwargs)) ("to")).xsetting_name)) ((xswappable_setting))))))))
                            (((unsupported)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ((((xSettingsReference)).apply ((((unsupported)).apply ((xkwargs)) ("to"))) ((xswappable_setting)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xpath)) ((xargs)) ((xkwargs)))))
                x_get_path_info.write
                  [xself xdirect xfiltered_relation]
                    memory > xint_model
                    memory > xintermediate_infos
                    memory > xlinkfield1
                    memory > xjoin1infos
                    memory > xlinkfield2
                    memory > xjoin2infos
                    memory > xjoin1_final
                    memory > xjoin2_initial
                    seq > @
                      (((unsupported)).apply)
                        unsupported
                        xint_model.write (((xself).xremote_field).xthrough)
                        xlinkfield1.write (((((xint_model).x_meta).xget_field)).apply (((((xself).xm2m_field_name)).apply)))
                        xlinkfield2.write (((((xint_model).x_meta).xget_field)).apply (((((xself).xm2m_reverse_field_name)).apply)))
                        (xdirect).if
                          seq
                            xjoin1infos.write ((xlinkfield1).xreverse_path_infos)
                            (xfiltered_relation).if
                              xjoin2infos.write ((((xlinkfield2).xget_path_info)).apply ((xfiltered_relation)))
                              xjoin2infos.write ((xlinkfield2).xpath_infos)
                          seq
                            xjoin1infos.write ((xlinkfield2).xreverse_path_infos)
                            (xfiltered_relation).if
                              xjoin2infos.write ((((xlinkfield1).xget_path_info)).apply ((xfiltered_relation)))
                              xjoin2infos.write ((xlinkfield1).xpath_infos)
                        xjoin1_final.write ((((unsupported)).apply ((xjoin1infos)) ((1.neg))).xto_opts)
                        xjoin2_initial.write ((((unsupported)).apply ((xjoin2infos)) (0)).xfrom_opts)
                        (((unsupported)).apply ((xjoin1_final)) ((xjoin2_initial))).if
                          xintermediate_infos.write (((unsupported)).apply)
                          (((xissubclass)).apply (((xjoin1_final).xmodel)) (((xjoin2_initial).xmodel))).if
                            xintermediate_infos.write ((((xjoin1_final).xget_path_to_parent)).apply (((xjoin2_initial).xmodel)))
                            xintermediate_infos.write ((((xjoin2_initial).xget_path_from_parent)).apply (((xjoin1_final).xmodel)))
                        (((unsupported)).apply ((((unsupported)).apply ((((unsupported)).apply ((xjoin1infos)))) ((((unsupported)).apply ((xintermediate_infos)))) ((((unsupported)).apply ((xjoin2infos)))))))
                xget_path_info.write
                  [xself xfiltered_relation]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).x_get_path_info)) (TRUE) ((xfiltered_relation)))))
                xpath_infos.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xget_path_info)).apply)))
                xget_reverse_path_info.write
                  [xself xfiltered_relation]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply (((xself).x_get_path_info)) (FALSE) ((xfiltered_relation)))))
                xreverse_path_infos.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).xget_reverse_path_info)).apply)))
                x_get_m2m_db_table.write
                  [xself xopts]
                    memory > xm2m_table_name
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((((xself).xremote_field).xthrough)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((((xself).xremote_field).xthrough).x_meta).xdb_table)))
                          ((xself).xdb_table).if
                            (((unsupported)).apply (((xself).xdb_table)))
                            seq
                              xm2m_table_name.write ("%s_%s".mod (((unsupported)).apply (((((xutils).xstrip_quotes)).apply (((xopts).xdb_table)))) (((xself).xname))))
                              (((unsupported)).apply (((((xutils).xtruncate_name)).apply ((xm2m_table_name)) ((((((xconnection).xops).xmax_name_length)).apply)))))
                x_get_m2m_attr.write
                  [xself xrelated xattr]
                    memory > xcache_attr
                    memory > xlink_field_name
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xcache_attr.write ("_m2m_%s_cache".mod (xattr))
                        (((xhasattr)).apply ((xself)) ((xcache_attr))).if
                          (((unsupported)).apply ((((xgetattr)).apply ((xself)) ((xcache_attr)))))
                        (((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) ("None: is there a None literal in the EO language?")).if
                          xlink_field_name.write (((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) (0))
                          xlink_field_name.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply ((xf)) ((((((xself).xremote_field).xthrough).x_meta).xfields)))
                          ((((xf).xis_relation).and ((((xf).xremote_field).xmodel).eq ((xrelated).xrelated_model))).and ((((unsupported)).apply ((xlink_field_name)) ("None: is there a None literal in the EO language?")).or ((xlink_field_name).eq ((xf).xname)))).if
                            seq
                              bogusForceDataize.write (((xsetattr)).apply ((xself)) ((xcache_attr)) ((((xgetattr)).apply ((xf)) ((xattr)))))
                              (((unsupported)).apply ((((xgetattr)).apply ((xself)) ((xcache_attr)))))
                x_get_m2m_reverse_attr.write
                  [xself xrelated xattr]
                    memory > xcache_attr
                    memory > xfound
                    memory > xlink_field_name
                    seq > @
                      seq
                        (((unsupported)).apply)
                        xcache_attr.write ("_m2m_reverse_%s_cache".mod (xattr))
                        (((xhasattr)).apply ((xself)) ((xcache_attr))).if
                          (((unsupported)).apply ((((xgetattr)).apply ((xself)) ((xcache_attr)))))
                        xfound.write FALSE
                        (((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) ("None: is there a None literal in the EO language?")).if
                          xlink_field_name.write (((unsupported)).apply ((((xself).xremote_field).xthrough_fields)) (1))
                          xlink_field_name.write "None: is there a None literal in the EO language?"
                        (((unsupported)).apply ((xf)) ((((((xself).xremote_field).xthrough).x_meta).xfields)))
                          (((xf).xis_relation).and ((((xf).xremote_field).xmodel).eq ((xrelated).xmodel))).if
                            ((((unsupported)).apply ((xlink_field_name)) ("None: is there a None literal in the EO language?")).and (((xrelated).xrelated_model).eq ((xrelated).xmodel))).if
                              (xfound).if
                                seq
                                  bogusForceDataize.write (((xsetattr)).apply ((xself)) ((xcache_attr)) ((((xgetattr)).apply ((xf)) ((xattr)))))
                                  (((unsupported)).apply)
                                xfound.write TRUE
                              ((((unsupported)).apply ((xlink_field_name)) ("None: is there a None literal in the EO language?")).or ((xlink_field_name).eq ((xf).xname))).if
                                seq
                                  bogusForceDataize.write (((xsetattr)).apply ((xself)) ((xcache_attr)) ((((xgetattr)).apply ((xf)) ((xattr)))))
                                  (((unsupported)).apply)
                        (((unsupported)).apply ((((xgetattr)).apply ((xself)) ((xcache_attr)))))
                xcontribute_to_class.write
                  [xself xcls xname]
                    memory > xresolve_through_model
                    seq > @
                      (((unsupported)).apply)
                        ((((xself).xremote_field).xsymmetrical).and (((((xself).xremote_field).xmodel).eq (xRECURSIVE_RELATIONSHIP_CONSTANT)).or ((((xself).xremote_field).xmodel).eq (((xcls).x_meta).xobject_name)))).if
                          (((unsupported)).apply ((((xself).xremote_field).xrelated_name)) (("%s_rel_-".mod (xname))))
                          (((((xself).xremote_field).xis_hidden)).apply).if
                            (((unsupported)).apply ((((xself).xremote_field).xrelated_name)) (("_%s_%s_%s_-".mod (((unsupported)).apply ((((xcls).x_meta).xapp_label)) ((((((xcls).x__name__).xlower)).apply)) ((xname))))))
                        bogusForceDataize.write ((((((xsuper)).apply).xcontribute_to_class)).apply ((xcls)) ((xname)) ((((unsupported)).apply ((xkwargs)))))
                        ((((xcls).x_meta).xabstract).not).if
                          (((xself).xremote_field).xthrough).if
                            seq
                              xresolve_through_model.write
                                [x_ xmodel xfield]
                                  seq > @
                                    (((unsupported)).apply ((((xfield).xremote_field).xthrough)) ((xmodel)))
                              (((unsupported)).apply ((xlazy_related_operation)) ((xresolve_through_model)) ((xcls)) ((((xself).xremote_field).xthrough)) ((xself)))
                            ((((xcls).x_meta).xswapped).not).if
                              (((unsupported)).apply ((((xself).xremote_field).xthrough)) ((((xcreate_many_to_many_intermediary_model)).apply ((xself)) ((xcls)))))
                        bogusForceDataize.write (((xsetattr)).apply ((xcls)) (((xself).xname)) ((((unsupported)).apply ((xManyToManyDescriptor)) (((xself).xremote_field)) (FALSE))))
                        (((unsupported)).apply (((xself).xm2m_db_table)) ((((xpartial)).apply (((xself).x_get_m2m_db_table)) (((xcls).x_meta)))))
                xcontribute_to_related_class.write
                  [xself xcls xrelated]
                    memory > xget_m2m_rel
                    memory > xget_m2m_reverse_rel
                    seq > @
                      seq
                        (((((((xself).xremote_field).xis_hidden)).apply).not).and (((((xrelated).xrelated_model).x_meta).xswapped).not)).if
                          bogusForceDataize.write (((xsetattr)).apply ((xcls)) (((((xrelated).xget_accessor_name)).apply)) ((((unsupported)).apply ((xManyToManyDescriptor)) (((xself).xremote_field)) (TRUE))))
                        (((unsupported)).apply (((xself).xm2m_column_name)) ((((xpartial)).apply (((xself).x_get_m2m_attr)) ((xrelated)) ("column"))))
                        (((unsupported)).apply (((xself).xm2m_reverse_name)) ((((xpartial)).apply (((xself).x_get_m2m_reverse_attr)) ((xrelated)) ("column"))))
                        (((unsupported)).apply (((xself).xm2m_field_name)) ((((xpartial)).apply (((xself).x_get_m2m_attr)) ((xrelated)) ("name"))))
                        (((unsupported)).apply (((xself).xm2m_reverse_field_name)) ((((xpartial)).apply (((xself).x_get_m2m_reverse_attr)) ((xrelated)) ("name"))))
                        xget_m2m_rel.write (((xpartial)).apply (((xself).x_get_m2m_attr)) ((xrelated)) ("remote_field"))
                        (((unsupported)).apply (((xself).xm2m_target_field_name)) ((((unsupported)).apply (((((xget_m2m_rel)).apply).xfield_name)))))
                        xget_m2m_reverse_rel.write (((xpartial)).apply (((xself).x_get_m2m_reverse_attr)) ((xrelated)) ("remote_field"))
                        (((unsupported)).apply (((xself).xm2m_reverse_target_field_name)) ((((unsupported)).apply (((((xget_m2m_reverse_rel)).apply).xfield_name)))))
                xset_attributes_from_rel.write
                  [xself]
                    seq > @
                xvalue_from_object.write
                  [xself xobj]
                    seq > @
                      (((unsupported)).apply (((((unsupported)).apply (((xobj).xpk)) ("None: is there a None literal in the EO language?")).if (((unsupported)).apply) (((xlist)).apply (((((((xgetattr)).apply ((xobj)) (((xself).xattname))).xall)).apply))))))
                xsave_form_data.write
                  [xself xinstance xdata]
                    seq > @
                      bogusForceDataize.write ((((((xgetattr)).apply ((xinstance)) (((xself).xattname))).xset)).apply ((xdata)))
                xformfield.write
                  [xself xusing]
                    memory > xdefaults
                    memory > xinitial
                    seq > @
                      (((unsupported)).apply)
                        xdefaults.write (((unsupported)).apply ("form_class") (((xforms).xModelMultipleChoiceField)) ("queryset") ((((((((xself).xremote_field).xmodel).x_default_manager).xusing)).apply ((xusing)))) ((xkwargs)))
                        (((unsupported)).apply (((((xdefaults).xget)).apply ("initial"))) ("None: is there a None literal in the EO language?")).if
                          seq
                            xinitial.write (((unsupported)).apply ((xdefaults)) ("initial"))
                            (((xcallable)).apply ((xinitial))).if
                              xinitial.write (((xinitial)).apply)
                            (((unsupported)).apply ((((unsupported)).apply ((xdefaults)) ("initial"))) ((((unsupported)).apply (((xi).xpk)) ((xi)) ((xinitial)))))
                        (((unsupported)).apply (((((((xsuper)).apply).xformfield)).apply ((((unsupported)).apply ((xdefaults)))))))
                xdb_check.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xdb_type.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xdb_parameters.write
                  [xself xconnection]
                    seq > @
                      (((unsupported)).apply ((((unsupported)).apply ("type") ("None: is there a None literal in the EO language?") ("check") ("None: is there a None literal in the EO language?"))))