memory > xd
memory > xAttributeError
memory > xlist
memory > xprocessed
memory > xapps
memory > xno_style
memory > xprocessed_path
memory > xNotImplementedError
memory > xdirs
memory > xFileSystemStorage
memory > xfiles
memory > xgetattr
memory > xstorage
memory > xfalse
memory > xplatform
memory > xp
memory > xget_finders
memory > xpath
memory > xstaticfiles_storage
memory > xany
memory > xBaseCommand
memory > xf
memory > xTags
memory > xException
memory > xhasattr
memory > xsuper
memory > xoriginal_path
memory > xfinder
memory > xargs
memory > xOSError
memory > xos
memory > xsource_file
memory > xinput
memory > xe
memory > xoptions
memory > xkwargs
memory > xisinstance
memory > xCommandError
memory > xlen
[] > collectstatic
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xrequires_system_checks
        memory > xset_options
        memory > xdelete_file
        memory > xis_local_storage
        memory > xcollect
        memory > xhandle
        memory > xclear_dir
        memory > x__init__
        memory > xcopy_file
        memory > xadd_arguments
        memory > xlocal
        memory > xlog
        memory > xlink_file
        memory > xhelp
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply ((xBaseCommand)))
              seq
                (((unsupported)).apply)
                xhelp.write "Collect static files in a single location."
                xrequires_system_checks.write (((unsupported)).apply (((xTags).xstaticfiles)))
                x__init__.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).xcopied_files)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xsymlinked_files)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xunmodified_files)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xpost_processed_files)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xstorage)) ((xstaticfiles_storage)))
                        (((unsupported)).apply (((xself).xstyle)) ((((xno_style)).apply)))
                xlocal.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xNotImplementedError)))
                          bogusForceDataize.write (((((xself).xstorage).xpath)).apply (""))
                          (((unsupported)).apply ((xfalse)))
                        (((unsupported)).apply (TRUE))
                xadd_arguments.write
                  [xself xparser]
                    seq > @
                      seq
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--noinput") ("--no-input") ("store_false") ("interactive") ("Do NOT prompt the user for input of any kind."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--no-post-process") ("store_false") ("post_process") ("Do NOT post process collected files."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("-i") ("--ignore") ("append") ((((unsupported)).apply)) ("ignore_patterns") ("PATTERN") ("Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("-n") ("--dry-run") ("store_true") ("Do everything except modify the filesystem."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("-c") ("--clear") ("store_true") ("Clear the existing files using the storage before trying to copy or link the original file."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("-l") ("--link") ("store_true") ("Create a symbolic link to each file instead of copying."))
                        (((unsupported)).apply (((xparser).xadd_argument)) ("--no-default-ignore") ("store_false") ("use_default_ignore_patterns") ("Don't ignore the common private glob-style patterns (defaults to 'CVS', '.*' and '*~')."))
                xset_options.write
                  [xself]
                    memory > xignore_patterns
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xinteractive)) ((((unsupported)).apply ((xoptions)) ("interactive"))))
                        (((unsupported)).apply (((xself).xverbosity)) ((((unsupported)).apply ((xoptions)) ("verbosity"))))
                        (((unsupported)).apply (((xself).xsymlink)) ((((unsupported)).apply ((xoptions)) ("link"))))
                        (((unsupported)).apply (((xself).xclear)) ((((unsupported)).apply ((xoptions)) ("clear"))))
                        (((unsupported)).apply (((xself).xdry_run)) ((((unsupported)).apply ((xoptions)) ("dry_run"))))
                        xignore_patterns.write (((unsupported)).apply ((xoptions)) ("ignore_patterns"))
                        (((unsupported)).apply ((xoptions)) ("use_default_ignore_patterns")).if
                          (((unsupported)).apply ((xignore_patterns)) ((((((xapps).xget_app_config)).apply ("staticfiles")).xignore_patterns)))
                        (((unsupported)).apply (((xself).xignore_patterns)) ((((xlist)).apply ((((unsupported)).apply ((((((xos).xpath).xnormpath)).apply ((xp)))) ((xp)) ((xignore_patterns)))))))
                        (((unsupported)).apply (((xself).xpost_process)) ((((unsupported)).apply ((xoptions)) ("post_process"))))
                xcollect.write
                  [xself]
                    memory > xfound_files
                    memory > xhandler
                    memory > xprocessor
                    memory > xprefixed_path
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((xself).xsymlink).and (((xself).xlocal).not)).if
                          (((unsupported)).apply ((((xCommandError)).apply ("Can't symlink to a remote destination."))))
                        ((xself).xclear).if
                          bogusForceDataize.write ((((xself).xclear_dir)).apply (""))
                        ((xself).xsymlink).if
                          xhandler.write ((xself).xlink_file)
                          xhandler.write ((xself).xcopy_file)
                        xfound_files.write (((unsupported)).apply)
                        (((unsupported)).apply ((xfinder)) ((((xget_finders)).apply)))
                          (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xstorage)))) (((((xfinder).xlist)).apply (((xself).xignore_patterns)))))
                            seq
                              (((xgetattr)).apply ((xstorage)) ("prefix") ("None: is there a None literal in the EO language?")).if
                                xprefixed_path.write (((((xos).xpath).xjoin)).apply (((xstorage).xprefix)) ((xpath)))
                                xprefixed_path.write (xpath)
                              (((unsupported)).apply ((xprefixed_path)) ((xfound_files))).if
                                seq
                                  (((unsupported)).apply ((((unsupported)).apply ((xfound_files)) ((xprefixed_path)))) ((((unsupported)).apply ((xstorage)) ((xpath)))))
                                  bogusForceDataize.write (((xhandler)).apply ((xpath)) ((xprefixed_path)) ((xstorage)))
                                (((unsupported)).apply (((xself).xlog)) (("Found another file with the destination path '%s'. It will be ignored since only the first encountered file is collected. If this is not what you want, make sure every static file has a unique path.".mod (xprefixed_path))) (1))
                        (((xself).xpost_process).and (((xhasattr)).apply (((xself).xstorage)) ("post_process"))).if
                          seq
                            xprocessor.write (((unsupported)).apply ((((xself).xstorage).xpost_process)) ((xfound_files)) (((xself).xdry_run)))
                            (((unsupported)).apply ((((unsupported)).apply ((xoriginal_path)) ((xprocessed_path)) ((xprocessed)))) ((xprocessor)))
                              seq
                                (((xisinstance)).apply ((xprocessed)) ((xException))).if
                                  seq
                                    bogusForceDataize.write (((((xself).xstderr).xwrite)).apply (("Post-processing '%s' failed!".mod (xoriginal_path))))
                                    bogusForceDataize.write (((((xself).xstderr).xwrite)).apply)
                                    (((unsupported)).apply ((xprocessed)))
                                (xprocessed).if
                                  seq
                                    (((unsupported)).apply (((xself).xlog)) (("Post-processed '%s' as '%s'".mod (((unsupported)).apply ((xoriginal_path)) ((xprocessed_path))))) (2))
                                    bogusForceDataize.write (((((xself).xpost_processed_files).xappend)).apply ((xoriginal_path)))
                                  bogusForceDataize.write ((((xself).xlog)).apply (("Skipped post-processing '%s'".mod (xoriginal_path))))
                        (((unsupported)).apply ((((unsupported)).apply ("modified") ((((xself).xcopied_files).add ((xself).xsymlinked_files))) ("unmodified") (((xself).xunmodified_files)) ("post_processed") (((xself).xpost_processed_files)))))
                xhandle.write
                  [xself]
                    memory > xunmodified_count
                    memory > xmessage
                    memory > xshould_warn_user
                    memory > xcollected
                    memory > xdestination_path
                    memory > xmodified_count
                    memory > xpost_processed_count
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xset_options)).apply ((((unsupported)).apply ((xoptions)))))
                        xmessage.write (((unsupported)).apply ("n"))
                        ((xself).xdry_run).if
                          bogusForceDataize.write ((((xmessage).xappend)).apply ("You have activated the --dry-run option so no files will be modified.nn"))
                        bogusForceDataize.write ((((xmessage).xappend)).apply ("You have requested to collect static files at the destinationnlocation as specified in your settings"))
                        (((((xself).xis_local_storage)).apply).and (((xself).xstorage).xlocation)).if
                          seq
                            xdestination_path.write (((xself).xstorage).xlocation)
                            bogusForceDataize.write ((((xmessage).xappend)).apply ((":nn    %snn".mod (xdestination_path))))
                            xshould_warn_user.write ((((((xself).xstorage).xexists)).apply ((xdestination_path))).and (((xany)).apply ((((((xself).xstorage).xlistdir)).apply ((xdestination_path))))))
                          seq
                            xdestination_path.write "None: is there a None literal in the EO language?"
                            bogusForceDataize.write ((((xmessage).xappend)).apply (".nn"))
                            xshould_warn_user.write TRUE
                        (((xself).xinteractive).and (xshould_warn_user)).if
                          seq
                            ((xself).xclear).if
                              bogusForceDataize.write ((((xmessage).xappend)).apply ("This will DELETE ALL FILES in this location!n"))
                              bogusForceDataize.write ((((xmessage).xappend)).apply ("This will overwrite existing files!n"))
                            bogusForceDataize.write ((((xmessage).xappend)).apply ("Are you sure you want to do this?nnType 'yes' to continue, or 'no' to cancel: "))
                            ((((xinput)).apply (((("".xjoin)).apply ((xmessage))))).neq "yes").if
                              (((unsupported)).apply ((((xCommandError)).apply ("Collecting static files cancelled."))))
                        xcollected.write ((((xself).xcollect)).apply)
                        (((xself).xverbosity).geq 1).if
                          seq
                            xmodified_count.write (((xlen)).apply ((((unsupported)).apply ((xcollected)) ("modified"))))
                            xunmodified_count.write (((xlen)).apply ((((unsupported)).apply ((xcollected)) ("unmodified"))))
                            xpost_processed_count.write (((xlen)).apply ((((unsupported)).apply ((xcollected)) ("post_processed"))))
                            (((unsupported)).apply (("n%(modified_count)s %(identifier)s %(action)s%(destination)s%(unmodified)s%(post_processed)s.".mod (((unsupported)).apply ("modified_count") ((xmodified_count)) ("identifier") (("static file".add (((xmodified_count).eq 1).if "" "s"))) ("action") ((((xself).xsymlink).if "symlinked" "copied")) ("destination") (((xdestination_path).if (" to '%s'".mod (xdestination_path)) "")) ("unmodified") (((((unsupported)).apply ((xcollected)) ("unmodified")).if (", %s unmodified".mod (xunmodified_count)) "")) ("post_processed") ((((((unsupported)).apply ((xcollected)) ("post_processed")).and (", %s post-processed".mod (xpost_processed_count))).or ""))))))
                xlog.write
                  [xself xmsg xlevel]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xself).xverbosity).geq (xlevel)).if
                          bogusForceDataize.write (((((xself).xstdout).xwrite)).apply ((xmsg)))
                xis_local_storage.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((((xisinstance)).apply (((xself).xstorage)) ((xFileSystemStorage)))))
                xclear_dir.write
                  [xself xpath]
                    memory > xfull_path
                    memory > xfpath
                    seq > @
                      seq
                        (((unsupported)).apply)
                        ((((((xself).xstorage).xexists)).apply ((xpath))).not).if
                          (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xdirs)) ((xfiles)))) ((((((xself).xstorage).xlistdir)).apply ((xpath)))))
                        (((unsupported)).apply ((xf)) ((xfiles)))
                          seq
                            xfpath.write (((((xos).xpath).xjoin)).apply ((xpath)) ((xf)))
                            ((xself).xdry_run).if
                              (((unsupported)).apply (((xself).xlog)) (("Pretending to delete '%s'".mod (xfpath))) (1))
                              seq
                                (((unsupported)).apply (((xself).xlog)) (("Deleting '%s'".mod (xfpath))) (1))
                                (((unsupported)).apply ((xNotImplementedError)))
                                  xfull_path.write (((((xself).xstorage).xpath)).apply ((xfpath)))
                                  bogusForceDataize.write (((((xself).xstorage).xdelete)).apply ((xfpath)))
                                  (((((((xos).xpath).xexists)).apply ((xfull_path))).not).and (((((xos).xpath).xlexists)).apply ((xfull_path)))).if
                                    bogusForceDataize.write ((((xos).xunlink)).apply ((xfull_path)))
                                    bogusForceDataize.write (((((xself).xstorage).xdelete)).apply ((xfpath)))
                        (((unsupported)).apply ((xd)) ((xdirs)))
                          bogusForceDataize.write ((((xself).xclear_dir)).apply ((((((xos).xpath).xjoin)).apply ((xpath)) ((xd)))))
                xdelete_file.write
                  [xself xpath xprefixed_path xsource_storage]
                    memory > xcan_skip_unmodified_files
                    memory > xsource_last_modified
                    memory > xtarget_last_modified
                    memory > xfile_is_unmodified
                    memory > xfull_path
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((((xself).xstorage).xexists)).apply ((xprefixed_path))).if
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xOSError)) ((xNotImplementedError)) ((xAttributeError)))))
                              xtarget_last_modified.write (((((xself).xstorage).xget_modified_time)).apply ((xprefixed_path)))
                              (((unsupported)).apply ((((unsupported)).apply ((xOSError)) ((xNotImplementedError)) ((xAttributeError)))))
                                xsource_last_modified.write ((((xsource_storage).xget_modified_time)).apply ((xpath)))
                                seq
                                  ((xself).xlocal).if
                                    seq
                                      xfull_path.write (((((xself).xstorage).xpath)).apply ((xprefixed_path)))
                                      xcan_skip_unmodified_files.write ((((unsupported)).apply (((xself).xsymlink)) ((((((xos).xpath).xislink)).apply ((xfull_path))))).not)
                                    xcan_skip_unmodified_files.write TRUE
                                  xfile_is_unmodified.write ((((unsupported)).apply (((xtarget_last_modified).xreplace)) (0)).geq (((unsupported)).apply (((xsource_last_modified).xreplace)) (0)))
                                  ((xfile_is_unmodified).and (xcan_skip_unmodified_files)).if
                                    seq
                                      (((unsupported)).apply ((xprefixed_path)) (((xself).xunmodified_files))).if
                                        bogusForceDataize.write (((((xself).xunmodified_files).xappend)).apply ((xprefixed_path)))
                                      bogusForceDataize.write ((((xself).xlog)).apply (("Skipping '%s' (not modified)".mod (xpath))))
                                      (((unsupported)).apply ((xfalse)))
                            ((xself).xdry_run).if
                              bogusForceDataize.write ((((xself).xlog)).apply (("Pretending to delete '%s'".mod (xpath))))
                              seq
                                bogusForceDataize.write ((((xself).xlog)).apply (("Deleting '%s'".mod (xpath))))
                                bogusForceDataize.write (((((xself).xstorage).xdelete)).apply ((xprefixed_path)))
                        (((unsupported)).apply (TRUE))
                xlink_file.write
                  [xself xpath xprefixed_path xsource_storage]
                    memory > xfull_path
                    memory > xsource_path
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xprefixed_path)) (((xself).xsymlinked_files))).if
                          (((unsupported)).apply (((((xself).xlog)).apply (("Skipping '%s' (already linked earlier)".mod (xpath))))))
                        (((((xself).xdelete_file)).apply ((xpath)) ((xprefixed_path)) ((xsource_storage))).not).if
                          (((unsupported)).apply)
                        xsource_path.write ((((xsource_storage).xpath)).apply ((xpath)))
                        ((xself).xdry_run).if
                          (((unsupported)).apply (((xself).xlog)) (("Pretending to link '%s'".mod (xsource_path))) (1))
                          seq
                            (((unsupported)).apply (((xself).xlog)) (("Linking '%s'".mod (xsource_path))) (2))
                            xfull_path.write (((((xself).xstorage).xpath)).apply ((xprefixed_path)))
                            (((unsupported)).apply (((xos).xmakedirs)) ((((((xos).xpath).xdirname)).apply ((xfull_path)))) (TRUE))
                            (((unsupported)).apply ((xNotImplementedError)) ((xOSError)))
                              seq
                                (((((xos).xpath).xlexists)).apply ((xfull_path))).if
                                  bogusForceDataize.write ((((xos).xunlink)).apply ((xfull_path)))
                                bogusForceDataize.write ((((xos).xsymlink)).apply ((xsource_path)) ((xfull_path)))
                              seq
                                (((unsupported)).apply)
                                (((unsupported)).apply ((((xCommandError)).apply (("Symlinking is not supported in this platform (%s).".mod ((((xplatform).xplatform)).apply))))))
                              (((unsupported)).apply ((((xCommandError)).apply ((xe)))))
                        (((unsupported)).apply ((xprefixed_path)) (((xself).xsymlinked_files))).if
                          bogusForceDataize.write (((((xself).xsymlinked_files).xappend)).apply ((xprefixed_path)))
                xcopy_file.write
                  [xself xpath xprefixed_path xsource_storage]
                    memory > xsource_path
                    seq > @
                      seq
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xprefixed_path)) (((xself).xcopied_files))).if
                          (((unsupported)).apply (((((xself).xlog)).apply (("Skipping '%s' (already copied earlier)".mod (xpath))))))
                        (((((xself).xdelete_file)).apply ((xpath)) ((xprefixed_path)) ((xsource_storage))).not).if
                          (((unsupported)).apply)
                        xsource_path.write ((((xsource_storage).xpath)).apply ((xpath)))
                        ((xself).xdry_run).if
                          (((unsupported)).apply (((xself).xlog)) (("Pretending to copy '%s'".mod (xsource_path))) (1))
                          seq
                            (((unsupported)).apply (((xself).xlog)) (("Copying '%s'".mod (xsource_path))) (2))
                            (((unsupported)).apply (((((xsource_storage).xopen)).apply ((xpath)))) ((xsource_file)))
                              bogusForceDataize.write (((((xself).xstorage).xsave)).apply ((xprefixed_path)) ((xsource_file)))
                        bogusForceDataize.write (((((xself).xcopied_files).xappend)).apply ((xprefixed_path)))