memory > xLazyObject
memory > xlist
memory > xprocessed
memory > xoriginal_file
memory > x_
memory > xConfiguredStorage
memory > xi
memory > xtuple
memory > xget_storage_class
memory > xContentFile
memory > xRuntimeError
memory > xsubst
memory > xValueError
memory > xmd5
memory > xStaticFilesStorage
memory > xFileNotFoundError
memory > xurlunsplit
memory > xtemplate
memory > xrange
memory > xcheck_settings
memory > xextension
memory > xFileSystemStorage
memory > xmanifest
memory > xsettings
memory > xManifestFilesMixin
memory > xre
memory > xException
memory > xhasattr
memory > xurldefrag
memory > xpattern
memory > xsuper
memory > xsorted
memory > xunquote
memory > xargs
memory > xOSError
memory > xos
memory > xurl_path
memory > xmatches_patterns
memory > xposixpath
memory > xname
memory > xexc
memory > xext
memory > xjson
memory > xchunk
memory > xurlsplit
memory > xHashedFilesMixin
memory > xImproperlyConfigured
memory > xkwargs
memory > xisinstance
memory > xlen
memory > xroot
memory > xstorage
memory > xfragment
[] > storage
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > x_setup
        memory > xload_manifest
        memory > xread_manifest
        memory > xclean_name
        memory > x_url
        memory > xmanifest_version
        memory > xdefault_template
        memory > x__init__
        memory > xhash_key
        memory > xstored_name
        memory > xfile_hash
        memory > xurl
        memory > x_post_process
        memory > xkeep_intermediate_files
        memory > xmax_post_process_passes
        memory > xsave_manifest
        memory > xmanifest_name
        memory > xpath
        memory > xstaticfiles_storage
        memory > x_stored_name
        memory > xpatterns
        memory > xmanifest_strict
        memory > xhashed_name
        memory > xpost_process
        memory > xurl_converter
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            seq
              (((unsupported)).apply)
              (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply ((xFileSystemStorage)))
              seq
                (((unsupported)).apply)
                x__init__.write
                  [xself xlocation xbase_url]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply ((xlocation)) ("None: is there a None literal in the EO language?")).if
                          xlocation.write ((xsettings).xSTATIC_ROOT)
                        (((unsupported)).apply ((xbase_url)) ("None: is there a None literal in the EO language?")).if
                          xbase_url.write ((xsettings).xSTATIC_URL)
                        bogusForceDataize.write (((xcheck_settings)).apply ((xbase_url)))
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((xlocation)) ((xbase_url)) ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        ((xlocation).not).if
                          seq
                            (((unsupported)).apply (((xself).xbase_location)) ("None: is there a None literal in the EO language?"))
                            (((unsupported)).apply (((xself).xlocation)) ("None: is there a None literal in the EO language?"))
                xpath.write
                  [xself xname]
                    seq > @
                      seq
                        (((xself).xlocation).not).if
                          (((unsupported)).apply ((((xImproperlyConfigured)).apply ("You're using the staticfiles app without having set the STATIC_ROOT setting to a filesystem path."))))
                        (((unsupported)).apply (((((((xsuper)).apply).xpath)).apply ((xname)))))
            (((unsupported)).apply)
              seq
                xdefault_template.write "url(\"%(url)s\")"
                xmax_post_process_passes.write 5
                xpatterns.write (((unsupported)).apply ((((unsupported)).apply ("*.css") ((((unsupported)).apply ("(?P<matched>url(['\"]{0,1}s*(?P<url>.*?)[\"']{0,1}))") ((((unsupported)).apply ("(?P<matched>@imports*[\"']s*(?P<url>.*?)[\"'])") ("@import url(\"%(url)s\")"))) ((((unsupported)).apply ("(?m)(?P<matched>)^(/*#[ t](?-i:sourceMappingURL)=(?P<url>.*)[ t]**/)$") ("/*# sourceMappingURL=%(url)s */"))))))) ((((unsupported)).apply ("*.js") ((((unsupported)).apply ((((unsupported)).apply ("(?m)(?P<matched>)^(//# (?-i:sourceMappingURL)=(?P<url>.*))$") ("//# sourceMappingURL=%(url)s"))))))))
                xkeep_intermediate_files.write TRUE
                x__init__.write
                  [xself]
                    memory > xtemplate
                    memory > xcompiled
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply (((xself).x_patterns)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((xself).xhashed_files)) ((((unsupported)).apply)))
                        (((unsupported)).apply ((((unsupported)).apply ((xextension)) ((xpatterns)))) (((xself).xpatterns)))
                          (((unsupported)).apply ((xpattern)) ((xpatterns)))
                            seq
                              (((xisinstance)).apply ((xpattern)) ((((unsupported)).apply ((xtuple)) ((xlist))))).if
                                (((unsupported)).apply ((((unsupported)).apply ((xpattern)) ((xtemplate)))) ((xpattern)))
                                xtemplate.write ((xself).xdefault_template)
                              xcompiled.write ((((xre).xcompile)).apply ((xpattern)) (((xre).xIGNORECASE)))
                              bogusForceDataize.write ((((((((xself).x_patterns).xsetdefault)).apply ((xextension)) ((((unsupported)).apply))).xappend)).apply ((((unsupported)).apply ((xcompiled)) ((xtemplate)))))
                xfile_hash.write
                  [xself xname xcontent]
                    memory > xhasher
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xcontent)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                        xhasher.write (((unsupported)).apply ((xmd5)) (FALSE))
                        (((unsupported)).apply ((xchunk)) (((((xcontent).xchunks)).apply)))
                          bogusForceDataize.write ((((xhasher).xupdate)).apply ((xchunk)))
                        (((unsupported)).apply ((((unsupported)).apply (((((xhasher).xhexdigest)).apply)) ((((unsupported)).apply (12))))))
                xhashed_name.write
                  [xself xname xcontent xfilename]
                    memory > xclean_name
                    memory > xfile_hash
                    memory > xhashed_name
                    memory > xopened
                    memory > xparsed_name
                    memory > xunparsed_name
                    seq > @
                      (((unsupported)).apply)
                        xparsed_name.write (((xurlsplit)).apply ((((xunquote)).apply ((xname)))))
                        xclean_name.write (((((xparsed_name).xpath).xstrip)).apply)
                        xfilename.write (((xfilename).and (((((((xurlsplit)).apply ((((xunquote)).apply ((xfilename))))).xpath).xstrip)).apply)).or (xclean_name))
                        xopened.write (((unsupported)).apply ((xcontent)) ("None: is there a None literal in the EO language?"))
                        (xopened).if
                          seq
                            (((((xself).xexists)).apply ((xfilename))).not).if
                              (((unsupported)).apply ((((xValueError)).apply (("The file '%s' could not be found with %r.".mod (((unsupported)).apply ((xfilename)) ((xself))))))))
                            (((unsupported)).apply ((xOSError)))
                              xcontent.write ((((xself).xopen)).apply ((xfilename)))
                              (((unsupported)).apply ((xname)))
                        (((unsupported)).apply)
                          xfile_hash.write ((((xself).xfile_hash)).apply ((xclean_name)) ((xcontent)))
                          (xopened).if
                            bogusForceDataize.write ((((xcontent).xclose)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xpath)) ((xfilename)))) ((((((xos).xpath).xsplit)).apply ((xclean_name)))))
                        (((unsupported)).apply ((((unsupported)).apply ((xroot)) ((xext)))) ((((((xos).xpath).xsplitext)).apply ((xfilename)))))
                        xfile_hash.write ((xfile_hash).if (".%s".mod (xfile_hash)) "")
                        xhashed_name.write (((((xos).xpath).xjoin)).apply ((xpath)) (("%s%s%s".mod (((unsupported)).apply ((xroot)) ((xfile_hash)) ((xext))))))
                        xunparsed_name.write (((xlist)).apply ((xparsed_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xunparsed_name)) (2))) ((xhashed_name)))
                        ((((unsupported)).apply ("?#") ((xname))).and ((((unsupported)).apply ((xunparsed_name)) (3)).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xunparsed_name)) (2))) ("?"))
                        (((unsupported)).apply ((((xurlunsplit)).apply ((xunparsed_name)))))
                x_url.write
                  [xself xhashed_name_func xname xforce xhashed_files]
                    memory > xfinal_url
                    memory > xhashed_name
                    memory > xurlparts
                    memory > xargs
                    memory > xquery_fragment
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((xsettings).xDEBUG).and ((xforce).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xhashed_name)) ((xfragment)))) ((((unsupported)).apply ((xname)) (""))))
                          seq
                            (((unsupported)).apply ((((unsupported)).apply ((xclean_name)) ((xfragment)))) ((((xurldefrag)).apply ((xname)))))
                            (((((((xurlsplit)).apply ((xclean_name))).xpath).xendswith)).apply ("/")).if
                              xhashed_name.write (xname)
                              seq
                                xargs.write (((unsupported)).apply ((xclean_name)))
                                (((unsupported)).apply ((xhashed_files)) ("None: is there a None literal in the EO language?")).if
                                  (((unsupported)).apply ((xargs)) ((((unsupported)).apply ((xhashed_files)))))
                                xhashed_name.write (((xhashed_name_func)).apply ((((unsupported)).apply ((xargs)))))
                        xfinal_url.write ((((((xsuper)).apply).xurl)).apply ((xhashed_name)))
                        xquery_fragment.write (((unsupported)).apply ("?#") ((xname)))
                        ((xfragment).or (xquery_fragment)).if
                          seq
                            xurlparts.write (((xlist)).apply ((((xurlsplit)).apply ((xfinal_url)))))
                            ((xfragment).and ((((unsupported)).apply ((xurlparts)) (4)).not)).if
                              (((unsupported)).apply ((((unsupported)).apply ((xurlparts)) (4))) ((xfragment)))
                            ((xquery_fragment).and ((((unsupported)).apply ((xurlparts)) (3)).not)).if
                              (((unsupported)).apply ((((unsupported)).apply ((xurlparts)) (2))) ("?"))
                            xfinal_url.write (((xurlunsplit)).apply ((xurlparts)))
                        (((unsupported)).apply ((((xunquote)).apply ((xfinal_url)))))
                xurl.write
                  [xself xname xforce]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply (((((xself).x_url)).apply (((xself).xstored_name)) ((xname)) ((xforce)))))
                xurl_converter.write
                  [xself xname xhashed_files xtemplate]
                    memory > xconverter
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (((unsupported)).apply ((xtemplate)) ("None: is there a None literal in the EO language?")).if
                          xtemplate.write ((xself).xdefault_template)
                        xconverter.write
                          [xmatchobj]
                            memory > xhashed_url
                            memory > xtransformed_url
                            memory > xurl
                            memory > xmatched
                            memory > xmatches
                            memory > xtarget_name
                            memory > xsource_name
                            seq > @
                              seq
                                (((unsupported)).apply)
                                xmatches.write ((((xmatchobj).xgroupdict)).apply)
                                xmatched.write (((unsupported)).apply ((xmatches)) ("matched"))
                                xurl.write (((unsupported)).apply ((xmatches)) ("url"))
                                ((((xre).xmatch)).apply ("^[a-z]+:") ((xurl))).if
                                  (((unsupported)).apply ((xmatched)))
                                (((((xurl).xstartswith)).apply ("/")).and (((((xurl).xstartswith)).apply (((xsettings).xSTATIC_URL))).not)).if
                                  (((unsupported)).apply ((xmatched)))
                                (((unsupported)).apply ((((unsupported)).apply ((xurl_path)) ((xfragment)))) ((((xurldefrag)).apply ((xurl)))))
                                ((((xurl_path).xstartswith)).apply ("/")).if
                                  seq
                                    (((unsupported)).apply (((((xurl_path).xstartswith)).apply (((xsettings).xSTATIC_URL)))))
                                    xtarget_name.write (((unsupported)).apply ((xurl_path)) ((((unsupported)).apply ((((xlen)).apply (((xsettings).xSTATIC_URL)))))))
                                  seq
                                    xsource_name.write ((((xos).xsep).eq "/").if (xname) ((((xname).xreplace)).apply (((xos).xsep)) ("/")))
                                    xtarget_name.write ((((xposixpath).xjoin)).apply (((((xposixpath).xdirname)).apply ((xsource_name)))) ((xurl_path)))
                                xhashed_url.write (((unsupported)).apply (((xself).x_url)) (((xself).x_stored_name)) ((((xunquote)).apply ((xtarget_name)))) (TRUE) ((xhashed_files)))
                                xtransformed_url.write ((("/".xjoin)).apply (((((unsupported)).apply (((((xurl_path).xsplit)).apply ("/"))) ((((unsupported)).apply ((1.neg))))).add (((unsupported)).apply (((((xhashed_url).xsplit)).apply ("/"))) ((((unsupported)).apply ((1.neg))))))))
                                (xfragment).if
                                  (((unsupported)).apply ((xtransformed_url)) ((((((unsupported)).apply ("?#") ((xurl))).if "?#" "#").add (xfragment))))
                                (((unsupported)).apply ((((unsupported)).apply ((xmatches)) ("url"))) ((((xunquote)).apply ((xtransformed_url)))))
                                (((unsupported)).apply (((xtemplate).mod (xmatches))))
                        (((unsupported)).apply ((xconverter)))
                xpost_process.write
                  [xself xpaths xdry_run]
                    memory > xhashed_files
                    memory > xadjustable_paths
                    memory > xprocessed_adjustable_paths
                    memory > xsubstitutions
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply)
                        (xdry_run).if
                          (((unsupported)).apply)
                        xhashed_files.write (((unsupported)).apply)
                        xadjustable_paths.write (((unsupported)).apply ((xpath)) ((xpath)) ((xpaths)) ((((xmatches_patterns)).apply ((xpath)) (((xself).x_patterns)))))
                        xprocessed_adjustable_paths.write (((unsupported)).apply)
                        (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xhashed_name)) ((xprocessed)) ((x_)))) (((((xself).x_post_process)).apply ((xpaths)) ((xadjustable_paths)) ((xhashed_files)))))
                          ((((unsupported)).apply ((xname)) ((xadjustable_paths))).or (((xisinstance)).apply ((xprocessed)) ((xException)))).if
                            (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xhashed_name)) ((xprocessed)))))
                            (((unsupported)).apply ((((unsupported)).apply ((xprocessed_adjustable_paths)) ((xname)))) ((((unsupported)).apply ((xname)) ((xhashed_name)) ((xprocessed)))))
                        xpaths.write (((unsupported)).apply ((xpath)) ((((unsupported)).apply ((xpaths)) ((xpath)))) ((xpath)) ((xadjustable_paths)))
                        xsubstitutions.write FALSE
                        (((unsupported)).apply ((xi)) ((((xrange)).apply (((xself).xmax_post_process_passes)))))
                          seq
                            xsubstitutions.write FALSE
                            (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xhashed_name)) ((xprocessed)) ((xsubst)))) (((((xself).x_post_process)).apply ((xpaths)) ((xadjustable_paths)) ((xhashed_files)))))
                              seq
                                (((unsupported)).apply ((((unsupported)).apply ((xprocessed_adjustable_paths)) ((xname)))) ((((unsupported)).apply ((xname)) ((xhashed_name)) ((xprocessed)))))
                                xsubstitutions.write ((xsubstitutions).or (xsubst))
                            ((xsubstitutions).not).if
                              (((unsupported)).apply)
                        (xsubstitutions).if
                          (((unsupported)).apply ((((unsupported)).apply ("All") ("None: is there a None literal in the EO language?") ((((xRuntimeError)).apply ("Max post-process passes exceeded."))))))
                        bogusForceDataize.write (((((xself).xhashed_files).xupdate)).apply ((xhashed_files)))
                        (((unsupported)).apply (((((xprocessed_adjustable_paths).xvalues)).apply)))
                x_post_process.write
                  [xself xpaths xadjustable_paths xhashed_files]
                    memory > xpath_level
                    memory > xprocessed
                    memory > xcontent
                    memory > xconverter
                    memory > xhashed_name
                    memory > xsubstitutions
                    memory > xsaved_name
                    memory > xcontent_file
                    memory > xcleaned_name
                    memory > xhashed_file_exists
                    memory > xold_hashed_name
                    memory > xhash_key
                    seq > @
                      seq
                        xpath_level.write
                          [xname]
                            seq > @
                              (((unsupported)).apply ((((xlen)).apply (((((xname).xsplit)).apply (((xos).xsep)))))))
                        (((unsupported)).apply ((xname)) ((((unsupported)).apply ((xsorted)) ((xpaths)) ((xpath_level)) (TRUE))))
                          seq
                            xsubstitutions.write TRUE
                            (((unsupported)).apply ((((unsupported)).apply ((xstorage)) ((xpath)))) ((((unsupported)).apply ((xpaths)) ((xname)))))
                            (((unsupported)).apply (((((xstorage).xopen)).apply ((xpath)))) ((xoriginal_file)))
                              seq
                                xcleaned_name.write ((((xself).xclean_name)).apply ((xname)))
                                xhash_key.write ((((xself).xhash_key)).apply ((xcleaned_name)))
                                (((unsupported)).apply ((xhash_key)) ((xhashed_files))).if
                                  xhashed_name.write ((((xself).xhashed_name)).apply ((xname)) ((xoriginal_file)))
                                  xhashed_name.write (((unsupported)).apply ((xhashed_files)) ((xhash_key)))
                                (((xhasattr)).apply ((xoriginal_file)) ("seek")).if
                                  bogusForceDataize.write ((((xoriginal_file).xseek)).apply (0))
                                xhashed_file_exists.write ((((xself).xexists)).apply ((xhashed_name)))
                                xprocessed.write FALSE
                                (((unsupported)).apply ((xname)) ((xadjustable_paths))).if
                                  seq
                                    xold_hashed_name.write (xhashed_name)
                                    xcontent.write (((((((xoriginal_file).xread)).apply).xdecode)).apply ("utf-8"))
                                    (((unsupported)).apply ((((unsupported)).apply ((xextension)) ((xpatterns)))) ((((((xself).x_patterns).xitems)).apply)))
                                      (((xmatches_patterns)).apply ((xpath)) ((((unsupported)).apply ((xextension))))).if
                                        (((unsupported)).apply ((((unsupported)).apply ((xpattern)) ((xtemplate)))) ((xpatterns)))
                                          seq
                                            xconverter.write ((((xself).xurl_converter)).apply ((xname)) ((xhashed_files)) ((xtemplate)))
                                            (((unsupported)).apply ((xValueError)))
                                              xcontent.write ((((xpattern).xsub)).apply ((xconverter)) ((xcontent)))
                                              (((unsupported)).apply ((((unsupported)).apply ((xname)) ("None: is there a None literal in the EO language?") ((xexc)) (FALSE))))
                                    (xhashed_file_exists).if
                                      bogusForceDataize.write ((((xself).xdelete)).apply ((xhashed_name)))
                                    xcontent_file.write (((xContentFile)).apply (((((xcontent).xencode)).apply)))
                                    ((xself).xkeep_intermediate_files).if
                                      bogusForceDataize.write ((((xself).x_save)).apply ((xhashed_name)) ((xcontent_file)))
                                    xhashed_name.write ((((xself).xhashed_name)).apply ((xname)) ((xcontent_file)))
                                    ((((xself).xexists)).apply ((xhashed_name))).if
                                      bogusForceDataize.write ((((xself).xdelete)).apply ((xhashed_name)))
                                    xsaved_name.write ((((xself).x_save)).apply ((xhashed_name)) ((xcontent_file)))
                                    xhashed_name.write ((((xself).xclean_name)).apply ((xsaved_name)))
                                    ((xold_hashed_name).eq (xhashed_name)).if
                                      xsubstitutions.write FALSE
                                    xprocessed.write TRUE
                                ((xprocessed).not).if
                                  ((xhashed_file_exists).not).if
                                    seq
                                      xprocessed.write TRUE
                                      xsaved_name.write ((((xself).x_save)).apply ((xhashed_name)) ((xoriginal_file)))
                                      xhashed_name.write ((((xself).xclean_name)).apply ((xsaved_name)))
                                (((unsupported)).apply ((((unsupported)).apply ((xhashed_files)) ((xhash_key)))) ((xhashed_name)))
                                (((unsupported)).apply ((((unsupported)).apply ((xname)) ((xhashed_name)) ((xprocessed)) ((xsubstitutions)))))
                xclean_name.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply (((((xname).xreplace)).apply ("\\") ("/"))))
                xhash_key.write
                  [xself xname]
                    seq > @
                      (((unsupported)).apply ((xname)))
                x_stored_name.write
                  [xself xname xhashed_files]
                    memory > xcache_name
                    memory > xhash_key
                    memory > xcleaned_name
                    seq > @
                      seq
                        xname.write ((((xposixpath).xnormpath)).apply ((xname)))
                        xcleaned_name.write ((((xself).xclean_name)).apply ((xname)))
                        xhash_key.write ((((xself).xhash_key)).apply ((xcleaned_name)))
                        xcache_name.write ((((xhashed_files).xget)).apply ((xhash_key)))
                        (((unsupported)).apply ((xcache_name)) ("None: is there a None literal in the EO language?")).if
                          xcache_name.write ((((xself).xclean_name)).apply (((((xself).xhashed_name)).apply ((xname)))))
                        (((unsupported)).apply ((xcache_name)))
                xstored_name.write
                  [xself xname]
                    memory > xcache_name
                    memory > xintermediate_name
                    memory > xhash_key
                    memory > xcleaned_name
                    seq > @
                      seq
                        xcleaned_name.write ((((xself).xclean_name)).apply ((xname)))
                        xhash_key.write ((((xself).xhash_key)).apply ((xcleaned_name)))
                        xcache_name.write (((((xself).xhashed_files).xget)).apply ((xhash_key)))
                        (xcache_name).if
                          (((unsupported)).apply ((xcache_name)))
                        xintermediate_name.write (xname)
                        (((unsupported)).apply ((xi)) ((((xrange)).apply ((((xself).xmax_post_process_passes).add 1)))))
                          seq
                            xcache_name.write ((((xself).xclean_name)).apply ((((unsupported)).apply (((xself).xhashed_name)) ((xname)) ("None: is there a None literal in the EO language?") ((xintermediate_name)))))
                            ((xintermediate_name).eq (xcache_name)).if
                              seq
                                (((unsupported)).apply ((((unsupported)).apply (((xself).xhashed_files)) ((xhash_key)))) ((xcache_name)))
                                (((unsupported)).apply ((xcache_name)))
                              xintermediate_name.write (xcache_name)
                        (((unsupported)).apply ((((xValueError)).apply (("The name '%s' could not be hashed with %r.".mod (((unsupported)).apply ((xname)) ((xself))))))))
            (((unsupported)).apply ((xHashedFilesMixin)))
              seq
                xmanifest_version.write "1.0"
                xmanifest_name.write "staticfiles.json"
                xmanifest_strict.write TRUE
                xkeep_intermediate_files.write FALSE
                x__init__.write
                  [xself xmanifest_storage]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((((xsuper)).apply).x__init__)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))
                        (((unsupported)).apply ((xmanifest_storage)) ("None: is there a None literal in the EO language?")).if
                          xmanifest_storage.write (xself)
                        (((unsupported)).apply (((xself).xmanifest_storage)) ((xmanifest_storage)))
                        (((unsupported)).apply (((xself).xhashed_files)) (((((xself).xload_manifest)).apply)))
                xread_manifest.write
                  [xself]
                    seq > @
                      (((unsupported)).apply ((xFileNotFoundError)))
                        (((unsupported)).apply ((((((xself).xmanifest_storage).xopen)).apply (((xself).xmanifest_name)))) ((xmanifest)))
                          (((unsupported)).apply ((((((((xmanifest).xread)).apply).xdecode)).apply)))
                        (((unsupported)).apply ("None: is there a None literal in the EO language?"))
                xload_manifest.write
                  [xself]
                    memory > xstored
                    memory > xversion
                    memory > xcontent
                    seq > @
                      seq
                        xcontent.write ((((xself).xread_manifest)).apply)
                        (((unsupported)).apply ((xcontent)) ("None: is there a None literal in the EO language?")).if
                          (((unsupported)).apply ((((unsupported)).apply)))
                        (((unsupported)).apply (((xjson).xJSONDecodeError)))
                          xstored.write ((((xjson).xloads)).apply ((xcontent)))
                          seq
                            xversion.write ((((xstored).xget)).apply ("version"))
                            ((xversion).eq "1.0").if
                              (((unsupported)).apply (((((xstored).xget)).apply ("paths") ((((unsupported)).apply)))))
                        (((unsupported)).apply ((((xValueError)).apply (("Couldn't load manifest '%s' (version %s)".mod (((unsupported)).apply (((xself).xmanifest_name)) (((xself).xmanifest_version))))))))
                xpost_process.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        (((unsupported)).apply (((xself).xhashed_files)) ((((unsupported)).apply)))
                        (((unsupported)).apply (((((((xsuper)).apply).xpost_process)).apply ((((unsupported)).apply ((xargs)))) ((((unsupported)).apply ((xkwargs)))))))
                        (((((xkwargs).xget)).apply ("dry_run")).not).if
                          bogusForceDataize.write ((((xself).xsave_manifest)).apply)
                xsave_manifest.write
                  [xself]
                    memory > xpayload
                    memory > xcontents
                    seq > @
                      seq
                        xpayload.write (((unsupported)).apply ("paths") (((xself).xhashed_files)) ("version") (((xself).xmanifest_version)))
                        (((((xself).xmanifest_storage).xexists)).apply (((xself).xmanifest_name))).if
                          bogusForceDataize.write (((((xself).xmanifest_storage).xdelete)).apply (((xself).xmanifest_name)))
                        xcontents.write (((((((xjson).xdumps)).apply ((xpayload))).xencode)).apply)
                        bogusForceDataize.write (((((xself).xmanifest_storage).x_save)).apply (((xself).xmanifest_name)) ((((xContentFile)).apply ((xcontents)))))
                xstored_name.write
                  [xself xname]
                    memory > xclean_name
                    memory > xcache_name
                    memory > xparsed_name
                    memory > xhash_key
                    memory > xunparsed_name
                    seq > @
                      seq
                        xparsed_name.write (((xurlsplit)).apply ((((xunquote)).apply ((xname)))))
                        xclean_name.write (((((xparsed_name).xpath).xstrip)).apply)
                        xhash_key.write ((((xself).xhash_key)).apply ((xclean_name)))
                        xcache_name.write (((((xself).xhashed_files).xget)).apply ((xhash_key)))
                        (((unsupported)).apply ((xcache_name)) ("None: is there a None literal in the EO language?")).if
                          seq
                            ((xself).xmanifest_strict).if
                              (((unsupported)).apply ((((xValueError)).apply (("Missing staticfiles manifest entry for '%s'".mod (xclean_name))))))
                            xcache_name.write ((((xself).xclean_name)).apply (((((xself).xhashed_name)).apply ((xname)))))
                        xunparsed_name.write (((xlist)).apply ((xparsed_name)))
                        (((unsupported)).apply ((((unsupported)).apply ((xunparsed_name)) (2))) ((xcache_name)))
                        ((((unsupported)).apply ("?#") ((xname))).and ((((unsupported)).apply ((xunparsed_name)) (3)).not)).if
                          (((unsupported)).apply ((((unsupported)).apply ((xunparsed_name)) (2))) ("?"))
                        (((unsupported)).apply ((((xurlunsplit)).apply ((xunparsed_name)))))
            (((unsupported)).apply ((xManifestFilesMixin)) ((xStaticFilesStorage)))
              seq
                (((unsupported)).apply)
            (((unsupported)).apply ((xLazyObject)))
              x_setup.write
                [xself]
                  seq > @
                    (((unsupported)).apply (((xself).x_wrapped)) ((((((xget_storage_class)).apply (((xsettings).xSTATICFILES_STORAGE)))).apply)))
            xstaticfiles_storage.write (((xConfiguredStorage)).apply)