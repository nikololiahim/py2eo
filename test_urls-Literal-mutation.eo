memory > xnamespace
memory > xdelattr
memory > xhint
memory > xwarning2
memory > xerror
memory > xWarning
memory > xError
memory > xget_warning_for_invalid_pattern
memory > xcheck_url_config
memory > xcheck_url_namespaces_unique
memory > xpath
memory > xsettings
memory > xx
memory > xwarning1
memory > xzip
memory > xE006
memory > xobject
memory > xwarning
memory > xcheck_url_settings
memory > xcode
memory > xnum_params
memory > xlen
memory > xSimpleTestCase
[] > test_urls
  [args...] > unsupported
  [args...] > xunsupported
  memory > bogusForceDataize
  memory > xbogusForceDataize
  memory > xhack
  seq > @
    xhack.write
      []
        memory > xtest_check_unique_namespaces
        memory > xtest_name_with_colon
        memory > xtest_contains_included_tuple
        memory > xtest_media_url_no_slash
        memory > xtest_beginning_with_caret
        memory > xtest_no_root_urlconf_in_settings
        memory > xtest_no_warnings
        memory > xtest_bad_class_based_handlers
        memory > xtest_no_warnings_i18n
        memory > xtest_beginning_with_slash_append_slash
        memory > xtest_slash_no_errors
        memory > xtest_empty_string_no_errors
        memory > xtest_get_warning_for_invalid_pattern_tuple
        memory > xtest_get_warning_for_invalid_pattern_other
        memory > xtest_good_function_based_handlers
        memory > xtest_check_view_not_class
        memory > xtest_beginning_with_slash
        memory > xtest_include_with_dollar
        memory > xtest_get_warning_for_invalid_pattern_string
        memory > xtest_contains_re_named_group
        memory > xtest_bad_function_based_handlers
        memory > xtest_static_url_no_slash
        memory > xtest_ending_with_dollar
        memory > xtest_check_resolver_recursive
        memory > xtest_check_non_unique_namespaces
        memory > xtest_good_class_based_handlers
        memory > xtest_static_url_double_slash_allowed
        memory > xtest_bad_handlers_invalid_path
        memory > xtest_contains_tuple_not_url_instance
        seq > @
          seq
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply)
            (((unsupported)).apply ((xSimpleTestCase)))
              seq
                xtest_no_warnings.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xresult)) ((((unsupported)).apply)))
                xtest_no_warnings_i18n.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply)))
                xtest_check_resolver_recursive.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (1))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("urls.W001"))
                xtest_include_with_dollar.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (1))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("urls.W001"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xmsg)) ("Your URL pattern '^include-with-dollar$' uses include with a route ending with a '$'. Remove the dollar from the route to avoid problems including URLs."))
                xtest_contains_tuple_not_url_instance.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("urls.E004"))
                        bogusForceDataize.write ((((xself).xassertRegex)).apply (((xwarning).xmsg)) ("^Your URL pattern ('^tuple/$', <function <lambda> at 0x(w+)>) is invalid. Ensure that urlpatterns is a list of path() and/or re_path() instances.$"))
                xtest_contains_included_tuple.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("urls.E004"))
                        bogusForceDataize.write ((((xself).xassertRegex)).apply (((xwarning).xmsg)) ("^Your URL pattern ('^tuple/$', <function <lambda> at 0x(w+)>) is invalid. Ensure that urlpatterns is a list of path() and/or re_path() instances.$"))
                xtest_beginning_with_slash.write
                  [xself]
                    memory > xmsg
                    seq > @
                      (((unsupported)).apply)
                        xmsg.write "Your URL pattern '%s' has a route beginning with a '/'. Remove this slash as it is unnecessary. If this pattern is targeted in an include(), ensure the include() pattern has a trailing '/'."
                        (((unsupported)).apply ((((unsupported)).apply ((xwarning1)) ((xwarning2)))) ((((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning1).xid)) ("urls.W002"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning1).xmsg)) (((xmsg).mod "/path-starting-with-slash/")))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning2).xid)) ("urls.W002"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning2).xmsg)) (((xmsg).mod "/url-starting-with-slash/$")))
                xtest_beginning_with_slash_append_slash.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xresult)) ((((unsupported)).apply)))
                xtest_name_with_colon.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    memory > xexpected_msg
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (1))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("urls.W003"))
                        xexpected_msg.write "Your URL pattern '^$' [name='name_with:colon'] has a name including a ':'."
                        bogusForceDataize.write ((((xself).xassertIn)).apply ((xexpected_msg)) (((xwarning).xmsg)))
                xtest_no_root_urlconf_in_settings.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write (((xdelattr)).apply ((xsettings)) ("ROOT_URLCONF"))
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xresult)) ((((unsupported)).apply)))
                xtest_get_warning_for_invalid_pattern_string.write
                  [xself]
                    memory > xwarning
                    seq > @
                      seq
                        xwarning.write (((unsupported)).apply ((((xget_warning_for_invalid_pattern)).apply (""))) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xhint)) ("Try removing the string ''. The list of urlpatterns should not have a prefix string as the first element."))
                xtest_get_warning_for_invalid_pattern_tuple.write
                  [xself]
                    memory > xwarning
                    seq > @
                      seq
                        xwarning.write (((unsupported)).apply ((((xget_warning_for_invalid_pattern)).apply ((((unsupported)).apply ("^$") ((((unsupported)).apply ((xx)))))))) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xhint)) ("Try using path() instead of a tuple."))
                xtest_get_warning_for_invalid_pattern_other.write
                  [xself]
                    memory > xwarning
                    seq > @
                      seq
                        xwarning.write (((unsupported)).apply ((((xget_warning_for_invalid_pattern)).apply ((((xobject)).apply)))) (0))
                        bogusForceDataize.write ((((xself).xassertIsNone)).apply (((xwarning).xhint)))
                xtest_check_non_unique_namespaces.write
                  [xself]
                    memory > xnon_unique_namespaces
                    memory > xwarning_messages
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_namespaces_unique)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (2))
                        xnon_unique_namespaces.write (((unsupported)).apply ("app-ns1") ("app-1"))
                        xwarning_messages.write (((unsupported)).apply (((("URL namespace '{}' isn't unique. You may not be able to reverse all URLs in this namespace".xformat)).apply ((xnamespace)))) ((xnamespace)) ((xnon_unique_namespaces)))
                        (((unsupported)).apply ((xwarning)) ((xresult)))
                          seq
                            bogusForceDataize.write ((((xself).xassertIsInstance)).apply ((xwarning)) ((xWarning)))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ("urls.W005") (((xwarning).xid)))
                            bogusForceDataize.write ((((xself).xassertIn)).apply (((xwarning).xmsg)) ((xwarning_messages)))
                xtest_check_unique_namespaces.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_namespaces_unique)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xresult)) ((((unsupported)).apply)))
                xtest_check_view_not_class.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply ((((unsupported)).apply ((xError)) ("Your URL pattern 'missing_as_view' has an invalid view, pass EmptyCBV.as_view() instead of EmptyCBV.") ("urls.E009"))))))
            (((unsupported)).apply ((xSimpleTestCase)))
              seq
                xtest_contains_re_named_group.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    memory > xexpected_msg
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (1))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("2_0.W001"))
                        xexpected_msg.write (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertIn)).apply ((xexpected_msg)) (((xwarning).xmsg)))
                xtest_beginning_with_caret.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    memory > xexpected_msg
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (1))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("2_0.W001"))
                        xexpected_msg.write "Your URL pattern '^beginning-with-caret' has a route"
                        bogusForceDataize.write ((((xself).xassertIn)).apply ((xexpected_msg)) (((xwarning).xmsg)))
                xtest_ending_with_dollar.write
                  [xself]
                    memory > xresult
                    memory > xwarning
                    memory > xexpected_msg
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (1))
                        xwarning.write (((unsupported)).apply ((xresult)) (0))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply (((xwarning).xid)) ("2_0.W001"))
                        xexpected_msg.write "Your URL pattern 'ending-with-dollar$' has a route"
                        bogusForceDataize.write ((((xself).xassertIn)).apply ((xexpected_msg)) (((xwarning).xmsg)))
            (((unsupported)).apply ((xSimpleTestCase)))
              seq
                xtest_bad_function_based_handlers.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (4))
                        (((unsupported)).apply ((((unsupported)).apply ((xcode)) ((xnum_params)) ((xerror)))) ((((xzip)).apply ((((unsupported)).apply (400) (403) (404) (500))) ((((unsupported)).apply (2) (2) (2) (1))) ((xresult)))))
                          (((unsupported)).apply (((((xself).xsubTest)).apply (((("handler{}".xformat)).apply ((xcode)))))))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerror)) ((((unsupported)).apply ((xError)) (((("The custom handler{} view 'check_framework.urls.bad_function_based_error_handlers.bad_handler' does not take the correct number of arguments (request{}).".xformat)).apply ((xcode)) ((((xnum_params).eq 2).if ", exception" "")))) ("urls.E007"))))
                xtest_bad_class_based_handlers.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xlen)).apply ((xresult)))) (4))
                        (((unsupported)).apply ((((unsupported)).apply ((xcode)) ((xnum_params)) ((xerror)))) ((((xzip)).apply ((((unsupported)).apply (400) (403) (404) (500))) ((((unsupported)).apply (2) (2) (2) (1))) ((xresult)))))
                          (((unsupported)).apply (((((xself).xsubTest)).apply (("handler%s".mod (xcode))))))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerror)) ((((unsupported)).apply ((xError)) (("The custom handler%s view 'check_framework.urls.bad_class_based_error_handlers.HandlerView.as_view.<locals>.view' does not take the correct number of arguments (request%s).".mod (((unsupported)).apply ((xcode)) ((((xnum_params).eq 2).if ", exception" ""))))) ("urls.E007"))))
                xtest_bad_handlers_invalid_path.write
                  [xself]
                    memory > xpaths
                    memory > xresult
                    memory > xhints
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        xpaths.write (((unsupported)).apply ("django.views.bad_handler") ("django.invalid_module.bad_handler") ("invalid_module.bad_handler") ("django"))
                        xhints.write (((unsupported)).apply ("Could not import '{}'. View does not exist in module django.views.") ("Could not import '{}'. Parent module django.invalid_module does not exist.") ("No module named 'invalid_module'") ("Could not import '{}'. The path must be fully qualified."))
                        (((unsupported)).apply ((((unsupported)).apply ((xcode)) ((xpath)) ((xhint)) ((xerror)))) ((((xzip)).apply ((((unsupported)).apply (400) (403) (404) (500))) ((xpaths)) ((xhints)) ((xresult)))))
                          (((unsupported)).apply (((((xself).xsubTest)).apply (((("handler{}".xformat)).apply ((xcode)))))))
                            bogusForceDataize.write ((((xself).xassertEqual)).apply ((xerror)) ((((unsupported)).apply ((xError)) (((("The custom handler{} view '{}' could not be imported.".xformat)).apply ((xcode)) ((xpath)))) (((((xhint).xformat)).apply ((xpath)))) ("urls.E008"))))
                xtest_good_function_based_handlers.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xresult)) ((((unsupported)).apply)))
                xtest_good_class_based_handlers.write
                  [xself]
                    memory > xresult
                    seq > @
                      (((unsupported)).apply)
                        xresult.write (((xcheck_url_config)).apply ("None: is there a None literal in the EO language?"))
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((xresult)) ((((unsupported)).apply)))
            (((unsupported)).apply ((xSimpleTestCase)))
              seq
                xtest_slash_no_errors.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcheck_url_settings)).apply ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply)))
                xtest_empty_string_no_errors.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcheck_url_settings)).apply ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply)))
                xtest_static_url_no_slash.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcheck_url_settings)).apply ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply ((((xE006)).apply ("STATIC_URL"))))))
                xtest_static_url_double_slash_allowed.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcheck_url_settings)).apply ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply)))
                xtest_media_url_no_slash.write
                  [xself]
                    seq > @
                      (((unsupported)).apply)
                        bogusForceDataize.write ((((xself).xassertEqual)).apply ((((xcheck_url_settings)).apply ("None: is there a None literal in the EO language?"))) ((((unsupported)).apply ((((xE006)).apply ("MEDIA_URL"))))))